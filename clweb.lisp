;;;; TANGLED OUTPUT FROM WEB #P"clweb.clw". DO NOT EDIT.
(DEFPACKAGE "CLWEB"
  (:USE "COMMON-LISP")
  (:EXPORT "TANGLE-FILE"
           "LOAD-WEB"
           "WEAVE"
           "LOAD-SECTIONS-FROM-TEMP-FILE"
           "AMBIGUOUS-PREFIX-ERROR"
           "SECTION-NAME-CONTEXT-ERROR"
           "SECTION-NAME-USE-ERROR"
           "SECTION-NAME-DEFINITION-ERROR"
           "UNUSED-NAMED-SECTION-WARNING"))
(IN-PACKAGE "CLWEB")
(EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)
  (REQUIRE 'RT)
  (USE-PACKAGE "RT"))
(DEFINE-CONDITION AMBIGUOUS-PREFIX-ERROR
    (ERROR)
    ((PREFIX :READER AMBIGUOUS-PREFIX :INITARG :PREFIX)
     (FIRST-MATCH :READER AMBIGUOUS-PREFIX-FIRST-MATCH :INITARG :FIRST-MATCH)
     (ALT-MATCH :READER AMBIGUOUS-PREFIX-ALT-MATCH :INITARG :ALT-MATCH))
  (:REPORT
   (LAMBDA (CONDITION STREAM)
     (FORMAT STREAM "~@<Ambiguous prefix: <~A> matches both <~A> and <~A>~:@>"
             (AMBIGUOUS-PREFIX CONDITION)
             (AMBIGUOUS-PREFIX-FIRST-MATCH CONDITION)
             (AMBIGUOUS-PREFIX-ALT-MATCH CONDITION)))))
(DEFINE-CONDITION SIMPLE-READER-ERROR
    (READER-ERROR SIMPLE-CONDITION)
    NIL
  (:REPORT
   (LAMBDA (CONDITION STREAM)
     (FORMAT STREAM "~S on ~S:~%~?" CONDITION (STREAM-ERROR-STREAM CONDITION)
             (SIMPLE-CONDITION-FORMAT-CONTROL CONDITION)
             (SIMPLE-CONDITION-FORMAT-ARGUMENTS CONDITION)))))
(DEFUN SIMPLE-READER-ERROR (STREAM CONTROL &REST ARGS)
  (ERROR 'SIMPLE-READER-ERROR :STREAM STREAM :FORMAT-CONTROL CONTROL
         :FORMAT-ARGUMENTS ARGS))
(DEFINE-CONDITION SECTION-NAME-CONTEXT-ERROR
    (ERROR)
    ((NAME :READER SECTION-NAME :INITARG :NAME)))
(DEFINE-CONDITION SECTION-NAME-DEFINITION-ERROR
    (SECTION-NAME-CONTEXT-ERROR)
    NIL
  (:REPORT
   (LAMBDA (CONDITION STREAM)
     (FORMAT STREAM "Can't define a named section in Lisp mode: ~A"
             (SECTION-NAME CONDITION)))))
(DEFINE-CONDITION SECTION-NAME-USE-ERROR
    (SECTION-NAME-CONTEXT-ERROR)
    NIL
  (:REPORT
   (LAMBDA (CONDITION STREAM)
     (FORMAT STREAM "Can't use a section name in TeX mode: ~A"
             (SECTION-NAME CONDITION)))))
(DEFINE-CONDITION UNUSED-NAMED-SECTION-WARNING
    (SIMPLE-WARNING)
    NIL)
(DEFCLASS SECTION NIL
          ((NAME :ACCESSOR SECTION-NAME :INITARG :NAME)
           (NUMBER :ACCESSOR SECTION-NUMBER)
           (COMMENTARY :ACCESSOR SECTION-COMMENTARY :INITARG :COMMENTARY)
           (TESTP :ACCESSOR TEST-SECTION-P :INITARG :TESTP)
           (CODE :READER SECTION-CODE :INITARG :CODE))
          (:DEFAULT-INITARGS :COMMENTARY NIL :NAME NIL :TESTP NIL :CODE NIL))
(DEFGENERIC (SETF SECTION-CODE)
    (FORMS SECTION &KEY))
(DEFMETHOD (SETF SECTION-CODE) (FORMS (SECTION SECTION) &KEY)
           (SETF (SLOT-VALUE SECTION 'CODE) FORMS))
(DEFCLASS STARRED-SECTION (SECTION) NIL)
(DEFCLASS LIMBO-SECTION (SECTION) NIL)
(DEFVAR *SECTIONS*
  (MAKE-ARRAY 128 :ELEMENT-TYPE 'SECTION :ADJUSTABLE T :FILL-POINTER 0))
(DEFMETHOD INITIALIZE-INSTANCE :AFTER ((SECTION SECTION) &REST INITARGS &KEY)
           (DECLARE (IGNORE INITARGS))
           (SETF (SECTION-NUMBER SECTION)
                   (VECTOR-PUSH-EXTEND SECTION *SECTIONS*)))
(DEFUN CURRENT-SECTION () (ELT *SECTIONS* (1- (FILL-POINTER *SECTIONS*))))
(DEFTEST CURRENT-SECTION (EQL (MAKE-INSTANCE 'SECTION) (CURRENT-SECTION)) T)
(DEFCLASS BINARY-SEARCH-TREE NIL
          ((KEY :ACCESSOR NODE-KEY :INITARG :KEY)
           (VALUE :ACCESSOR NODE-VALUE :INITARG :VALUE)
           (LEFT-CHILD :ACCESSOR LEFT-CHILD :INITARG :LEFT)
           (RIGHT-CHILD :ACCESSOR RIGHT-CHILD :INITARG :RIGHT))
          (:DEFAULT-INITARGS :LEFT NIL :RIGHT NIL))
(DEFGENERIC FIND-OR-INSERT
    (ITEM ROOT &KEY PREDICATE TEST INSERT-IF-NOT-FOUND))
(DEFMETHOD FIND-OR-INSERT
           (ITEM (ROOT BINARY-SEARCH-TREE) &KEY (PREDICATE #'<) (TEST #'EQL)
            (INSERT-IF-NOT-FOUND T))
           (FLET ((LESSP (ITEM NODE)
                    (FUNCALL PREDICATE ITEM (NODE-KEY NODE)))
                  (SAMEP (ITEM NODE)
                    (FUNCALL TEST ITEM (NODE-KEY NODE))))
             (DO ((PARENT NIL NODE)
                  (NODE ROOT
                        (IF (LESSP ITEM NODE)
                            (LEFT-CHILD NODE)
                            (RIGHT-CHILD NODE))))
                 ((OR (NULL NODE) (SAMEP ITEM NODE))
                  (IF NODE
                      (VALUES NODE T)
                      (IF INSERT-IF-NOT-FOUND
                          (LET ((NODE
                                 (MAKE-INSTANCE (CLASS-OF ROOT) :KEY ITEM)))
                            (WHEN PARENT
                              (IF (LESSP ITEM PARENT)
                                  (SETF (LEFT-CHILD PARENT) NODE)
                                  (SETF (RIGHT-CHILD PARENT) NODE)))
                            (VALUES NODE NIL))
                          (VALUES NIL NIL)))))))
(DEFTEST BST
         (LET ((TREE (MAKE-INSTANCE 'BINARY-SEARCH-TREE :KEY 0)))
           (FIND-OR-INSERT -1 TREE)
           (FIND-OR-INSERT 1 TREE)
           (VALUES (NODE-KEY TREE) (NODE-KEY (LEFT-CHILD TREE))
                   (NODE-KEY (RIGHT-CHILD TREE))))
         0 -1 1)
(DEFTEST BST-FIND-NO-INSERT
         (LET ((TREE (MAKE-INSTANCE 'BINARY-SEARCH-TREE :KEY 0)))
           (FIND-OR-INSERT -1 TREE :INSERT-IF-NOT-FOUND NIL))
         NIL NIL)
(DEFCLASS NAMED-SECTION (BINARY-SEARCH-TREE)
          ((KEY :ACCESSOR SECTION-NAME :INITARG :NAME)
           (VALUE :READER SECTION-CODE :INITARG :CODE)
           (NUMBER :ACCESSOR SECTION-NUMBER)
           (USED-BY :ACCESSOR USED-BY :INITFORM 'NIL)
           (SEE-ALSO :ACCESSOR SEE-ALSO :INITFORM 'NIL)))
(DEFMETHOD (SETF SECTION-CODE) (FORMS (SECTION NAMED-SECTION) &KEY (APPENDP T))
           (SETF (SLOT-VALUE SECTION 'VALUE)
                   (IF (AND APPENDP (SLOT-BOUNDP SECTION 'VALUE))
                       (APPEND (SECTION-CODE SECTION) FORMS)
                       FORMS)))
(DEFTEST SET-NAMED-SECTION-CODE
         (LET ((SECTION (MAKE-INSTANCE 'NAMED-SECTION)))
           (SETF (SECTION-CODE SECTION) '(:A :B :C)))
         (:A :B :C))
(DEFTEST APPEND-NAMED-SECTION-CODE
         (LET ((SECTION (MAKE-INSTANCE 'NAMED-SECTION)))
           (SETF (SECTION-CODE SECTION) '(:A))
           (SETF (SECTION-CODE SECTION) '(:B :C)))
         (:A :B :C))
(DEFTEST REPLACE-NAMED-SECTION-CODE
         (LET ((SECTION (MAKE-INSTANCE 'NAMED-SECTION)))
           (SETF (SECTION-CODE SECTION) '(:A :B :C))
           (SETF (SECTION-CODE SECTION :APPENDP NIL) '(:D :E :F)))
         (:D :E :F))
(DEFUN SECTION-NAME-PREFIX-P (NAME)
  (LET ((LEN (LENGTH NAME)))
    (IF (STRING= NAME "..." :START1 (MAX (- LEN 3) 0) :END1 LEN)
        (VALUES T (- LEN 3))
        (VALUES NIL LEN))))
(DEFTEST (SECTION-NAME-PREFIX-P 1) (SECTION-NAME-PREFIX-P "a") NIL 1)
(DEFTEST (SECTION-NAME-PREFIX-P 2) (SECTION-NAME-PREFIX-P "ab...") T 2)
(DEFTEST (SECTION-NAME-PREFIX-P 3) (SECTION-NAME-PREFIX-P "abcd...") T 4)
(DEFUN SECTION-NAME-LESSP (NAME1 NAME2)
  (LET ((LEN1 (NTH-VALUE 1 (SECTION-NAME-PREFIX-P NAME1)))
        (LEN2 (NTH-VALUE 1 (SECTION-NAME-PREFIX-P NAME2))))
    (STRING-LESSP NAME1 NAME2 :END1 LEN1 :END2 LEN2)))
(DEFUN SECTION-NAME-EQUAL (NAME1 NAME2)
  (MULTIPLE-VALUE-BIND (PREFIX-1-P LEN1)
      (SECTION-NAME-PREFIX-P NAME1)
    (MULTIPLE-VALUE-BIND (PREFIX-2-P LEN2)
        (SECTION-NAME-PREFIX-P NAME2)
      (LET ((END (MIN LEN1 LEN2)))
        (IF (OR PREFIX-1-P PREFIX-2-P)
            (STRING-EQUAL NAME1 NAME2 :END1 END :END2 END)
            (STRING-EQUAL NAME1 NAME2))))))
(DEFTEST (SECTION-NAME-LESSP 1) (SECTION-NAME-LESSP "b" "a") NIL)
(DEFTEST (SECTION-NAME-LESSP 2) (SECTION-NAME-LESSP "b..." "a...") NIL)
(DEFTEST (SECTION-NAME-LESSP 3) (SECTION-NAME-LESSP "ab" "a...") NIL)
(DEFTEST (SECTION-NAME-EQUAL 1) (SECTION-NAME-EQUAL "a" "b") NIL)
(DEFTEST (SECTION-NAME-EQUAL 2) (SECTION-NAME-EQUAL "a" "a") T)
(DEFTEST (SECTION-NAME-EQUAL 3) (SECTION-NAME-EQUAL "a..." "ab") T)
(DEFTEST (SECTION-NAME-EQUAL 4) (SECTION-NAME-EQUAL "a..." "ab...") T)
(DEFMETHOD FIND-OR-INSERT
           (ITEM (ROOT NAMED-SECTION) &KEY (PREDICATE #'SECTION-NAME-LESSP)
            (TEST #'SECTION-NAME-EQUAL) (INSERT-IF-NOT-FOUND T))
           (MULTIPLE-VALUE-BIND (NODE PRESENT-P)
               (CALL-NEXT-METHOD ITEM ROOT :PREDICATE PREDICATE :TEST TEST
                :INSERT-IF-NOT-FOUND INSERT-IF-NOT-FOUND)
             (IF PRESENT-P
                 (OR
                  (DOLIST (CHILD (LIST (LEFT-CHILD NODE) (RIGHT-CHILD NODE)))
                    (WHEN CHILD
                      (MULTIPLE-VALUE-BIND (ALT PRESENT-P)
                          (CALL-NEXT-METHOD ITEM CHILD :PREDICATE PREDICATE
                           :TEST TEST :INSERT-IF-NOT-FOUND NIL)
                        (WHEN PRESENT-P
                          (RESTART-CASE (ERROR 'AMBIGUOUS-PREFIX-ERROR :PREFIX
                                               ITEM :FIRST-MATCH
                                               (NODE-KEY NODE) :ALT-MATCH
                                               (NODE-KEY ALT))
                            (USE-FIRST-MATCH NIL :REPORT "Use the first match."
                             (RETURN (VALUES NODE T)))
                            (USE-ALT-MATCH NIL :REPORT "Use alternate match."
                             (RETURN (VALUES ALT T))))))))
                  (VALUES NODE T))
                 (VALUES NODE NIL))))
(DEFVAR *NAMED-SECTIONS* NIL)
(DEFPARAMETER *WHITESPACE*
  #.(COERCE '(#\  #\Tab #\Newline #\Newline #\Page #\Return) 'STRING))
(DEFUN WHITESPACEP (CHAR) (FIND CHAR *WHITESPACE* :TEST #'CHAR=))
(DEFUN SQUEEZE (STRING)
  (LOOP WITH SQUEEZING = NIL
        FOR CHAR ACROSS (STRING-TRIM *WHITESPACE* STRING)
        IF (NOT SQUEEZING)
        IF (WHITESPACEP CHAR)
        DO (SETQ SQUEEZING T)
        AND
        COLLECT #\  INTO CHARS ELSE
        COLLECT CHAR INTO CHARS ELSE
        UNLESS (WHITESPACEP CHAR)
        DO (SETQ SQUEEZING NIL)
        AND
        COLLECT CHAR INTO CHARS
        FINALLY (RETURN (COERCE CHARS 'STRING))))
(DEFTEST (SQUEEZE 1) (SQUEEZE "abc") "abc")
(DEFTEST (SQUEEZE 2) (SQUEEZE "ab c") "ab c")
(DEFTEST (SQUEEZE 3) (SQUEEZE (FORMAT NIL " a b ~C c " #\Tab)) "a b c")
(DEFUN FIND-SECTION (NAME &AUX (NAME (SQUEEZE NAME)))
  (IF (NULL *NAMED-SECTIONS*)
      (VALUES (SETQ *NAMED-SECTIONS* (MAKE-INSTANCE 'NAMED-SECTION :NAME NAME))
              NIL)
      (MULTIPLE-VALUE-BIND (SECTION PRESENT-P)
          (FIND-OR-INSERT NAME *NAMED-SECTIONS*)
        (WHEN PRESENT-P
          (MULTIPLE-VALUE-BIND (NEW-PREFIX-P NEW-LEN)
              (SECTION-NAME-PREFIX-P NAME)
            (MULTIPLE-VALUE-BIND (OLD-PREFIX-P OLD-LEN)
                (SECTION-NAME-PREFIX-P (SECTION-NAME SECTION))
              (WHEN
                  (OR (AND OLD-PREFIX-P (NOT NEW-PREFIX-P))
                      (AND OLD-PREFIX-P NEW-PREFIX-P (< NEW-LEN OLD-LEN)))
                (SETF (SECTION-NAME SECTION) NAME)))))
        (VALUES SECTION PRESENT-P))))
(DEFVAR *TEST-NAMED-SECTIONS*
  (LET ((SECTIONS (MAKE-INSTANCE 'NAMED-SECTION :NAME "baz" :CODE '(BAZ))))
    (SETF (SECTION-CODE (FIND-OR-INSERT "foo" SECTIONS)) '(:FOO))
    (SETF (SECTION-CODE (FIND-OR-INSERT "bar" SECTIONS)) '(:BAR))
    (SETF (SECTION-CODE (FIND-OR-INSERT "qux" SECTIONS)) '(:QUX))
    SECTIONS))
(DEFUN FIND-TEST-SECTION (NAME)
  (FIND-OR-INSERT NAME *TEST-NAMED-SECTIONS* :INSERT-IF-NOT-FOUND NIL))
(DEFTEST FIND-NAMED-SECTION (SECTION-NAME (FIND-TEST-SECTION "bar")) "bar")
(DEFTEST FIND-SECTION-BY-PREFIX (SECTION-NAME (FIND-TEST-SECTION "q...")) "qux")
(DEFTEST FIND-SECTION-BY-AMBIGUOUS-PREFIX
         (SECTION-NAME
          (HANDLER-BIND ((AMBIGUOUS-PREFIX-ERROR
                          (LAMBDA (CONDITION)
                            (DECLARE (IGNORE CONDITION))
                            (INVOKE-RESTART 'USE-ALT-MATCH))))
            (FIND-TEST-SECTION "b...")))
         "bar")
(DEFTEST FIND-SECTION
         (LET ((*NAMED-SECTIONS* *TEST-NAMED-SECTIONS*))
           (FIND-SECTION (FORMAT NIL " foo  bar ~C baz..." #\Tab))
           (SECTION-NAME (FIND-SECTION "foo...")))
         "foo")
(EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)
  (DEFPARAMETER *MODES* '(:LIMBO :TEX :LISP :INNER-LISP :RESTRICTED)))
(DEFTYPE MODE () `(MEMBER ,@*MODES*))
(DEFVAR *READTABLES*
  (LOOP FOR MODE IN (CONS NIL *MODES*)
        COLLECT (CONS MODE (COPY-READTABLE NIL))))
(DEFUN READTABLE-FOR-MODE (MODE)
  (DECLARE (TYPE (OR MODE NULL) MODE))
  (CDR (ASSOC MODE *READTABLES*)))
(DEFTEST (READTABLE-FOR-MODE 1) (READTABLEP (READTABLE-FOR-MODE :TEX)) T)
(DEFTEST (READTABLE-FOR-MODE 2) (READTABLEP (READTABLE-FOR-MODE NIL)) T)
(DEFTEST (READTABLE-FOR-MODE 3)
         (EQL (READTABLE-FOR-MODE :TEX) (READTABLE-FOR-MODE :LISP)) NIL)
(DEFMACRO WITH-MODE (MODE &BODY BODY)
  `(LET ((*READTABLE* (READTABLE-FOR-MODE ,MODE)))
     ,@BODY))
(DEFTEST WITH-MODE
         (LOOP FOR (MODE . READTABLE) IN *READTABLES*
               ALWAYS (WITH-MODE MODE
                        (EQL *READTABLE* READTABLE)))
         T)
(DEFVAR *EOF* (MAKE-SYMBOL "EOF"))
(DEFUN EOF-P (X) (EQ X *EOF*))
(DEFTYPE EOF () '(SATISFIES EOF-P))
(DEFTEST EOF-P (EOF-P (READ-FROM-STRING "" NIL *EOF*)) T)
(DEFTEST EOF-TYPE (TYPEP (READ-FROM-STRING "" NIL *EOF*) 'EOF) T)
(DEFUN TOKEN-DELIMITER-P (CHAR)
  (OR (WHITESPACEP CHAR)
      (MULTIPLE-VALUE-BIND #'NON-TERMINATING-P
          (GET-MACRO-CHARACTER CHAR)
        (AND FUNCTION (NOT NON-TERMINATING-P)))))
(DEFTEST (TOKEN-DELIMITER-P 1) (NOT (TOKEN-DELIMITER-P #\ )) NIL)
(DEFTEST (TOKEN-DELIMITER-P 2) (NOT (TOKEN-DELIMITER-P #\))) NIL)
(DEFCLASS CHARPOS-STREAM NIL
          ((CHARPOS :INITARG :CHARPOS)
           (PROXY-STREAM :ACCESSOR CHARPOS-PROXY-STREAM :INITARG :PROXY))
          (:DEFAULT-INITARGS :CHARPOS 0))
(DEFGENERIC GET-CHARPOS-STREAM-BUFFER
    (STREAM))
(DEFGENERIC CHARPOS
    (STREAM))
(DEFMETHOD CHARPOS ((STREAM CHARPOS-STREAM))
           (LET* ((BUFFER (GET-CHARPOS-STREAM-BUFFER STREAM))
                  (LEN (LENGTH BUFFER))
                  (NEWLINE
                   (POSITION #\Newline BUFFER :TEST #'CHAR= :FROM-END T)))
             (IF NEWLINE
                 (SETF (SLOT-VALUE STREAM 'CHARPOS) (- LEN 1 NEWLINE))
                 (INCF (SLOT-VALUE STREAM 'CHARPOS) LEN))))
(DEFCLASS CHARPOS-INPUT-STREAM (CHARPOS-STREAM) NIL)
(DEFMETHOD SHARED-INITIALIZE :AROUND
           ((INSTANCE CHARPOS-INPUT-STREAM) SLOT-NAMES &REST INITARGS &KEY
            STREAM)
           (APPLY #'CALL-NEXT-METHOD INSTANCE SLOT-NAMES
                  (LIST* :PROXY
                         (MAKE-ECHO-STREAM STREAM
                                           (MAKE-STRING-OUTPUT-STREAM
                                            :ELEMENT-TYPE
                                            (STREAM-ELEMENT-TYPE STREAM)))
                         INITARGS)))
(DEFMETHOD GET-CHARPOS-STREAM-BUFFER ((STREAM CHARPOS-INPUT-STREAM))
           (GET-OUTPUT-STREAM-STRING
            (ECHO-STREAM-OUTPUT-STREAM (CHARPOS-PROXY-STREAM STREAM))))
(DEFCLASS CHARPOS-OUTPUT-STREAM (CHARPOS-STREAM) NIL)
(DEFMETHOD SHARED-INITIALIZE :AROUND
           ((INSTANCE CHARPOS-OUTPUT-STREAM) SLOT-NAMES &REST INITARGS &KEY
            STREAM)
           (APPLY #'CALL-NEXT-METHOD INSTANCE SLOT-NAMES
                  (LIST* :PROXY
                         (MAKE-BROADCAST-STREAM
                          (MAKE-STRING-OUTPUT-STREAM :ELEMENT-TYPE
                                                     (STREAM-ELEMENT-TYPE
                                                      STREAM))
                          STREAM)
                         INITARGS)))
(DEFMETHOD GET-CHARPOS-STREAM-BUFFER ((STREAM CHARPOS-OUTPUT-STREAM))
           (GET-OUTPUT-STREAM-STRING
            (FIRST (BROADCAST-STREAM-STREAMS (CHARPOS-PROXY-STREAM STREAM)))))
(DEFVAR *CHARPOS-STREAMS* (MAKE-HASH-TABLE :TEST #'EQ))
(DEFMETHOD INITIALIZE-INSTANCE :AFTER
           ((INSTANCE CHARPOS-STREAM) &REST INITARGS &KEY)
           (DECLARE (IGNORE INITARGS))
           (SETF (GETHASH (CHARPOS-PROXY-STREAM INSTANCE) *CHARPOS-STREAMS*)
                   INSTANCE))
(DEFUN STREAM-CHARPOS (STREAM)
  (CHARPOS
   (OR (GETHASH STREAM *CHARPOS-STREAMS*)
       (ERROR "Not tracking charpos for ~S" STREAM))))
(DEFUN RELEASE-CHARPOS-STREAM (STREAM)
  (MULTIPLE-VALUE-BIND (CHARPOS-STREAM PRESENT-P)
      (GETHASH STREAM *CHARPOS-STREAMS*)
    (COND
     (PRESENT-P (SETF (CHARPOS-PROXY-STREAM CHARPOS-STREAM) NIL)
      (REMHASH STREAM *CHARPOS-STREAMS*))
     (T (WARN "Not tracking charpos for ~S" STREAM)))))
(DEFUN MAKE-CHARPOS-INPUT-STREAM (INPUT-STREAM &KEY (CHARPOS 0))
  (MAKE-INSTANCE 'CHARPOS-INPUT-STREAM :STREAM
                 (CASE INPUT-STREAM
                   ((T) *TERMINAL-IO*)
                   ((NIL) *STANDARD-INPUT*)
                   (OTHERWISE INPUT-STREAM))
                 :CHARPOS CHARPOS))
(DEFUN MAKE-CHARPOS-OUTPUT-STREAM (OUTPUT-STREAM &KEY (CHARPOS 0))
  (MAKE-INSTANCE 'CHARPOS-OUTPUT-STREAM :STREAM
                 (CASE OUTPUT-STREAM
                   ((T) *TERMINAL-IO*)
                   ((NIL) *STANDARD-OUTPUT*)
                   (OTHERWISE OUTPUT-STREAM))
                 :CHARPOS CHARPOS))
(DEFMACRO WITH-CHARPOS-INPUT-STREAM ((VAR STREAM &KEY (CHARPOS 0)) &BODY BODY)
  `(LET ((,VAR
          (CHARPOS-PROXY-STREAM
           (MAKE-CHARPOS-INPUT-STREAM ,STREAM :CHARPOS ,CHARPOS))))
     (UNWIND-PROTECT (PROGN ,@BODY) (RELEASE-CHARPOS-STREAM ,VAR))))
(DEFMACRO WITH-CHARPOS-OUTPUT-STREAM ((VAR STREAM &KEY (CHARPOS 0)) &BODY BODY)
  `(LET ((,VAR
          (CHARPOS-PROXY-STREAM
           (MAKE-CHARPOS-OUTPUT-STREAM ,STREAM :CHARPOS ,CHARPOS))))
     (UNWIND-PROTECT (PROGN ,@BODY) (RELEASE-CHARPOS-STREAM ,VAR))))
(DEFTEST CHARPOS-INPUT-STREAM
         (WITH-CHARPOS-INPUT-STREAM (S
                                     (MAKE-STRING-INPUT-STREAM
                                      (FORMAT NIL "012~%abc")))
           (VALUES (STREAM-CHARPOS S) (READ-LINE S) (STREAM-CHARPOS S)
                   (READ-CHAR S) (READ-CHAR S) (READ-CHAR S)
                   (STREAM-CHARPOS S)))
         0 "012" 0 #\a #\b #\c 3)
(DEFTEST CHARPOS-OUTPUT-STREAM
         (LET ((STRING-STREAM (MAKE-STRING-OUTPUT-STREAM)))
           (WITH-CHARPOS-OUTPUT-STREAM (S STRING-STREAM)
             (VALUES (STREAM-CHARPOS S)
                     (PROGN (WRITE-STRING "012" S) (STREAM-CHARPOS S))
                     (PROGN (WRITE-CHAR #\Newline S) (STREAM-CHARPOS S))
                     (PROGN (WRITE-STRING "abc" S) (STREAM-CHARPOS S))
                     (GET-OUTPUT-STREAM-STRING STRING-STREAM))))
         0 3 0 3 #.(FORMAT NIL "012~%abc"))
(DEFMACRO WITH-REWIND-STREAM
          ((VAR STREAM &OPTIONAL (REWIND 'REWIND))
           &BODY BODY
           &AUX (OUT (GENSYM)))
  `(WITH-OPEN-STREAM (,OUT (MAKE-STRING-OUTPUT-STREAM))
     (WITH-OPEN-STREAM (,VAR (MAKE-ECHO-STREAM ,STREAM ,OUT))
       (FLET ((,REWIND ,NIL
                (SETQ ,VAR
                        (MAKE-CONCATENATED-STREAM
                         (MAKE-STRING-INPUT-STREAM
                          (GET-OUTPUT-STREAM-STRING ,OUT))
                         ,VAR))))
         ,@BODY))))
(DEFTEST REWIND-STREAM
         (WITH-REWIND-STREAM (S (MAKE-STRING-INPUT-STREAM "abcdef"))
           (VALUES (READ-CHAR S) (READ-CHAR S) (READ-CHAR S)
                   (PROGN (REWIND) (READ-CHAR S))
                   (PROGN (REWIND) (READ-LINE S))))
         #\a #\b #\c #\a "bcdef")
(DEFMACRO READ-WITH-ECHO
          ((STREAM VALUES ECHOED &KEY PREFIX)
           &BODY BODY
           &AUX (OUT (GENSYM)) (ECHO (GENSYM)) (REWIND (GENSYM))
           (RAW-OUTPUT (GENSYM)) (LENGTH (GENSYM)))
  `(WITH-OPEN-STREAM (,OUT (MAKE-STRING-OUTPUT-STREAM))
     (WITH-OPEN-STREAM (,ECHO (MAKE-ECHO-STREAM ,STREAM ,OUT))
       (WITH-OPEN-STREAM
           (,REWIND
            (MAKE-CONCATENATED-STREAM
             ,@(WHEN PREFIX `((MAKE-STRING-INPUT-STREAM ,PREFIX))) ,ECHO))
         (LET* ((,VALUES
                 (MULTIPLE-VALUE-LIST (READ-PRESERVING-WHITESPACE ,REWIND)))
                (,RAW-OUTPUT (GET-OUTPUT-STREAM-STRING ,OUT))
                (,LENGTH (LENGTH ,RAW-OUTPUT))
                (,ECHOED
                 (SUBSEQ ,RAW-OUTPUT ,0
                         (IF (OR (EOF-P (PEEK-CHAR ,NIL ,REWIND NIL *EOF*))
                                 (TOKEN-DELIMITER-P
                                  (ELT ,RAW-OUTPUT (1- ,LENGTH))))
                             ,LENGTH
                             (1- ,LENGTH)))))
           (DECLARE (IGNORABLE ,VALUES ,ECHOED))
           ,@BODY)))))
(DEFTEST READ-WITH-ECHO
         (READ-WITH-ECHO ((MAKE-STRING-INPUT-STREAM ":foo :bar") VALUES CHARS)
           (VALUES VALUES CHARS))
         (:FOO) ":foo ")
(DEFTEST READ-WITH-ECHO-TO-EOF
         (READ-WITH-ECHO ((MAKE-STRING-INPUT-STREAM ":foo") VALUES CHARS)
           (VALUES VALUES CHARS))
         (:FOO) ":foo")
(DEFCLASS MARKER NIL ((VALUE :READER MARKER-VALUE :INITARG :VALUE)))
(DEFUN MARKERP (X) (TYPEP X 'MARKER))
(DEFGENERIC MARKER-BOUNDP
    (MARKER))
(DEFMETHOD MARKER-BOUNDP ((MARKER MARKER)) (SLOT-BOUNDP MARKER 'VALUE))
(DEFVAR *PRINT-MARKER* T)
(DEFMETHOD PRINT-OBJECT ((OBJ MARKER) STREAM)
           (IF *PRINT-MARKER*
               (WHEN (MARKER-BOUNDP OBJ)
                 (WRITE (MARKER-VALUE OBJ) :STREAM STREAM))
               (PRINT-UNREADABLE-OBJECT (OBJ STREAM :TYPE T :IDENTITY T)
                 (WHEN (MARKER-BOUNDP OBJ) (PRINC (MARKER-VALUE OBJ) STREAM)))))
(DEFTEST PRINT-MARKER
         (LET ((*PRINT-MARKER* T))
           (FORMAT NIL "~A" (MAKE-INSTANCE 'MARKER :VALUE ':FOO)))
         "FOO")
(DEFTEST PRINT-MARKER-UNREADABLY
         (LET ((*PRINT-MARKER* NIL) (*PRINT-READABLY* T))
           (HANDLER-CASE (FORMAT NIL "~W" (MAKE-INSTANCE 'MARKER :VALUE ':FOO))
                         (PRINT-NOT-READABLE (CONDITION)
                          (MARKER-VALUE
                           (PRINT-NOT-READABLE-OBJECT CONDITION)))))
         :FOO)
(DEFVAR *EVALUATING* NIL)
(DEFCLASS NEWLINE-MARKER (MARKER)
          ((INDENTATION :ACCESSOR INDENTATION :INITFORM NIL)))
(DEFUN NEWLINEP (OBJ) (TYPEP OBJ 'NEWLINE-MARKER))
(SET-MACRO-CHARACTER #\Newline
                     (LAMBDA (STREAM CHAR)
                       (DECLARE (IGNORE STREAM CHAR))
                       (MAKE-INSTANCE 'NEWLINE-MARKER))
                     NIL (READTABLE-FOR-MODE :LISP))
(DEFTEST READ-NEWLINE
         (NEWLINEP
          (WITH-INPUT-FROM-STRING (S (FORMAT NIL "~%"))
            (WITH-MODE :LISP
              (READ S))))
         T)
(DEFCLASS EMPTY-LIST-MARKER (MARKER) NIL (:DEFAULT-INITARGS :VALUE 'NIL))
(DEFVAR *EMPTY-LIST* (MAKE-INSTANCE 'EMPTY-LIST-MARKER))
(DEFCLASS LIST-MARKER (MARKER)
          ((LENGTH :ACCESSOR LIST-MARKER-LENGTH :INITARG :LENGTH)
           (LIST :ACCESSOR LIST-MARKER-LIST :INITARG :LIST)
           (CHARPOS :ACCESSOR LIST-MARKER-CHARPOS :INITARG :CHARPOS)))
(DEFUN LIST-MARKER-P (OBJ) (TYPEP OBJ 'LIST-MARKER))
(DEFCLASS CONSING-DOT-MARKER (MARKER) NIL)
(DEFVAR *CONSING-DOT* (MAKE-INSTANCE 'CONSING-DOT-MARKER))
(DEFMETHOD MARKER-BOUNDP ((MARKER LIST-MARKER)) T)
(DEFMETHOD MARKER-VALUE ((MARKER LIST-MARKER))
           (DO* ((LIST (LIST NIL))
                 (TAIL LIST)
                 (MARKER-LIST (LIST-MARKER-LIST MARKER) (CDR MARKER-LIST))
                 (X (CAR MARKER-LIST) (CAR MARKER-LIST)))
                ((ENDP MARKER-LIST) (CDR LIST))
             (COND
              ((EQ X *CONSING-DOT*)
               (RPLACD TAIL
                       (DOLIST
                           (X MARKER-LIST (ERROR "Nothing after . in list"))
                         (COND
                          ((AND (MARKERP X) (MARKER-BOUNDP X))
                           (RETURN (MARKER-VALUE X)))
                          ((NOT (MARKERP X)) (RETURN X)))))
               (RETURN (CDR LIST)))
              ((MARKERP X)
               (WHEN (MARKER-BOUNDP X)
                 (LET ((OBJ (LIST (MARKER-VALUE X))))
                   (RPLACD TAIL OBJ)
                   (SETQ TAIL OBJ))))
              (T
               (LET ((OBJ (LIST X)))
                 (RPLACD TAIL OBJ)
                 (SETQ TAIL OBJ))))))
(DEFUN MAKE-LIST-READER (NEXT)
  (LAMBDA (STREAM CHAR)
    (IF (CHAR= (PEEK-CHAR T STREAM T NIL T) #\))
        (PROGN (READ-CHAR STREAM T NIL T) *EMPTY-LIST*)
        (FUNCALL NEXT STREAM CHAR))))
(SET-MACRO-CHARACTER #\( (MAKE-LIST-READER (GET-MACRO-CHARACTER #\( NIL)) NIL
                     (READTABLE-FOR-MODE :INNER-LISP))
(DEFUN LIST-READER (STREAM CHAR)
  (DECLARE (IGNORE CHAR))
  (LOOP WITH LIST = 'NIL
        WITH CHARPOS-LIST = 'NIL
        FOR N FROM 0
        FOR FIRST-CHAR = (PEEK-CHAR T STREAM T NIL
                                    T) AS CHARPOS = (STREAM-CHARPOS STREAM)
        UNTIL (CHAR= FIRST-CHAR #\))
        IF (CHAR= FIRST-CHAR #\.)
        DO (WITH-REWIND-STREAM (STREAM STREAM)
             (READ-CHAR STREAM T)
             (LET ((NEXT-CHAR (READ-CHAR STREAM T)))
               (COND
                ((TOKEN-DELIMITER-P NEXT-CHAR)
                 (UNLESS (OR LIST *READ-SUPPRESS*)
                   (SIMPLE-READER-ERROR STREAM
                                        "Nothing appears before . in list."))
                 (PUSH *CONSING-DOT* LIST) (PUSH CHARPOS CHARPOS-LIST))
                (T (REWIND)
                 (LET ((VALUES (MULTIPLE-VALUE-LIST (READ STREAM T NIL T))))
                   (WHEN VALUES
                     (PUSH (CAR VALUES) LIST)
                     (PUSH CHARPOS CHARPOS-LIST))))))) ELSE
        DO (LET ((VALUES (MULTIPLE-VALUE-LIST (READ STREAM T NIL T))))
             (WHEN VALUES
               (PUSH (CAR VALUES) LIST)
               (PUSH CHARPOS CHARPOS-LIST)))
        FINALLY (READ-CHAR STREAM T NIL T) (RETURN
                                            (MAKE-INSTANCE 'LIST-MARKER :LENGTH
                                                           N :LIST
                                                           (NREVERSE LIST)
                                                           :CHARPOS
                                                           (NREVERSE
                                                            CHARPOS-LIST)))))
(SET-MACRO-CHARACTER #\( (MAKE-LIST-READER #'LIST-READER) NIL
                     (READTABLE-FOR-MODE :LISP))
(DEFMACRO READ-FROM-STRING-WITH-CHARPOS
          (STRING
           &OPTIONAL (EOF-ERROR-P T) (EOF-VALUE NIL)
           &KEY (PRESERVE-WHITESPACE NIL)
           &AUX (STRING-STREAM (GENSYM)) (CHARPOS-STREAM (GENSYM)))
  `(WITH-OPEN-STREAM (,STRING-STREAM (MAKE-STRING-INPUT-STREAM ,STRING))
     (WITH-CHARPOS-INPUT-STREAM (,CHARPOS-STREAM ,STRING-STREAM)
       (IF ,PRESERVE-WHITESPACE
           (READ-PRESERVING-WHITESPACE ,CHARPOS-STREAM ,EOF-ERROR-P ,EOF-VALUE)
           (READ ,CHARPOS-STREAM ,EOF-ERROR-P ,EOF-VALUE)))))
(DEFUN READ-FORM-FROM-STRING (STRING &KEY (MODE :LISP))
  (WITH-MODE MODE
    (READ-FROM-STRING-WITH-CHARPOS STRING)))
(DEFTEST READ-EMPTY-LIST-INNER-LISP
         (TYPEP (READ-FORM-FROM-STRING "()" :MODE :INNER-LISP)
                'EMPTY-LIST-MARKER)
         T)
(DEFTEST READ-EMPTY-LIST
         (TYPEP (READ-FORM-FROM-STRING "()") 'EMPTY-LIST-MARKER) T)
(DEFTEST READ-LIST-INNER-LISP
         (LISTP (READ-FORM-FROM-STRING "(:a :b :c)" :MODE :INNER-LISP)) T)
(DEFTEST READ-LIST (MARKER-VALUE (READ-FORM-FROM-STRING "(:a :b :c)"))
         (:A :B :C))
(DEFTEST READ-DOTTED-LIST (MARKER-VALUE (READ-FORM-FROM-STRING "(:a :b . :c)"))
         (:A :B . :C))
(DEFTEST LIST-MARKER-CHARPOS
         (LIST-MARKER-CHARPOS (READ-FORM-FROM-STRING "(1 2 3)")) (1 3 5))
(DEFCLASS QUOTE-MARKER (MARKER)
          ((QUOTE :READER QUOTE-MARKER-QUOTE :INITARG :QUOTE)
           (FORM :READER QUOTED-FORM :INITARG :FORM)))
(DEFMETHOD MARKER-BOUNDP ((MARKER QUOTE-MARKER)) T)
(DEFMETHOD MARKER-VALUE ((MARKER QUOTE-MARKER))
           (LIST (QUOTE-MARKER-QUOTE MARKER) (QUOTED-FORM MARKER)))
(DEFUN SINGLE-QUOTE-READER (STREAM CHAR)
  (DECLARE (IGNORE CHAR))
  (MAKE-INSTANCE 'QUOTE-MARKER :QUOTE 'QUOTE :FORM (READ STREAM T NIL T)))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-MACRO-CHARACTER #\' #'SINGLE-QUOTE-READER NIL (READTABLE-FOR-MODE MODE)))
(DEFTEST READ-QUOTED-FORM
         (LET ((MARKER (READ-FORM-FROM-STRING "':foo")))
           (VALUES (QUOTED-FORM MARKER) (MARKER-VALUE MARKER)))
         :FOO ':FOO)
(DEFCLASS COMMENT-MARKER (MARKER) ((TEXT :READER COMMENT-TEXT :INITARG :TEXT)))
(DEFUN COMMENT-READER (STREAM CHAR)
  (IF (EQL (PEEK-CHAR NIL STREAM NIL NIL T) #\Newline)
      (PROGN (READ-CHAR STREAM T NIL T) (VALUES))
      (MAKE-INSTANCE 'COMMENT-MARKER :TEXT
                     (WITH-OUTPUT-TO-STRING (S)
                       (WRITE-CHAR CHAR S)
                       (DO ()
                           ((CHAR= (PEEK-CHAR NIL STREAM NIL #\Newline T)
                                   #\Newline))
                         (WRITE-CHAR (READ-CHAR STREAM T NIL T) S))))))
(SET-MACRO-CHARACTER #\; #'COMMENT-READER NIL (READTABLE-FOR-MODE :LISP))
(DEFTEST READ-COMMENT
         (LET ((MARKER (READ-FORM-FROM-STRING "; foo")))
           (VALUES (COMMENT-TEXT MARKER) (MARKER-BOUNDP MARKER)))
         "; foo" NIL)
(DEFTEST SOFT-NEWLINE (READ-FORM-FROM-STRING (FORMAT NIL ";~%:foo")) :FOO)
(DEFCLASS BACKQUOTE-MARKER (MARKER) ((FORM :READER BACKQ-FORM :INITARG :FORM)))
(DEFMETHOD MARKER-BOUNDP ((MARKER BACKQUOTE-MARKER)) T)
(DEFMETHOD MARKER-VALUE ((MARKER BACKQUOTE-MARKER))
           (LET ((*PRINT-PRETTY* NIL)
                 (*PRINT-READABLY* T)
                 (*PRINT-MARKER* T)
                 (*READTABLE* (READTABLE-FOR-MODE NIL)))
             (VALUES (READ-FROM-STRING (PRIN1-TO-STRING MARKER)))))
(DEFMETHOD PRINT-OBJECT ((OBJ BACKQUOTE-MARKER) STREAM)
           (IF *PRINT-MARKER*
               (FORMAT STREAM "`~W" (BACKQ-FORM OBJ))
               (PRINT-UNREADABLE-OBJECT (OBJ STREAM :TYPE T :IDENTITY T))))
(DEFUN BACKQUOTE-READER (STREAM CHAR)
  (DECLARE (IGNORE CHAR))
  (MAKE-INSTANCE 'BACKQUOTE-MARKER :FORM (READ STREAM T NIL T)))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-MACRO-CHARACTER #\` #'BACKQUOTE-READER NIL (READTABLE-FOR-MODE MODE)))
(DEFTEST READ-BACKQUOTE
         (LET ((MARKER (READ-FORM-FROM-STRING "`(:a :b :c)")))
           (AND (TYPEP MARKER 'BACKQUOTE-MARKER) (MARKER-VALUE MARKER)))
         #.(READ-FROM-STRING "`(:a :b :c)"))
(DEFCLASS COMMA-MARKER (MARKER)
          ((FORM :READER COMMA-FORM :INITARG :FORM)
           (MODIFIER :READER COMMA-MODIFIER :INITARG :MODIFIER))
          (:DEFAULT-INITARGS :MODIFIER NIL))
(DEFMETHOD MARKER-BOUNDP ((MARKER COMMA-MARKER)) T)
(DEFMETHOD MARKER-VALUE ((MARKER COMMA-MARKER)) MARKER)
(DEFMETHOD PRINT-OBJECT ((OBJ COMMA-MARKER) STREAM)
           (IF *PRINT-MARKER*
               (FORMAT STREAM ",~@[~C~]~W" (COMMA-MODIFIER OBJ)
                       (COMMA-FORM OBJ))
               (PRINT-UNREADABLE-OBJECT (OBJ STREAM :TYPE T :IDENTITY T))))
(DEFUN COMMA-READER (STREAM CHAR)
  (DECLARE (IGNORE CHAR))
  (CASE (PEEK-CHAR NIL STREAM T NIL T)
    ((#\@ #\.)
     (MAKE-INSTANCE 'COMMA-MARKER :MODIFIER (READ-CHAR STREAM) :FORM
                    (READ STREAM T NIL T)))
    (T (MAKE-INSTANCE 'COMMA-MARKER :FORM (READ STREAM T NIL T)))))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-MACRO-CHARACTER #\, #'COMMA-READER NIL (READTABLE-FOR-MODE MODE)))
(DEFTEST READ-COMMA
         (EVAL (MARKER-VALUE (READ-FORM-FROM-STRING "`(:a ,@'(:b :c) :d)")))
         (:A :B :C :D))
(DEFCLASS FUNCTION-MARKER (QUOTE-MARKER) NIL)
(DEFUN SHARPSIGN-QUOTE-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR ARG))
  (MAKE-INSTANCE 'FUNCTION-MARKER :QUOTE 'FUNCTION :FORM (READ STREAM T NIL T)))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\' #'SHARPSIGN-QUOTE-READER
                                (READTABLE-FOR-MODE MODE)))
(DEFTEST READ-FUNCTION
         (LET ((MARKER (READ-FORM-FROM-STRING "#'identity")))
           (VALUES (QUOTED-FORM MARKER) (MARKER-VALUE MARKER)))
         IDENTITY #'IDENTITY)
(DEFCLASS SIMPLE-VECTOR-MARKER (MARKER)
          ((LENGTH :INITARG :LENGTH) (ELEMENTS :INITARG :ELEMENTS)
           (ELEMENT-TYPE :INITARG :ELEMENT-TYPE))
          (:DEFAULT-INITARGS :ELEMENT-TYPE T))
(DEFMETHOD MARKER-BOUNDP ((MARKER SIMPLE-VECTOR-MARKER)) T)
(DEFMETHOD MARKER-VALUE ((MARKER SIMPLE-VECTOR-MARKER))
           (WITH-SLOTS (ELEMENTS ELEMENT-TYPE)
               MARKER
             (IF (SLOT-BOUNDP MARKER 'LENGTH)
                 (WITH-SLOTS (LENGTH)
                     MARKER
                   (LET ((SUPPLIED-LENGTH (LENGTH ELEMENTS)))
                     (FILL
                      (REPLACE (MAKE-ARRAY LENGTH :ELEMENT-TYPE ELEMENT-TYPE)
                               ELEMENTS)
                      (ELT ELEMENTS (1- SUPPLIED-LENGTH)) :START
                      SUPPLIED-LENGTH)))
                 (COERCE ELEMENTS `(VECTOR ,ELEMENT-TYPE)))))
(DEFUN SIMPLE-VECTOR-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR))
  (LET* ((LIST (READ-DELIMITED-LIST #\) STREAM T))
         (LENGTH
          (HANDLER-CASE (LENGTH LIST)
                        (TYPE-ERROR (ERROR) (DECLARE (IGNORE ERROR))
                         (SIMPLE-READER-ERROR STREAM "improper list in #(): ~S"
                                              LIST)))))
    (UNLESS *READ-SUPPRESS*
      (IF ARG
          (IF (> LENGTH ARG)
              (SIMPLE-READER-ERROR STREAM
                                   "vector longer than specified length: #~S~S"
                                   ARG LIST)
              (MAKE-INSTANCE 'SIMPLE-VECTOR-MARKER :LENGTH ARG :ELEMENTS LIST))
          (MAKE-INSTANCE 'SIMPLE-VECTOR-MARKER :ELEMENTS LIST)))))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\( #'SIMPLE-VECTOR-READER
                                (READTABLE-FOR-MODE MODE)))
(DEFTEST READ-SIMPLE-VECTOR
         (MARKER-VALUE (READ-FORM-FROM-STRING "#5(:a :b :c)"))
         #(:A :B :C :C :C))
(DEFCLASS BIT-VECTOR-MARKER (SIMPLE-VECTOR-MARKER) NIL
          (:DEFAULT-INITARGS :ELEMENT-TYPE 'BIT))
(DEFUN SIMPLE-BIT-VECTOR-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR))
  (LET ((*READTABLE* (READTABLE-FOR-MODE NIL)))
    (READ-WITH-ECHO (STREAM VALUES BITS :PREFIX (FORMAT NIL "#~@[~D~]*" ARG))
      (APPLY #'MAKE-INSTANCE 'BIT-VECTOR-MARKER :ELEMENTS
             (MAP 'BIT-VECTOR (LAMBDA (C) (ECASE C (#\0 0) (#\1 1)))
                  (SUBSEQ BITS 0
                          (LET ((N (LENGTH BITS)))
                            (CASE (ELT BITS (1- N))
                              ((#\0 #\1) N)
                              (T (1- N))))))
             (IF ARG
                 (LIST :LENGTH ARG))))))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\* #'SIMPLE-BIT-VECTOR-READER
                                (READTABLE-FOR-MODE MODE)))
(DEFTEST READ-BIT-VECTOR (MARKER-VALUE (READ-FORM-FROM-STRING "#5*101"))
         #*10111)
(DEFCLASS READ-TIME-EVAL NIL
          ((FORM :READER READ-TIME-EVAL-FORM :INITARG :FORM)))
(DEFMETHOD PRINT-OBJECT ((OBJ READ-TIME-EVAL) STREAM)
           (IF *PRINT-MARKER*
               (FORMAT STREAM "#.~W" (READ-TIME-EVAL-FORM OBJ))
               (PRINT-UNREADABLE-OBJECT (OBJ STREAM :TYPE T :IDENTITY T))))
(DEFCLASS READ-TIME-EVAL-MARKER (READ-TIME-EVAL MARKER) NIL)
(DEFMETHOD MARKER-BOUNDP ((MARKER READ-TIME-EVAL-MARKER)) T)
(DEFMETHOD MARKER-VALUE ((MARKER READ-TIME-EVAL-MARKER))
           (IF *EVALUATING*
               (CALL-NEXT-METHOD)
               (MAKE-INSTANCE 'READ-TIME-EVAL :FORM
                              (READ-TIME-EVAL-FORM MARKER))))
(DEFUN SHARPSIGN-DOT-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR ARG))
  (LET* ((*READTABLE*
          (IF *EVALUATING*
              (READTABLE-FOR-MODE NIL)
              *READTABLE*))
         (FORM (READ STREAM T NIL T)))
    (UNLESS *READ-SUPPRESS*
      (UNLESS *READ-EVAL*
        (SIMPLE-READER-ERROR STREAM "can't read #. while *READ-EVAL* is NIL"))
      (MAKE-INSTANCE 'READ-TIME-EVAL-MARKER :FORM FORM :VALUE (EVAL FORM)))))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\. #'SHARPSIGN-DOT-READER
                                (READTABLE-FOR-MODE MODE)))
(DEFTEST (READ-TIME-EVAL 1)
         (LET* ((*READ-EVAL* T) (*EVALUATING* NIL) (*PRINT-MARKER* T))
           (PRIN1-TO-STRING
            (MARKER-VALUE (READ-FORM-FROM-STRING "#.(+ 1 1)"))))
         "#.(+ 1 1)")
(DEFTEST (READ-TIME-EVAL 2)
         (LET* ((*READ-EVAL* T) (*EVALUATING* T))
           (MARKER-VALUE (READ-FORM-FROM-STRING "#.(+ 1 1)")))
         2)
(DEFCLASS RADIX-MARKER (MARKER)
          ((BASE :READER RADIX-MARKER-BASE :INITARG :BASE)))
(DEFVAR *RADIX-PREFIX-ALIST* '((#\B . 2) (#\O . 8) (#\X . 16) (#\R)))
(DEFUN RADIX-READER (STREAM SUB-CHAR ARG)
  (MAKE-INSTANCE 'RADIX-MARKER :BASE
                 (OR (CDR (ASSOC SUB-CHAR *RADIX-PREFIX-ALIST*)) ARG) :VALUE
                 (FUNCALL
                  (GET-DISPATCH-MACRO-CHARACTER #\# SUB-CHAR
                                                (READTABLE-FOR-MODE NIL))
                  STREAM SUB-CHAR ARG)))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (DOLIST (SUB-CHAR '(#\B #\O #\X #\R))
    (SET-DISPATCH-MACRO-CHARACTER #\# SUB-CHAR #'RADIX-READER
                                  (READTABLE-FOR-MODE MODE))))
(DEFTEST (READ-RADIX 1)
         (LET ((MARKER (READ-FORM-FROM-STRING "#B1011")))
           (VALUES (RADIX-MARKER-BASE MARKER) (MARKER-VALUE MARKER)))
         2 11)
(DEFTEST (READ-RADIX 2)
         (LET ((MARKER (READ-FORM-FROM-STRING "#14R11")))
           (VALUES (RADIX-MARKER-BASE MARKER) (MARKER-VALUE MARKER)))
         14 15)
(DEFCLASS STRUCTURE-MARKER (MARKER)
          ((FORM :READER STRUCTURE-MARKER-FORM :INITARG :FORM)))
(DEFMETHOD MARKER-BOUNDP ((MARKER STRUCTURE-MARKER)) T)
(DEFMETHOD MARKER-VALUE ((MARKER STRUCTURE-MARKER))
           (LET ((*PRINT-PRETTY* NIL)
                 (*PRINT-READABLY* T)
                 (*PRINT-MARKER* T)
                 (*READTABLE* (READTABLE-FOR-MODE NIL)))
             (VALUES (READ-FROM-STRING (PRIN1-TO-STRING MARKER)))))
(DEFMETHOD PRINT-OBJECT ((OBJ STRUCTURE-MARKER) STREAM)
           (IF *PRINT-MARKER*
               (FORMAT STREAM "#S~W" (STRUCTURE-MARKER-FORM OBJ))
               (PRINT-UNREADABLE-OBJECT (OBJ STREAM :TYPE T :IDENTITY T))))
(DEFUN STRUCTURE-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR ARG))
  (MAKE-INSTANCE 'STRUCTURE-MARKER :FORM (READ STREAM T NIL T)))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\S #'STRUCTURE-READER
                                (READTABLE-FOR-MODE MODE)))
(DEFUN FEATUREP (X)
  (ETYPECASE X
    (CONS
     (CASE (CAR X)
       ((:NOT NOT)
        (COND
         ((CDDR X)
          (ERROR "too many subexpressions in feature expression: ~S" X))
         ((NULL (CDR X))
          (ERROR "too few subexpressions in feature expression: ~S" X))
         (T (NOT (FEATUREP (CADR X))))))
       ((:AND AND) (EVERY #'FEATUREP (CDR X)))
       ((:OR OR) (SOME #'FEATUREP (CDR X)))
       (T (ERROR "unknown operator in feature expression: ~S." X))))
    (SYMBOL (NOT (NULL (MEMBER X *FEATURES* :TEST #'EQ))))))
(DEFTEST FEATUREP
         (LET ((*FEATURES* '(:A :B)))
           (FEATUREP '(:AND :A (:OR :C :B) (:NOT :D))))
         T)
(DEFCLASS READ-TIME-CONDITIONAL NIL
          ((PLUSP :READER READ-TIME-CONDITIONAL-PLUSP :INITARG :PLUSP)
           (TEST :READER READ-TIME-CONDITIONAL-TEST :INITARG :TEST)
           (FORM :READER READ-TIME-CONDITIONAL-FORM :INITARG :FORM)))
(DEFMETHOD PRINT-OBJECT ((OBJ READ-TIME-CONDITIONAL) STREAM)
           (IF *PRINT-MARKER*
               (FORMAT STREAM "#~:[-~;+~]~S ~A"
                       (READ-TIME-CONDITIONAL-PLUSP OBJ)
                       (READ-TIME-CONDITIONAL-TEST OBJ)
                       (READ-TIME-CONDITIONAL-FORM OBJ))
               (PRINT-UNREADABLE-OBJECT (OBJ STREAM :TYPE T :IDENTITY T))))
(DEFCLASS READ-TIME-CONDITIONAL-MARKER (READ-TIME-CONDITIONAL MARKER) NIL)
(DEFMETHOD MARKER-BOUNDP ((MARKER READ-TIME-CONDITIONAL-MARKER))
           (IF *EVALUATING*
               (CALL-NEXT-METHOD)
               T))
(DEFMETHOD MARKER-VALUE ((MARKER READ-TIME-CONDITIONAL-MARKER))
           (IF *EVALUATING*
               (CALL-NEXT-METHOD)
               (MAKE-INSTANCE 'READ-TIME-CONDITIONAL :PLUSP
                              (READ-TIME-CONDITIONAL-PLUSP MARKER) :TEST
                              (READ-TIME-CONDITIONAL-TEST MARKER) :FORM
                              (READ-TIME-CONDITIONAL-FORM MARKER))))
(DEFUN READ-TIME-CONDITIONAL-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE ARG))
  (LET* ((PLUSP (ECASE SUB-CHAR (#\+ T) (#\- NIL)))
         (*READTABLE* (READTABLE-FOR-MODE NIL))
         (TEST
          (LET ((*PACKAGE* (FIND-PACKAGE "KEYWORD")) (*READ-SUPPRESS* NIL))
            (READ STREAM T NIL T)))
         (*READ-SUPPRESS*
          (IF PLUSP
              (NOT (FEATUREP TEST))
              (FEATUREP TEST))))
    (PEEK-CHAR T STREAM T NIL T)
    (READ-WITH-ECHO (STREAM VALUES FORM)
      (APPLY #'MAKE-INSTANCE 'READ-TIME-CONDITIONAL-MARKER :PLUSP PLUSP :TEST
             TEST :FORM FORM
             (AND (NOT *READ-SUPPRESS*) VALUES (LIST :VALUE (CAR VALUES)))))))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\+ #'READ-TIME-CONDITIONAL-READER
                                (READTABLE-FOR-MODE MODE))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\- #'READ-TIME-CONDITIONAL-READER
                                (READTABLE-FOR-MODE MODE)))
(DEFTEST (READ-TIME-CONDITIONAL 1)
         (LET ((*FEATURES* '(:A)) (*EVALUATING* NIL) (*PRINT-MARKER* T))
           (VALUES
            (PRIN1-TO-STRING (MARKER-VALUE (READ-FORM-FROM-STRING "#+a 1")))
            (PRIN1-TO-STRING (MARKER-VALUE (READ-FORM-FROM-STRING "#-a 1")))))
         "#+:A 1" "#-:A 1")
(DEFTEST (READ-TIME-CONDITIONAL 2)
         (LET ((*FEATURES* '(:A)) (*EVALUATING* T))
           (VALUES (MARKER-VALUE (READ-FORM-FROM-STRING "#+a 1"))
                   (MARKER-VALUE (READ-FORM-FROM-STRING "#-b 2"))
                   (MARKER-BOUNDP (READ-FORM-FROM-STRING "#-a 1"))
                   (MARKER-BOUNDP (READ-FORM-FROM-STRING "#+b 2"))))
         1 2 NIL NIL)
(DEFUN SNARF-UNTIL-CONTROL-CHAR
       (STREAM CONTROL-CHARS
        &AUX
        (CONTROL-CHARS
         (IF (LISTP CONTROL-CHARS)
             CONTROL-CHARS
             (LIST CONTROL-CHARS))))
  (WITH-OUTPUT-TO-STRING (STRING)
    (LOOP FOR CHAR = (PEEK-CHAR NIL STREAM NIL *EOF* NIL)
          UNTIL (OR (EOF-P CHAR) (MEMBER CHAR CONTROL-CHARS))
          DO (WRITE-CHAR (READ-CHAR STREAM) STRING))))
(DEFTEST SNARF-UNTIL-CONTROL-CHAR
         (WITH-INPUT-FROM-STRING (S "abc*123")
           (VALUES (SNARF-UNTIL-CONTROL-CHAR S #\*)
                   (SNARF-UNTIL-CONTROL-CHAR S '(#\a #\3))))
         "abc" "*12")
(DEFUN READ-INNER-LISP (STREAM CHAR)
  (WITH-MODE :INNER-LISP
    (READ-DELIMITED-LIST CHAR STREAM T)))
(DOLIST (MODE '(:TEX :RESTRICTED))
  (SET-MACRO-CHARACTER #\| #'READ-INNER-LISP NIL (READTABLE-FOR-MODE MODE)))
(DEFTEST READ-INNER-LISP
         (WITH-MODE :TEX
           (VALUES (READ-FROM-STRING "|:foo :bar|")))
         (:FOO :BAR))
(SET-MACRO-CHARACTER #\| (GET-MACRO-CHARACTER #\) NIL) NIL
                     (READTABLE-FOR-MODE :INNER-LISP))
(DOLIST (MODE *MODES*)
  (IGNORE-ERRORS
   (MAKE-DISPATCH-MACRO-CHARACTER #\@ T (READTABLE-FOR-MODE MODE))))
(DEFUN GET-CONTROL-CODE (SUB-CHAR MODE)
  (GET-DISPATCH-MACRO-CHARACTER #\@ SUB-CHAR (READTABLE-FOR-MODE MODE)))
(DEFUN SET-CONTROL-CODE (SUB-CHAR FUNCTION &OPTIONAL (MODES *MODES*))
  (DOLIST
      (MODE
       (IF (LISTP MODES)
           MODES
           (LIST MODES)))
    (SET-DISPATCH-MACRO-CHARACTER #\@ SUB-CHAR FUNCTION
                                  (READTABLE-FOR-MODE MODE))))
(SET-CONTROL-CODE #\@
                  (LAMBDA (STREAM SUB-CHAR ARG)
                    (DECLARE (IGNORE SUB-CHAR STREAM ARG))
                    (STRING "@")))
(DEFTEST LITERAL-@
         (WITH-MODE :TEX
           (VALUES (READ-FROM-STRING "@@")))
         "@")
(DEFUN START-SECTION-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE STREAM ARG))
  (MAKE-INSTANCE (ECASE SUB-CHAR (#\  'SECTION) (#\* 'STARRED-SECTION))))
(DOLIST (SUB-CHAR '(#\  #\*))
  (SET-CONTROL-CODE SUB-CHAR #'START-SECTION-READER '(:LIMBO :TEX :LISP)))
(DEFCLASS START-CODE-MARKER (MARKER)
          ((NAME :READER SECTION-NAME :INITARG :NAME)
           (TESTP :READER TEST-CODE-P :INITARG :TESTP))
          (:DEFAULT-INITARGS :NAME NIL :TESTP NIL))
(DEFUN START-CODE-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE STREAM ARG))
  (MAKE-INSTANCE 'START-CODE-MARKER :TESTP
                 (CHAR= (CHAR-DOWNCASE SUB-CHAR) #\t)))
(DOLIST (SUB-CHAR '(#\l #\p #\t))
  (SET-CONTROL-CODE SUB-CHAR #'START-CODE-READER '(:TEX :LISP)))
(DEFTEST (START-CODE-MARKER 1)
         (WITH-MODE :TEX
           (VALUES-LIST
            (MAPCAR
             (LAMBDA (MARKER)
               (AND (TYPEP MARKER 'START-CODE-MARKER)
                    (NOT (TEST-CODE-P MARKER))))
             (LIST (READ-FROM-STRING "@l") (READ-FROM-STRING "@p")))))
         T T)
(DEFTEST (START-CODE-MARKER 2)
         (WITH-MODE :TEX
           (TEST-CODE-P (READ-FROM-STRING "@t")))
         T)
(DEFCLASS EVALUATED-FORM-MARKER (MARKER) NIL)
(DEFUN READ-EVALUATED-FORM (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR ARG))
  (LOOP FOR FORM = (READ STREAM T NIL T)
        UNTIL (NOT (NEWLINEP FORM))
        FINALLY (RETURN (MAKE-INSTANCE 'EVALUATED-FORM-MARKER :VALUE FORM))))
(SET-CONTROL-CODE #\e #'READ-EVALUATED-FORM :LISP)
(DEFTEST READ-EVALUATED-FORM
         (LET ((MARKER (READ-FORM-FROM-STRING (FORMAT NIL "@e~%1"))))
           (AND (TYPEP MARKER 'EVALUATED-FORM-MARKER) (MARKER-VALUE MARKER)))
         1)
(DEFVAR *END-CONTROL-TEXT* (MAKE-SYMBOL "@>"))
(SET-CONTROL-CODE #\> (CONSTANTLY *END-CONTROL-TEXT*) :RESTRICTED)
(DEFUN READ-CONTROL-TEXT
       (STREAM &OPTIONAL (EOF-ERROR-P T) (EOF-VALUE NIL) (RECURSIVE-P NIL))
  (WITH-MODE :RESTRICTED
    (APPLY #'CONCATENATE 'STRING
           (LOOP FOR TEXT = (SNARF-UNTIL-CONTROL-CHAR STREAM
                                                      #\@) AS X = (READ-PRESERVING-WHITESPACE
                                                                   STREAM
                                                                   EOF-ERROR-P
                                                                   EOF-VALUE
                                                                   RECURSIVE-P)
                 COLLECT TEXT
                 IF (EQ X *END-CONTROL-TEXT*)
                 DO (LOOP-FINISH) ELSE
                 COLLECT X))))
(DEFTEST READ-CONTROL-TEXT
         (WITH-INPUT-FROM-STRING (S "frob |foo|@>") (READ-CONTROL-TEXT S))
         "frob |foo|")
(DEFUN MAKE-SECTION-NAME-READER (DEFINITION-ALLOWED-P)
  (LAMBDA (STREAM SUB-CHAR ARG)
    (DECLARE (IGNORE SUB-CHAR ARG))
    (LET* ((NAME (READ-CONTROL-TEXT STREAM T NIL T))
           (DEFINITIONP (EQL (PEEK-CHAR NIL STREAM NIL NIL T) #\=)))
      (IF DEFINITIONP
          (IF DEFINITION-ALLOWED-P
              (PROGN
               (READ-CHAR STREAM)
               (MAKE-INSTANCE 'START-CODE-MARKER :NAME NAME))
              (RESTART-CASE (ERROR 'SECTION-NAME-DEFINITION-ERROR :NAME NAME)
                (USE-SECTION NIL :REPORT
                 "Don't define the section, just use it."
                 (FIND-SECTION NAME))))
          (IF DEFINITION-ALLOWED-P
              (RESTART-CASE (ERROR 'SECTION-NAME-USE-ERROR :NAME NAME)
                (NAME-SECTION NIL :REPORT
                 "Name the current section and start the code part."
                 (MAKE-INSTANCE 'START-CODE-MARKER :NAME NAME))
                (CITE-SECTION NIL :REPORT
                 "Assume the section is just being cited."
                 (FIND-SECTION NAME)))
              (LET ((NAMED-SECTION (FIND-SECTION NAME)))
                (PUSHNEW (CURRENT-SECTION) (USED-BY NAMED-SECTION))
                NAMED-SECTION))))))
(SET-CONTROL-CODE #\< (MAKE-SECTION-NAME-READER T) :TEX)
(SET-CONTROL-CODE #\< (MAKE-SECTION-NAME-READER NIL) '(:LISP :INNER-LISP))
(DEFTEST (READ-SECTION-NAME :TEX)
         (WITH-MODE :TEX
           (SECTION-NAME (READ-FROM-STRING "@<foo@>=")))
         "foo")
(DEFTEST (READ-SECTION-NAME :LISP)
         (LET ((*NAMED-SECTIONS* *TEST-NAMED-SECTIONS*))
           (WITH-MODE :LISP
             (SECTION-NAME (READ-FROM-STRING "@<foo@>"))))
         "foo")
(DEFTEST SECTION-NAME-DEFINITION-ERROR
         (LET ((*NAMED-SECTIONS* *TEST-NAMED-SECTIONS*))
           (SECTION-NAME
            (HANDLER-BIND ((SECTION-NAME-DEFINITION-ERROR
                            (LAMBDA (CONDITION)
                              (DECLARE (IGNORE CONDITION))
                              (INVOKE-RESTART 'USE-SECTION))))
              (WITH-MODE :LISP
                (READ-FROM-STRING "@<foo@>=")))))
         "foo")
(DEFTEST SECTION-NAME-USE-ERROR
         (LET ((*NAMED-SECTIONS* *TEST-NAMED-SECTIONS*))
           (SECTION-NAME
            (HANDLER-BIND ((SECTION-NAME-USE-ERROR
                            (LAMBDA (CONDITION)
                              (DECLARE (IGNORE CONDITION))
                              (INVOKE-RESTART 'CITE-SECTION))))
              (WITH-MODE :TEX
                (READ-FROM-STRING "@<foo@>")))))
         "foo")
(DEFCLASS PAR-MARKER (NEWLINE-MARKER) NIL)
(DEFVAR *PAR* (MAKE-INSTANCE 'PAR-MARKER))
(DEFMACRO MAYBE-PUSH (OBJ PLACE &AUX (G (GENSYM)))
  `(LET ((,G ,OBJ))
     (WHEN
         (IF (STRINGP ,G)
             (PLUSP (LENGTH ,G))
             ,G)
       (PUSH ,G ,PLACE))))
(DEFTEST MAYBE-PUSH
         (LET ((LIST 'NIL))
           (MAYBE-PUSH 'A LIST)
           (MAYBE-PUSH NIL LIST)
           (MAYBE-PUSH "" LIST)
           (MAYBE-PUSH 'B LIST)
           LIST)
         (B A))
(DEFUN READ-SECTIONS (INPUT-STREAM &KEY (APPENDP T))
  (WITH-CHARPOS-INPUT-STREAM (STREAM INPUT-STREAM)
    (FLET ((FINISH-SECTION (SECTION COMMENTARY CODE)
             (WHEN (STRINGP (CAR COMMENTARY))
               (RPLACA COMMENTARY
                       (STRING-RIGHT-TRIM *WHITESPACE* (CAR COMMENTARY))))
             (SETQ COMMENTARY (NREVERSE COMMENTARY))
             (WHEN (STRINGP (CAR COMMENTARY))
               (RPLACA COMMENTARY
                       (STRING-LEFT-TRIM *WHITESPACE* (CAR COMMENTARY))))
             (SETQ CODE (NREVERSE (MEMBER-IF-NOT #'NEWLINEP CODE)))
             (SETF (SECTION-COMMENTARY SECTION) COMMENTARY)
             (SETF (SECTION-CODE SECTION) CODE)
             (WHEN (SECTION-NAME SECTION)
               (LET ((NAMED-SECTION (FIND-SECTION (SECTION-NAME SECTION)))
                     (NUMBER (SECTION-NUMBER SECTION))
                     (CODE (SECTION-CODE SECTION)))
                 (SETF (SECTION-CODE NAMED-SECTION :APPENDP APPENDP) CODE)
                 (WHEN
                     (OR (NOT (SLOT-BOUNDP NAMED-SECTION 'NUMBER))
                         (NOT APPENDP))
                   (SETF (SECTION-NUMBER NAMED-SECTION) NUMBER))
                 (IF APPENDP
                     (PUSHNEW SECTION (SEE-ALSO NAMED-SECTION))
                     (SETF (SEE-ALSO NAMED-SECTION) (LIST SECTION)))))
             SECTION))
      (PROG (FORM COMMENTARY CODE SECTION SECTIONS)
        (SETQ SECTION (MAKE-INSTANCE 'LIMBO-SECTION))
        (WITH-MODE :LIMBO
          (LOOP (MAYBE-PUSH (SNARF-UNTIL-CONTROL-CHAR STREAM #\@) COMMENTARY)
                (SETQ FORM (READ-PRESERVING-WHITESPACE STREAM NIL *EOF* NIL))
                (TYPECASE FORM
                  (EOF (GO EOF))
                  (SECTION (GO COMMENTARY))
                  (T (PUSH FORM COMMENTARY)))))
       COMMENTARY
        (PUSH (FINISH-SECTION SECTION COMMENTARY CODE) SECTIONS)
        (CHECK-TYPE FORM SECTION)
        (SETQ SECTION FORM
              COMMENTARY 'NIL
              CODE 'NIL)
        (WITH-MODE :TEX
          (LOOP
           (MAYBE-PUSH (SNARF-UNTIL-CONTROL-CHAR STREAM '(#\@ #\|)) COMMENTARY)
           (SETQ FORM (READ-PRESERVING-WHITESPACE STREAM NIL *EOF* NIL))
           (TYPECASE FORM
             (EOF (GO EOF))
             (SECTION (GO COMMENTARY))
             (START-CODE-MARKER
              (SETF (SECTION-NAME SECTION) (SECTION-NAME FORM))
              (GO LISP))
             (T (PUSH FORM COMMENTARY)))))
       LISP
        (CHECK-TYPE FORM START-CODE-MARKER)
        (UNLESS (SECTION-NAME SECTION)
          (SETF (TEST-SECTION-P SECTION) (TEST-CODE-P FORM)))
        (WITH-MODE :LISP
          (LOOP (SETQ FORM (READ-PRESERVING-WHITESPACE STREAM NIL *EOF* NIL))
                (TYPECASE FORM
                  (EOF (GO EOF))
                  (SECTION (GO COMMENTARY))
                  (START-CODE-MARKER
                   (CERROR "Start a new unnamed section with no commentary."
                           "Can't start a section with a code part.")
                   (SETQ FORM (MAKE-INSTANCE 'SECTION))
                   (PUSH (FINISH-SECTION SECTION COMMENTARY CODE) SECTIONS)
                   (CHECK-TYPE FORM SECTION)
                   (SETQ SECTION FORM
                         COMMENTARY 'NIL
                         CODE 'NIL))
                  (NEWLINE-MARKER
                   (UNLESS (NULL CODE)
                     (COND ((NEWLINEP (CAR CODE)) (POP CODE) (PUSH *PAR* CODE))
                           (T (PUSH FORM CODE)))))
                  (EVALUATED-FORM-MARKER
                   (LET ((FORM (MARKER-VALUE FORM)))
                     (EVAL (TANGLE FORM))
                     (PUSH FORM CODE)))
                  (T (PUSH FORM CODE)))))
       EOF
        (PUSH (FINISH-SECTION SECTION COMMENTARY CODE) SECTIONS)
        (RETURN (NREVERSE SECTIONS))))))
(DEFUN TANGLE-1 (FORM)
  (TYPECASE FORM
    (LIST-MARKER (VALUES (MARKER-VALUE FORM) T))
    (ATOM (VALUES FORM NIL))
    ((CONS NAMED-SECTION *)
     (VALUES (APPEND (SECTION-CODE (CAR FORM)) (TANGLE-1 (CDR FORM))) T))
    ((CONS MARKER *)
     (VALUES
      (IF (MARKER-BOUNDP (CAR FORM))
          (CONS (MARKER-VALUE (CAR FORM)) (TANGLE-1 (CDR FORM)))
          (TANGLE-1 (CDR FORM)))
      T))
    (T
     (MULTIPLE-VALUE-BIND (A CAR-EXPANDED-P)
         (TANGLE-1 (CAR FORM))
       (MULTIPLE-VALUE-BIND (D CDR-EXPANDED-P)
           (TANGLE-1 (CDR FORM))
         (VALUES
          (IF (AND (EQL A (CAR FORM)) (EQL D (CDR FORM)))
              FORM
              (CONS A D))
          (OR CAR-EXPANDED-P CDR-EXPANDED-P)))))))
(DEFTEST (TANGLE-1 1) (TANGLE-1 (READ-FORM-FROM-STRING ":a")) :A NIL)
(DEFTEST (TANGLE-1 2) (TANGLE-1 (READ-FORM-FROM-STRING "(:a :b :c)"))
         (:A :B :C) T)
(DEFTEST (TANGLE-1 3)
         (LET ((*NAMED-SECTIONS* *TEST-NAMED-SECTIONS*))
           (EQL (TANGLE-1 (READ-FORM-FROM-STRING "@<foo@>"))
                (FIND-TEST-SECTION "foo")))
         T)
(DEFUN TANGLE (FORM)
  (LABELS ((EXPAND (FORM EXPANDED)
             (MULTIPLE-VALUE-BIND (NEW-FORM NEWLY-EXPANDED-P)
                 (TANGLE-1 FORM)
               (IF NEWLY-EXPANDED-P
                   (EXPAND NEW-FORM T)
                   (VALUES NEW-FORM EXPANDED)))))
    (EXPAND FORM NIL)))
(DEFTEST TANGLE
         (LET ((*NAMED-SECTIONS* *TEST-NAMED-SECTIONS*))
           (TANGLE (READ-FORM-FROM-STRING (FORMAT NIL "(:a @<foo@>~% :b)"))))
         (:A :FOO :B) T)
(DEFUN READ-CODE-PARTS (STREAM &KEY (APPENDP T) (ELIDE-TESTS NIL))
  (APPLY #'APPEND
         (MAP 'LIST #'SECTION-CODE
              (REMOVE-IF
               (LAMBDA (SECTION)
                 (OR (SECTION-NAME SECTION)
                     (AND ELIDE-TESTS (TEST-SECTION-P SECTION))))
               (READ-SECTIONS STREAM :APPENDP APPENDP)))))
(DEFUN LOAD-WEB-FROM-STREAM (STREAM PRINT &KEY (APPENDP T))
  (LET ((*READTABLE* *READTABLE*) (*PACKAGE* *PACKAGE*) (*EVALUATING* T))
    (DOLIST (FORM (TANGLE (READ-CODE-PARTS STREAM :APPENDP APPENDP)) T)
      (IF PRINT
          (LET ((RESULTS (MULTIPLE-VALUE-LIST (EVAL FORM))))
            (FORMAT T "~&; ~{~S~^, ~}~%" RESULTS))
          (EVAL FORM)))))
(DEFUN LOAD-WEB
       (FILESPEC
        &KEY (VERBOSE *LOAD-VERBOSE*) (PRINT *LOAD-PRINT*)
        (IF-DOES-NOT-EXIST T) (EXTERNAL-FORMAT :DEFAULT))
  "Load the web given by FILESPEC into the Lisp environment."
  (SETF (FILL-POINTER *SECTIONS*) 0)
  (SETQ *NAMED-SECTIONS* NIL)
  (WHEN VERBOSE (FORMAT T "~&; loading WEB from ~S~%" FILESPEC))
  (IF (STREAMP FILESPEC)
      (LOAD-WEB-FROM-STREAM FILESPEC PRINT)
      (WITH-OPEN-FILE
          (STREAM
           (MERGE-PATHNAMES (MAKE-PATHNAME :TYPE "CLW" :CASE :COMMON) FILESPEC)
           :DIRECTION :INPUT :EXTERNAL-FORMAT EXTERNAL-FORMAT
           :IF-DOES-NOT-EXIST
           (IF IF-DOES-NOT-EXIST
               :ERROR
               NIL))
        (LOAD-WEB-FROM-STREAM STREAM PRINT))))
(DEFUN LOAD-SECTIONS-FROM-TEMP-FILE
       (FILE APPENDP &AUX (TRUENAME (PROBE-FILE FILE)))
  "Load web sections from FILE, then delete it."
  (WHEN TRUENAME
    (UNWIND-PROTECT
        (WITH-OPEN-FILE (STREAM TRUENAME :DIRECTION :INPUT)
          (LOAD-WEB-FROM-STREAM STREAM T :APPENDP APPENDP))
      (DELETE-FILE TRUENAME))))
(DEFUN TANGLE-FILE
       (INPUT-FILE
        &REST ARGS
        &KEY OUTPUT-FILE (ELIDE-TESTS NIL) (VERBOSE *COMPILE-VERBOSE*)
        (PRINT *COMPILE-PRINT*) (EXTERNAL-FORMAT :DEFAULT) &ALLOW-OTHER-KEYS
        &AUX
        (INPUT-FILE
         (MERGE-PATHNAMES (MAKE-PATHNAME :TYPE "CLW" :CASE :COMMON)
                          INPUT-FILE))
        (LISP-FILE
         (MERGE-PATHNAMES (MAKE-PATHNAME :TYPE "LISP" :CASE :COMMON)
                          INPUT-FILE)))
  "Tangle and compile the web in INPUT-FILE, producing OUTPUT-FILE."
  (DECLARE (IGNORE OUTPUT-FILE PRINT))
  (WHEN VERBOSE (FORMAT T "~&; tangling WEB from ~S~%" INPUT-FILE))
  (SETF (FILL-POINTER *SECTIONS*) 0)
  (SETQ *NAMED-SECTIONS* NIL)
  (WITH-OPEN-FILE
      (INPUT INPUT-FILE :DIRECTION :INPUT :EXTERNAL-FORMAT EXTERNAL-FORMAT)
    (WITH-OPEN-FILE
        (LISP LISP-FILE :DIRECTION :OUTPUT :IF-EXISTS :SUPERSEDE
         :EXTERNAL-FORMAT EXTERNAL-FORMAT)
      (FORMAT LISP ";;;; TANGLED OUTPUT FROM WEB ~S. DO NOT EDIT." INPUT-FILE)
      (LET ((*EVALUATING* NIL) (*PRINT-MARKER* T))
        (DOLIST
            (FORM (TANGLE (READ-CODE-PARTS INPUT :ELIDE-TESTS ELIDE-TESTS)))
          (PPRINT FORM LISP)))))
  (LET ((UNUSED-SECTIONS 'NIL))
    (LABELS ((COLLECT-UNUSED-SECTIONS (SECTION)
               (WHEN SECTION
                 (COLLECT-UNUSED-SECTIONS (LEFT-CHILD SECTION))
                 (COLLECT-UNUSED-SECTIONS (RIGHT-CHILD SECTION))
                 (WHEN (NULL (USED-BY SECTION))
                   (PUSH SECTION UNUSED-SECTIONS)))))
      (COLLECT-UNUSED-SECTIONS *NAMED-SECTIONS*)
      (MAP NIL
           (LAMBDA (SECTION)
             (WARN 'UNUSED-NAMED-SECTION-WARNING :FORMAT-CONTROL
                   "Unused named section <~A>." :FORMAT-ARGUMENTS
                   (LIST (SECTION-NAME SECTION))))
           (SORT UNUSED-SECTIONS #'< :KEY #'SECTION-NUMBER))))
  (APPLY #'COMPILE-FILE LISP-FILE :ALLOW-OTHER-KEYS T ARGS))
(DEFVAR *WEAVE-VERBOSE* T)
(DEFVAR *WEAVE-PRINT* T)
(DEFUN WEAVE
       (INPUT-FILE
        &KEY (OUTPUT-FILE NIL) (VERBOSE *WEAVE-VERBOSE*) (PRINT *WEAVE-PRINT*)
        (IF-DOES-NOT-EXIST T) (EXTERNAL-FORMAT :DEFAULT)
        &AUX
        (INPUT-FILE
         (MERGE-PATHNAMES (MAKE-PATHNAME :TYPE "CLW" :CASE :COMMON)
                          INPUT-FILE))
        (OUTPUT-FILE
         (MERGE-PATHNAMES (MAKE-PATHNAME :TYPE "TEX" :CASE :COMMON)
                          (OR OUTPUT-FILE INPUT-FILE))))
  "Weave the web contained in INPUT-FILE, producing the TeX file OUTPUT-FILE."
  (WHEN VERBOSE (FORMAT T "~&; weaving WEB from ~S~%" INPUT-FILE))
  (SETF (FILL-POINTER *SECTIONS*) 0)
  (SETQ *NAMED-SECTIONS* NIL)
  (WITH-OPEN-FILE
      (STREAM INPUT-FILE :DIRECTION :INPUT :EXTERNAL-FORMAT EXTERNAL-FORMAT
       :IF-DOES-NOT-EXIST
       (IF IF-DOES-NOT-EXIST
           :ERROR
           NIL))
    (WEAVE-SECTIONS (READ-SECTIONS STREAM) OUTPUT-FILE :PRINT PRINT
                    :EXTERNAL-FORMAT EXTERNAL-FORMAT)))
(DEFPARAMETER *WEAVE-PPRINT-DISPATCH* (COPY-PPRINT-DISPATCH NIL))
(DEFUN WEAVE-SECTIONS
       (SECTIONS OUTPUT-FILE
        &KEY (PRINT *WEAVE-PRINT*) (EXTERNAL-FORMAT :DEFAULT))
  (WITH-OPEN-FILE
      (OUTPUT OUTPUT-FILE :DIRECTION :OUTPUT :EXTERNAL-FORMAT EXTERNAL-FORMAT
       :IF-EXISTS :SUPERSEDE)
    (FORMAT OUTPUT "\\input clwebmac~%")
    (FLET ((WRITE-SECTION (SECTION)
             (WRITE SECTION :STREAM OUTPUT :CASE :DOWNCASE :ESCAPE NIL :PRETTY
                    T :PPRINT-DISPATCH *WEAVE-PPRINT-DISPATCH* :RIGHT-MARGIN
                    1000)))
      (IF PRINT
          (PPRINT-LOGICAL-BLOCK (NIL NIL :PER-LINE-PREFIX "; ")
            (MAP NIL
                 (LAMBDA (SECTION)
                   (FORMAT T "~:[~;~:@_*~]~D~:_ "
                           (TYPEP SECTION 'STARRED-SECTION)
                           (SECTION-NUMBER SECTION))
                   (WRITE-SECTION SECTION))
                 SECTIONS))
          (MAP NIL #'WRITE-SECTION SECTIONS)))
    (FORMAT OUTPUT "~&\\bye~%")
    (TRUENAME OUTPUT)))
(DEFUN SET-WEAVE-DISPATCH (TYPE-SPECIFIER FUNCTION &OPTIONAL (PRIORITY 0))
  (SET-PPRINT-DISPATCH TYPE-SPECIFIER FUNCTION PRIORITY
                       *WEAVE-PPRINT-DISPATCH*))
(DEFVAR *INNER-LISP* NIL)
(DEFUN PRINT-TEX (STREAM TEX-MODE-MATERIAL)
  (DOLIST (X TEX-MODE-MATERIAL)
    (ETYPECASE X
      (STRING (WRITE-STRING X STREAM))
      (LIST
       (LET ((*INNER-LISP* T))
         (DOLIST (FORM X) (FORMAT STREAM "\\(~W\\)" FORM)))))))
(DEFUN READ-TEX-FROM-STRING (INPUT-STRING)
  (WITH-MODE :RESTRICTED
    (WITH-INPUT-FROM-STRING (STREAM INPUT-STRING)
      (LOOP FOR TEXT = (SNARF-UNTIL-CONTROL-CHAR STREAM #\|)
            FOR FORMS = (READ-PRESERVING-WHITESPACE STREAM NIL *EOF* NIL)
            IF (PLUSP (LENGTH TEXT))
            COLLECT TEXT
            IF (EOF-P FORMS)
            DO (LOOP-FINISH) ELSE
            COLLECT FORMS))))
(DEFUN PRINT-LIMBO (STREAM SECTION)
  (LET ((COMMENTARY (SECTION-COMMENTARY SECTION)))
    (WHEN COMMENTARY (PRINT-TEX STREAM COMMENTARY) (TERPRI STREAM))))
(SET-WEAVE-DISPATCH 'LIMBO-SECTION #'PRINT-LIMBO 1)
(DEFUN PRINT-SECTION (STREAM SECTION)
  (FORMAT STREAM "~&\\~:[M~;N{1}~]{~D}" (TYPEP SECTION 'STARRED-SECTION)
          (SECTION-NUMBER SECTION))
  (LET* ((COMMENTARY (SECTION-COMMENTARY SECTION))
         (NAME (SECTION-NAME SECTION))
         (NAMED-SECTION (AND NAME (FIND-SECTION NAME)))
         (CODE (SECTION-CODE SECTION)))
    (PRINT-TEX STREAM COMMENTARY)
    (FRESH-LINE STREAM)
    (COND ((AND COMMENTARY CODE) (FORMAT STREAM "\\Y\\B~%"))
          (CODE (FORMAT STREAM "\\B~%")))
    (WHEN NAMED-SECTION
      (PRINT-SECTION-NAME STREAM NAMED-SECTION)
      (FORMAT STREAM "${}~:[\\mathrel+~;~]\\E{}$~%"
              (= (SECTION-NUMBER SECTION) (SECTION-NUMBER NAMED-SECTION))))
    (WHEN CODE
      (DOLIST (FORM CODE)
        (IF (LIST-MARKER-P FORM)
            (FORMAT STREAM "~@<\\+~@;~W~;\\cr~:>" FORM)
            (FORMAT STREAM "~W" FORM)))
      (FORMAT STREAM "~&\\egroup~%"))
    (WHEN NAMED-SECTION
      (PRINT-XREFS STREAM #\A (REMOVE SECTION (SEE-ALSO NAMED-SECTION)))
      (PRINT-XREFS STREAM #\U (REMOVE SECTION (USED-BY NAMED-SECTION)))))
  (FORMAT STREAM "\\fi~%"))
(SET-WEAVE-DISPATCH 'SECTION #'PRINT-SECTION)
(DEFUN PRINT-XREFS (STREAM KIND XREFS)
  (WHEN XREFS
    (FORMAT STREAM
            "\\~C~{~#[~;~D~;s ~D\\ET~D~:;s~@{~#[~;\\ETs~D~;~D~:;~D, ~]~}~]~}.~%"
            KIND (SORT (MAPCAR #'SECTION-NUMBER XREFS) #'<))))
(DEFUN PRINT-SECTION-NAME (STREAM NAMED-SECTION)
  (FORMAT STREAM "\\X~D:" (SECTION-NUMBER NAMED-SECTION))
  (PRINT-TEX STREAM (READ-TEX-FROM-STRING (SECTION-NAME NAMED-SECTION)))
  (WRITE-STRING "\\X" STREAM))
(SET-WEAVE-DISPATCH 'NAMED-SECTION #'PRINT-SECTION-NAME)
(DEFPARAMETER *TEX-ESCAPE-ALIST*
  '((" \\%&#$^_~<>" . #\\) ("{" . "$\\{$") ("}" . "$\\}$")))
(DEFUN WRITE-STRING-ESCAPED
       (STRING
        &OPTIONAL STREAM (ESCAPE-CHARS *TEX-ESCAPE-ALIST*)
        &AUX
        (STREAM
         (CASE STREAM
           ((T) *TERMINAL-IO*)
           ((NIL) *STANDARD-OUTPUT*)
           (OTHERWISE STREAM))))
  (LOOP FOR CHAR ACROSS STRING AS ESCAPE = (CDR
                                            (ASSOC CHAR ESCAPE-CHARS :TEST
                                                   #'FIND))
        IF ESCAPE
        DO (ETYPECASE ESCAPE
             (CHARACTER (WRITE-CHAR ESCAPE STREAM) (WRITE-CHAR CHAR STREAM))
             (STRING (WRITE-STRING ESCAPE STREAM))) ELSE
        DO (WRITE-CHAR CHAR STREAM)))
(DEFTEST WRITE-STRING-ESCAPED
         (WITH-OUTPUT-TO-STRING (S) (WRITE-STRING-ESCAPED "foo#{bar}*baz" S))
         "foo\\#$\\{$bar$\\}$*baz")
(DEFUN PRINT-STRING (STREAM STRING)
  (WRITE-STRING "\\.{\"" STREAM)
  (WRITE-STRING-ESCAPED STRING STREAM
                        (LIST* '("{*}" . #\\) '("\\" . "\\\\\\\\")
                               '("\"" . "\\\\\"") *TEX-ESCAPE-ALIST*))
  (WRITE-STRING "\"}" STREAM))
(SET-WEAVE-DISPATCH 'STRING #'PRINT-STRING)
(DEFUN PRINT-CHAR (STREAM CHAR)
  (LET ((GRAPHICP (AND (GRAPHIC-CHAR-P CHAR) (STANDARD-CHAR-P CHAR)))
        (NAME (CHAR-NAME CHAR)))
    (WRITE-STRING "\\#\\CH{" STREAM)
    (WRITE-STRING-ESCAPED
     (IF (AND NAME (NOT GRAPHICP))
         NAME
         (MAKE-STRING 1 :INITIAL-ELEMENT CHAR))
     STREAM (LIST* '("{}" . #\\) *TEX-ESCAPE-ALIST*))
    (WRITE-STRING "}" STREAM)
    CHAR))
(SET-WEAVE-DISPATCH 'CHARACTER #'PRINT-CHAR)
(DEFUN PRINT-SYMBOL (STREAM SYMBOL)
  (LET ((GROUP-P
         (COND
          ((MEMBER SYMBOL LAMBDA-LIST-KEYWORDS) (WRITE-STRING "\\K{" STREAM))
          ((KEYWORDP SYMBOL) (WRITE-STRING "\\:{" STREAM)))))
    (WRITE-STRING-ESCAPED (WRITE-TO-STRING SYMBOL :ESCAPE NIL :PRETTY NIL)
                          STREAM)
    (WHEN GROUP-P (WRITE-STRING "}" STREAM))))
(SET-WEAVE-DISPATCH 'SYMBOL #'PRINT-SYMBOL)
(SET-WEAVE-DISPATCH '(EQL LAMBDA)
                    (LAMBDA (STREAM OBJ)
                      (DECLARE (IGNORE OBJ))
                      (WRITE-STRING "\\L" STREAM))
                    1)
(DEFSTRUCT (LOGICAL-BLOCK (:CONSTRUCTOR MAKE-LOGICAL-BLOCK (LIST))) LIST)
(DEFUN ANALYZE-INDENTATION (LIST-MARKER)
  (DECLARE (TYPE LIST-MARKER LIST-MARKER))
  (LABELS ((FIND-NEXT-NEWLINE (LIST)
             (MEMBER-IF #'NEWLINEP LIST :KEY #'CAR))
           (NEXT-LOGICAL-BLOCK (LIST)
             (DO* ((BLOCK 'NIL)
                   (BLOCK-INDENT (CDAR LIST))
                   (INDENT BLOCK-INDENT)
                   (NEWLINE (FIND-NEXT-NEWLINE LIST))
                   (NEXT-INDENT (CDADR NEWLINE)))
                  ((OR (ENDP LIST)
                       (AND (EQ LIST NEWLINE) NEXT-INDENT
                            (< NEXT-INDENT BLOCK-INDENT)))
                   (VALUES
                    (IF (NOTANY #'NEWLINEP BLOCK)
                        (NREVERSE BLOCK)
                        (MAKE-LOGICAL-BLOCK (NREVERSE BLOCK)))
                    LIST))
               (IF (AND INDENT NEXT-INDENT (> NEXT-INDENT INDENT)
                        (= NEXT-INDENT (CDAR LIST)))
                   (MULTIPLE-VALUE-BIND (SUB-BLOCK TAIL)
                       (NEXT-LOGICAL-BLOCK LIST)
                     (CHECK-TYPE (CAAR TAIL) (OR NEWLINE-MARKER NULL))
                     (PUSH SUB-BLOCK BLOCK)
                     (SETQ LIST TAIL))
                   (LET ((NEXT (CAR (POP LIST))))
                     (PUSH NEXT BLOCK)
                     (WHEN (AND LIST (NEWLINEP NEXT))
                       (SETF INDENT (CDAR LIST)
                             (INDENTATION NEXT) (- INDENT BLOCK-INDENT)
                             NEWLINE (FIND-NEXT-NEWLINE LIST)
                             NEXT-INDENT (CDADR NEWLINE))))))))
    (ASSERT
     (= (LENGTH (LIST-MARKER-LIST LIST-MARKER))
        (LENGTH (LIST-MARKER-CHARPOS LIST-MARKER)))
     ((LIST-MARKER-LIST LIST-MARKER) (LIST-MARKER-CHARPOS LIST-MARKER))
     "List marker's list and charpos-list aren't the same length.")
    (NEXT-LOGICAL-BLOCK
     (MAPCAR #'CONS (LIST-MARKER-LIST LIST-MARKER)
             (LIST-MARKER-CHARPOS LIST-MARKER)))))
(DEFUN PRINT-LIST (STREAM LIST-MARKER)
  (LET ((BLOCK (ANALYZE-INDENTATION LIST-MARKER)))
    (ETYPECASE BLOCK
      (LIST (FORMAT STREAM "~<(~;~@{~W~^ ~}~;)~:>" BLOCK))
      (LOGICAL-BLOCK (FORMAT STREAM "(~W)" BLOCK)))))
(SET-WEAVE-DISPATCH 'LIST-MARKER #'PRINT-LIST)
(DEFUN PRINT-LOGICAL-BLOCK (STREAM BLOCK)
  (WRITE-STRING "\\!" STREAM)
  (PPRINT-LOGICAL-BLOCK
      (STREAM (LOGICAL-BLOCK-LIST BLOCK) :PER-LINE-PREFIX "&")
    (DO (INDENT
         NEXT
         (OBJ (PPRINT-POP) NEXT))
        (NIL)
      (COND
       ((NEWLINEP OBJ) (FORMAT STREAM "\\cr~:@_")
        (SETQ INDENT (INDENTATION OBJ)) (PPRINT-EXIT-IF-LIST-EXHAUSTED)
        (SETQ NEXT (PPRINT-POP)))
       (T (FORMAT STREAM "~@[~[~;\\1~;\\1~:;\\2~]~]~W" INDENT OBJ)
        (SETQ INDENT NIL) (PPRINT-EXIT-IF-LIST-EXHAUSTED)
        (SETQ NEXT (PPRINT-POP))
        (UNLESS (NEWLINEP NEXT) (WRITE-CHAR #\  STREAM)))))))
(SET-WEAVE-DISPATCH 'LOGICAL-BLOCK #'PRINT-LOGICAL-BLOCK)
(SET-WEAVE-DISPATCH 'NEWLINE-MARKER
                    (LAMBDA (STREAM OBJ)
                      (DECLARE (IGNORE OBJ))
                      (TERPRI STREAM)))
(SET-WEAVE-DISPATCH 'PAR-MARKER
                    (LAMBDA (STREAM OBJ)
                      (DECLARE (IGNORE OBJ))
                      (FORMAT STREAM "~&\\Y~%"))
                    1)
(SET-WEAVE-DISPATCH 'EMPTY-LIST-MARKER
                    (LAMBDA (STREAM OBJ)
                      (DECLARE (IGNORE OBJ))
                      (WRITE-STRING "()" STREAM)))
(SET-WEAVE-DISPATCH 'CONSING-DOT-MARKER
                    (LAMBDA (STREAM OBJ)
                      (DECLARE (IGNORE OBJ))
                      (WRITE-CHAR #\. STREAM)))
(SET-WEAVE-DISPATCH 'QUOTE-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\'~W" (QUOTED-FORM OBJ))))
(SET-WEAVE-DISPATCH 'COMMENT-MARKER
                    (LAMBDA (STREAM OBJ)
                      (WRITE-STRING "\\C{" STREAM)
                      (PRINT-TEX STREAM
                                 (READ-TEX-FROM-STRING (COMMENT-TEXT OBJ)))
                      (WRITE-STRING "}" STREAM)))
(SET-WEAVE-DISPATCH 'BACKQUOTE-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\`~W" (BACKQ-FORM OBJ))))
(SET-WEAVE-DISPATCH 'COMMA-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\CO{~@[~C~]}~W" (COMMA-MODIFIER OBJ)
                              (COMMA-FORM OBJ))))
(SET-WEAVE-DISPATCH 'FUNCTION-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\#\\'~S" (QUOTED-FORM OBJ)))
                    1)
(SET-WEAVE-DISPATCH 'SIMPLE-VECTOR-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\#~@[~D~]~S"
                              (AND (SLOT-BOUNDP OBJ 'LENGTH)
                                   (SLOT-VALUE OBJ 'LENGTH))
                              (SLOT-VALUE OBJ 'ELEMENTS))))
(SET-WEAVE-DISPATCH 'BIT-VECTOR-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\#~@[~D~]*~{~[0~;1~]~}"
                              (AND (SLOT-BOUNDP OBJ 'LENGTH)
                                   (SLOT-VALUE OBJ 'LENGTH))
                              (MAP 'LIST #'IDENTITY
                                   (SLOT-VALUE OBJ 'ELEMENTS))))
                    1)
(SET-WEAVE-DISPATCH 'READ-TIME-EVAL-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\#.~W" (READ-TIME-EVAL-FORM OBJ))))
(SET-WEAVE-DISPATCH 'RADIX-MARKER
                    (LAMBDA (STREAM OBJ)
                      (LET ((*PRINT-RADIX* NIL)
                            (*PRINT-BASE* (RADIX-MARKER-BASE OBJ)))
                        (PRINC (MARKER-VALUE OBJ) STREAM)
                        (FORMAT STREAM "_{~D}" *PRINT-BASE*))))
(SET-WEAVE-DISPATCH 'STRUCTURE-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\#S~W" (STRUCTURE-MARKER-FORM OBJ))))
(SET-WEAVE-DISPATCH 'READ-TIME-CONDITIONAL-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\#~:[--~;+~]\\RC{~S"
                              (READ-TIME-CONDITIONAL-PLUSP OBJ)
                              (READ-TIME-CONDITIONAL-TEST OBJ))
                      (WRITE-CHAR #\  STREAM)
                      (WRITE-STRING-ESCAPED (READ-TIME-CONDITIONAL-FORM OBJ)
                                            STREAM)
                      (WRITE-CHAR #\} STREAM)))