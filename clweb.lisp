;;;; TANGLED WEB FROM "clweb.clw". DO NOT EDIT.
(PROVIDE "CLWEB")
(EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)
  #+:SBCL (require 'sb-cltl2))
(DEFPACKAGE "CLWEB"
  (:USE "COMMON-LISP" #+:SBCL "SB-CLTL2" #+:ALLEGRO "SYS")
  (:EXPORT "TANGLE-FILE"
           "LOAD-WEB"
           "WEAVE"
           "LOAD-SECTIONS-FROM-TEMP-FILE"
           "AMBIGUOUS-PREFIX-ERROR"
           "SECTION-NAME-CONTEXT-ERROR"
           "SECTION-NAME-USE-ERROR"
           "SECTION-NAME-DEFINITION-ERROR"
           "UNUSED-NAMED-SECTION-WARNING")
  (:SHADOW "ENCLOSE"
           #+:ALLEGRO "FUNCTION-INFORMATION"
           #+:ALLEGRO "VARIABLE-INFORMATION"))
(IN-PACKAGE "CLWEB")
(DEFVAR *SECTIONS* (MAKE-ARRAY 128 :ADJUSTABLE T :FILL-POINTER 0))
(DEFVAR *CURRENT-SECTION* NIL)
(DEFVAR *TEST-SECTIONS* (MAKE-ARRAY 128 :ADJUSTABLE T :FILL-POINTER 0))
(DEFVAR *NAMED-SECTIONS* NIL)
(EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)
  (DEFPARAMETER *MODES* '(:LIMBO :TEX :LISP :INNER-LISP :RESTRICTED)))
(DEFTYPE MODE () `(MEMBER ,@*MODES*))
(DEFVAR *READTABLES*
  (LOOP FOR MODE IN (CONS NIL *MODES*)
        COLLECT (CONS MODE (COPY-READTABLE NIL))))
(DEFVAR *EOF* (MAKE-SYMBOL "EOF"))
(DEFVAR *CHARPOS-STREAMS* (MAKE-HASH-TABLE :TEST #'EQ))
(DEFVAR *PRINT-MARKER* T)
(DEFVAR *EVALUATING* NIL)
(DEFVAR *WEAVE-VERBOSE* T)
(DEFVAR *WEAVE-PRINT* T)
(DEFPARAMETER *WEAVE-PPRINT-DISPATCH* (COPY-PPRINT-DISPATCH NIL))
(DEFVAR *INNER-LISP* NIL)
(DEFVAR *INDEX-PACKAGES* NIL)
(DEFVAR *DEFINING-OPERATORS*
  (LIST (CONS 'DEFUN :FUNCTION) (CONS 'FLET :LOCAL-FUNCTION)
        (CONS 'LABELS :LOCAL-FUNCTION) (CONS 'MACROLET :LOCAL-MACRO)
        (CONS 'DEFVAR :SPECIAL-VARIABLE)
        (CONS 'DEFPARAMETER :SPECIAL-VARIABLE)))
(DEFVAR *INDEXING* NIL)
(DEFINE-CONDITION AMBIGUOUS-PREFIX-ERROR
    (ERROR)
    ((PREFIX :READER AMBIGUOUS-PREFIX :INITARG :PREFIX)
     (FIRST-MATCH :READER AMBIGUOUS-PREFIX-FIRST-MATCH :INITARG :FIRST-MATCH)
     (ALT-MATCH :READER AMBIGUOUS-PREFIX-ALT-MATCH :INITARG :ALT-MATCH))
  (:REPORT
   (LAMBDA (CONDITION STREAM)
     (FORMAT STREAM "~@<Ambiguous prefix: <~A> matches both <~A> and <~A>~:@>"
             (AMBIGUOUS-PREFIX CONDITION)
             (AMBIGUOUS-PREFIX-FIRST-MATCH CONDITION)
             (AMBIGUOUS-PREFIX-ALT-MATCH CONDITION)))))
(DEFINE-CONDITION SIMPLE-READER-ERROR
    (READER-ERROR SIMPLE-CONDITION)
    NIL
  (:REPORT
   (LAMBDA (CONDITION STREAM)
     (FORMAT STREAM "~S on ~S:~%~?" CONDITION (STREAM-ERROR-STREAM CONDITION)
             (SIMPLE-CONDITION-FORMAT-CONTROL CONDITION)
             (SIMPLE-CONDITION-FORMAT-ARGUMENTS CONDITION)))))
(DEFUN SIMPLE-READER-ERROR (STREAM CONTROL &REST ARGS)
  (ERROR 'SIMPLE-READER-ERROR :STREAM STREAM :FORMAT-CONTROL CONTROL
         :FORMAT-ARGUMENTS ARGS))
(DEFINE-CONDITION SECTION-NAME-CONTEXT-ERROR
    (ERROR)
    ((NAME :READER SECTION-NAME :INITARG :NAME)))
(DEFINE-CONDITION SECTION-NAME-DEFINITION-ERROR
    (SECTION-NAME-CONTEXT-ERROR)
    NIL
  (:REPORT
   (LAMBDA (CONDITION STREAM)
     (FORMAT STREAM "Can't define a named section in Lisp mode: ~A"
             (SECTION-NAME CONDITION)))))
(DEFINE-CONDITION SECTION-NAME-USE-ERROR
    (SECTION-NAME-CONTEXT-ERROR)
    NIL
  (:REPORT
   (LAMBDA (CONDITION STREAM)
     (FORMAT STREAM "Can't use a section name in TeX mode: ~A"
             (SECTION-NAME CONDITION)))))
(DEFINE-CONDITION SECTION-LACKS-COMMENTARY
    (PARSE-ERROR)
    ((STREAM :INITARG :STREAM :READER SECTION-LACKS-COMMENTARY-STREAM))
  (:REPORT
   (LAMBDA (ERROR STREAM)
     (LET* ((INPUT-STREAM
             (DO ((STREAM (SECTION-LACKS-COMMENTARY-STREAM ERROR)))
                 (NIL)
               (TYPECASE STREAM
                 (ECHO-STREAM (SETQ STREAM (ECHO-STREAM-INPUT-STREAM STREAM)))
                 (T (RETURN STREAM)))))
            (POSITION (FILE-POSITION INPUT-STREAM))
            (PATHNAME
             (WHEN (TYPEP INPUT-STREAM 'FILE-STREAM) (PATHNAME INPUT-STREAM))))
       (FORMAT STREAM "~@<Can't start a section with a code part ~
~:[~;~:*at position ~D in file ~A.~]~:@>"
               POSITION (OR PATHNAME INPUT-STREAM))))))
(DEFINE-CONDITION UNUSED-NAMED-SECTION-WARNING
    (SIMPLE-WARNING)
    NIL)
(DEFINE-CONDITION INVALID-FUNCTION-NAME
    (PARSE-ERROR)
    ((NAME :INITARG :NAME :READER FUNCTION-NAME))
  (:REPORT
   (LAMBDA (ERROR STREAM)
     (FORMAT STREAM "~@<Invalid function name ~A.~:@>" (FUNCTION-NAME ERROR)))))
(DEFCLASS SECTION NIL
          ((NAME :ACCESSOR SECTION-NAME :INITARG :NAME)
           (NUMBER :ACCESSOR SECTION-NUMBER)
           (COMMENTARY :ACCESSOR SECTION-COMMENTARY :INITARG :COMMENTARY)
           (CODE :ACCESSOR SECTION-CODE :INITARG :CODE))
          (:DEFAULT-INITARGS :NAME NIL :COMMENTARY NIL :CODE NIL))
(DEFCLASS STARRED-SECTION (SECTION) NIL)
(DEFCLASS TEST-SECTION (SECTION)
          ((TEST-FOR :ACCESSOR TEST-FOR-SECTION :INITFORM *CURRENT-SECTION*)))
(DEFCLASS STARRED-TEST-SECTION (TEST-SECTION STARRED-SECTION) NIL)
(DEFCLASS LIMBO-SECTION (SECTION) NIL)
(DEFGENERIC PUSH-SECTION
    (SECTION))
(DEFMETHOD PUSH-SECTION ((SECTION SECTION))
           (SETF (SECTION-NUMBER SECTION)
                   (VECTOR-PUSH-EXTEND SECTION *SECTIONS*))
           SECTION)
(DEFMETHOD INITIALIZE-INSTANCE :AFTER ((SECTION SECTION) &REST INITARGS &KEY)
           (DECLARE (IGNORE INITARGS))
           (SETQ *CURRENT-SECTION* (PUSH-SECTION SECTION)))
(DEFMETHOD PUSH-SECTION ((SECTION TEST-SECTION))
           (LET ((*SECTIONS* *TEST-SECTIONS*))
             (CALL-NEXT-METHOD)))
(DEFMETHOD PUSH-SECTION :AFTER ((SECTION LIMBO-SECTION))
           (VECTOR-PUSH-EXTEND SECTION *TEST-SECTIONS*))
(DEFCLASS BINARY-SEARCH-TREE NIL
          ((KEY :ACCESSOR NODE-KEY :INITARG :KEY)
           (LEFT-CHILD :ACCESSOR LEFT-CHILD :INITARG :LEFT)
           (RIGHT-CHILD :ACCESSOR RIGHT-CHILD :INITARG :RIGHT))
          (:DEFAULT-INITARGS :LEFT NIL :RIGHT NIL))
(DEFGENERIC FIND-OR-INSERT
    (ITEM ROOT &KEY PREDICATE TEST INSERT-IF-NOT-FOUND))
(DEFMETHOD FIND-OR-INSERT
           (ITEM (ROOT BINARY-SEARCH-TREE) &KEY (PREDICATE #'<) (TEST #'EQL)
            (INSERT-IF-NOT-FOUND T))
           (FLET ((LESSP (ITEM NODE)
                    (FUNCALL PREDICATE ITEM (NODE-KEY NODE)))
                  (SAMEP (ITEM NODE)
                    (FUNCALL TEST ITEM (NODE-KEY NODE))))
             (DO ((PARENT NIL NODE)
                  (NODE ROOT
                        (IF (LESSP ITEM NODE)
                            (LEFT-CHILD NODE)
                            (RIGHT-CHILD NODE))))
                 ((OR (NULL NODE) (SAMEP ITEM NODE))
                  (IF NODE
                      (VALUES NODE T)
                      (IF INSERT-IF-NOT-FOUND
                          (LET ((NODE
                                 (MAKE-INSTANCE (CLASS-OF ROOT) :KEY ITEM)))
                            (WHEN PARENT
                              (IF (LESSP ITEM PARENT)
                                  (SETF (LEFT-CHILD PARENT) NODE)
                                  (SETF (RIGHT-CHILD PARENT) NODE)))
                            (VALUES NODE NIL))
                          (VALUES NIL NIL)))))))
(DEFUN MAPAPPEND (FUN &REST ARGS)
  (IF (SOME #'NULL ARGS)
      NIL
      (APPEND (APPLY FUN (MAPCAR #'CAR ARGS))
              (APPLY #'MAPAPPEND FUN (MAPCAR #'CDR ARGS)))))
(DEFCLASS NAMED-SECTION (BINARY-SEARCH-TREE)
          ((KEY :ACCESSOR SECTION-NAME :INITARG :NAME)
           (SECTIONS :ACCESSOR NAMED-SECTION-SECTIONS :INITFORM 'NIL)
           (USED-BY :ACCESSOR USED-BY :INITFORM 'NIL)))
(DEFMETHOD NAMED-SECTION-SECTIONS :AROUND ((SECTION NAMED-SECTION))
           (SORT (COPY-LIST (CALL-NEXT-METHOD)) #'< :KEY #'SECTION-NUMBER))
(DEFMETHOD SECTION-CODE ((SECTION NAMED-SECTION))
           (MAPAPPEND #'SECTION-CODE (NAMED-SECTION-SECTIONS SECTION)))
(DEFMETHOD SECTION-NUMBER ((SECTION NAMED-SECTION))
           (SECTION-NUMBER (FIRST (NAMED-SECTION-SECTIONS SECTION))))
(DEFUN SECTION-NAME-PREFIX-P (NAME)
  (LET ((LEN (LENGTH NAME)))
    (IF (STRING= NAME "..." :START1 (MAX (- LEN 3) 0) :END1 LEN)
        (VALUES T (- LEN 3))
        (VALUES NIL LEN))))
(DEFUN SECTION-NAME-LESSP (NAME1 NAME2)
  (LET ((LEN1 (NTH-VALUE 1 (SECTION-NAME-PREFIX-P NAME1)))
        (LEN2 (NTH-VALUE 1 (SECTION-NAME-PREFIX-P NAME2))))
    (STRING-LESSP NAME1 NAME2 :END1 LEN1 :END2 LEN2)))
(DEFUN SECTION-NAME-EQUAL (NAME1 NAME2)
  (MULTIPLE-VALUE-BIND (PREFIX-1-P LEN1)
      (SECTION-NAME-PREFIX-P NAME1)
    (MULTIPLE-VALUE-BIND (PREFIX-2-P LEN2)
        (SECTION-NAME-PREFIX-P NAME2)
      (LET ((END (MIN LEN1 LEN2)))
        (IF (OR PREFIX-1-P PREFIX-2-P)
            (STRING-EQUAL NAME1 NAME2 :END1 END :END2 END)
            (STRING-EQUAL NAME1 NAME2))))))
(DEFMETHOD FIND-OR-INSERT
           (ITEM (ROOT NAMED-SECTION) &KEY (PREDICATE #'SECTION-NAME-LESSP)
            (TEST #'SECTION-NAME-EQUAL) (INSERT-IF-NOT-FOUND T))
           (MULTIPLE-VALUE-BIND (NODE PRESENT-P)
               (CALL-NEXT-METHOD ITEM ROOT :PREDICATE PREDICATE :TEST TEST
                :INSERT-IF-NOT-FOUND INSERT-IF-NOT-FOUND)
             (IF PRESENT-P
                 (OR
                  (DOLIST (CHILD (LIST (LEFT-CHILD NODE) (RIGHT-CHILD NODE)))
                    (WHEN CHILD
                      (MULTIPLE-VALUE-BIND (ALT PRESENT-P)
                          (CALL-NEXT-METHOD ITEM CHILD :PREDICATE PREDICATE
                           :TEST TEST :INSERT-IF-NOT-FOUND NIL)
                        (WHEN PRESENT-P
                          (RESTART-CASE (ERROR 'AMBIGUOUS-PREFIX-ERROR :PREFIX
                                               ITEM :FIRST-MATCH
                                               (NODE-KEY NODE) :ALT-MATCH
                                               (NODE-KEY ALT))
                            (USE-FIRST-MATCH NIL :REPORT "Use the first match."
                             (RETURN (VALUES NODE T)))
                            (USE-ALT-MATCH NIL :REPORT "Use alternate match."
                             (RETURN (VALUES ALT T))))))))
                  (VALUES NODE T))
                 (VALUES NODE NIL))))
(DEFPARAMETER *WHITESPACE*
  #.(COERCE '(#\  #\Tab #\Newline #\Newline #\Page #\Return) 'STRING))
(DEFUN WHITESPACEP (CHAR) (FIND CHAR *WHITESPACE* :TEST #'CHAR=))
(DEFUN SQUEEZE (STRING)
  (LOOP WITH SQUEEZING = NIL
        FOR CHAR ACROSS (STRING-TRIM *WHITESPACE* STRING)
        IF (NOT SQUEEZING)
        IF (WHITESPACEP CHAR)
        DO (SETQ SQUEEZING T)
        AND
        COLLECT #\  INTO CHARS ELSE
        COLLECT CHAR INTO CHARS ELSE
        UNLESS (WHITESPACEP CHAR)
        DO (SETQ SQUEEZING NIL)
        AND
        COLLECT CHAR INTO CHARS
        FINALLY (RETURN (COERCE CHARS 'STRING))))
(DEFUN FIND-SECTION (NAME &AUX (NAME (SQUEEZE NAME)))
  (IF (NULL *NAMED-SECTIONS*)
      (VALUES (SETQ *NAMED-SECTIONS* (MAKE-INSTANCE 'NAMED-SECTION :NAME NAME))
              NIL)
      (MULTIPLE-VALUE-BIND (SECTION PRESENT-P)
          (FIND-OR-INSERT NAME *NAMED-SECTIONS*)
        (WHEN PRESENT-P
          (MULTIPLE-VALUE-BIND (NEW-PREFIX-P NEW-LEN)
              (SECTION-NAME-PREFIX-P NAME)
            (MULTIPLE-VALUE-BIND (OLD-PREFIX-P OLD-LEN)
                (SECTION-NAME-PREFIX-P (SECTION-NAME SECTION))
              (WHEN
                  (OR (AND OLD-PREFIX-P (NOT NEW-PREFIX-P))
                      (AND OLD-PREFIX-P NEW-PREFIX-P (< NEW-LEN OLD-LEN)))
                (SETF (SECTION-NAME SECTION) NAME)))))
        (VALUES SECTION PRESENT-P))))
(DEFUN READTABLE-FOR-MODE (MODE)
  (DECLARE (TYPE (OR MODE NULL) MODE))
  (CDR (ASSOC MODE *READTABLES*)))
(DEFMACRO WITH-MODE (MODE &BODY BODY)
  `(LET ((*READTABLE* (READTABLE-FOR-MODE ,MODE)))
     ,@BODY))
(DEFUN EOF-P (X) (EQ X *EOF*))
(DEFTYPE EOF () '(SATISFIES EOF-P))
(DEFUN TOKEN-DELIMITER-P (CHAR)
  (OR (WHITESPACEP CHAR)
      (MULTIPLE-VALUE-BIND #'NON-TERMINATING-P
          (GET-MACRO-CHARACTER CHAR)
        (AND FUNCTION (NOT NON-TERMINATING-P)))))
(DEFCLASS CHARPOS-STREAM NIL
          ((CHARPOS :INITARG :CHARPOS)
           (PROXY-STREAM :ACCESSOR CHARPOS-PROXY-STREAM :INITARG :PROXY))
          (:DEFAULT-INITARGS :CHARPOS 0))
(DEFGENERIC GET-CHARPOS-STREAM-BUFFER
    (STREAM))
(DEFGENERIC CHARPOS
    (STREAM))
(DEFMETHOD CHARPOS ((STREAM CHARPOS-STREAM))
           (LET* ((BUFFER (GET-CHARPOS-STREAM-BUFFER STREAM))
                  (LEN (LENGTH BUFFER))
                  (NEWLINE
                   (POSITION #\Newline BUFFER :TEST #'CHAR= :FROM-END T)))
             (IF NEWLINE
                 (SETF (SLOT-VALUE STREAM 'CHARPOS) (- LEN 1 NEWLINE))
                 (INCF (SLOT-VALUE STREAM 'CHARPOS) LEN))))
(DEFCLASS CHARPOS-INPUT-STREAM (CHARPOS-STREAM) NIL)
(DEFMETHOD SHARED-INITIALIZE :AROUND
           ((INSTANCE CHARPOS-INPUT-STREAM) SLOT-NAMES &REST INITARGS &KEY
            STREAM)
           (APPLY #'CALL-NEXT-METHOD INSTANCE SLOT-NAMES
                  (LIST* :PROXY
                         (MAKE-ECHO-STREAM STREAM
                                           (MAKE-STRING-OUTPUT-STREAM
                                            :ELEMENT-TYPE
                                            (STREAM-ELEMENT-TYPE STREAM)))
                         INITARGS)))
(DEFMETHOD GET-CHARPOS-STREAM-BUFFER ((STREAM CHARPOS-INPUT-STREAM))
           (GET-OUTPUT-STREAM-STRING
            (ECHO-STREAM-OUTPUT-STREAM (CHARPOS-PROXY-STREAM STREAM))))
(DEFCLASS CHARPOS-OUTPUT-STREAM (CHARPOS-STREAM) NIL)
(DEFMETHOD SHARED-INITIALIZE :AROUND
           ((INSTANCE CHARPOS-OUTPUT-STREAM) SLOT-NAMES &REST INITARGS &KEY
            STREAM)
           (APPLY #'CALL-NEXT-METHOD INSTANCE SLOT-NAMES
                  (LIST* :PROXY
                         (MAKE-BROADCAST-STREAM
                          (MAKE-STRING-OUTPUT-STREAM :ELEMENT-TYPE
                                                     (STREAM-ELEMENT-TYPE
                                                      STREAM))
                          STREAM)
                         INITARGS)))
(DEFMETHOD GET-CHARPOS-STREAM-BUFFER ((STREAM CHARPOS-OUTPUT-STREAM))
           (GET-OUTPUT-STREAM-STRING
            (FIRST (BROADCAST-STREAM-STREAMS (CHARPOS-PROXY-STREAM STREAM)))))
(DEFMETHOD INITIALIZE-INSTANCE :AFTER
           ((INSTANCE CHARPOS-STREAM) &REST INITARGS &KEY)
           (DECLARE (IGNORE INITARGS))
           (SETF (GETHASH (CHARPOS-PROXY-STREAM INSTANCE) *CHARPOS-STREAMS*)
                   INSTANCE))
(DEFUN STREAM-CHARPOS (STREAM)
  (CHARPOS
   (OR (GETHASH STREAM *CHARPOS-STREAMS*)
       (ERROR "Not tracking charpos for ~S" STREAM))))
(DEFUN RELEASE-CHARPOS-STREAM (STREAM)
  (MULTIPLE-VALUE-BIND (CHARPOS-STREAM PRESENT-P)
      (GETHASH STREAM *CHARPOS-STREAMS*)
    (COND
     (PRESENT-P (SETF (CHARPOS-PROXY-STREAM CHARPOS-STREAM) NIL)
      (REMHASH STREAM *CHARPOS-STREAMS*))
     (T (WARN "Not tracking charpos for ~S" STREAM)))))
(DEFUN MAKE-CHARPOS-INPUT-STREAM (INPUT-STREAM &KEY (CHARPOS 0))
  (MAKE-INSTANCE 'CHARPOS-INPUT-STREAM :STREAM
                 (CASE INPUT-STREAM
                   ((T) *TERMINAL-IO*)
                   ((NIL) *STANDARD-INPUT*)
                   (OTHERWISE INPUT-STREAM))
                 :CHARPOS CHARPOS))
(DEFUN MAKE-CHARPOS-OUTPUT-STREAM (OUTPUT-STREAM &KEY (CHARPOS 0))
  (MAKE-INSTANCE 'CHARPOS-OUTPUT-STREAM :STREAM
                 (CASE OUTPUT-STREAM
                   ((T) *TERMINAL-IO*)
                   ((NIL) *STANDARD-OUTPUT*)
                   (OTHERWISE OUTPUT-STREAM))
                 :CHARPOS CHARPOS))
(DEFMACRO WITH-CHARPOS-INPUT-STREAM ((VAR STREAM &KEY (CHARPOS 0)) &BODY BODY)
  `(LET ((,VAR
          (CHARPOS-PROXY-STREAM
           (MAKE-CHARPOS-INPUT-STREAM ,STREAM :CHARPOS ,CHARPOS))))
     (UNWIND-PROTECT (PROGN ,@BODY) (RELEASE-CHARPOS-STREAM ,VAR))))
(DEFMACRO WITH-CHARPOS-OUTPUT-STREAM ((VAR STREAM &KEY (CHARPOS 0)) &BODY BODY)
  `(LET ((,VAR
          (CHARPOS-PROXY-STREAM
           (MAKE-CHARPOS-OUTPUT-STREAM ,STREAM :CHARPOS ,CHARPOS))))
     (UNWIND-PROTECT (PROGN ,@BODY) (RELEASE-CHARPOS-STREAM ,VAR))))
(DEFMACRO WITH-REWIND-STREAM
          ((VAR STREAM &OPTIONAL (REWIND 'REWIND))
           &BODY BODY
           &AUX (OUT (GENSYM)))
  `(WITH-OPEN-STREAM (,OUT (MAKE-STRING-OUTPUT-STREAM))
     (WITH-OPEN-STREAM (,VAR (MAKE-ECHO-STREAM ,STREAM ,OUT))
       (FLET ((,REWIND ,NIL
                (SETQ ,VAR
                        (MAKE-CONCATENATED-STREAM
                         (MAKE-STRING-INPUT-STREAM
                          (GET-OUTPUT-STREAM-STRING ,OUT))
                         ,VAR))))
         ,@BODY))))
(DEFMACRO READ-WITH-ECHO
          ((STREAM VALUES ECHOED &KEY PREFIX)
           &BODY BODY
           &AUX (OUT (GENSYM)) (ECHO (GENSYM)) (REWIND (GENSYM))
           (RAW-OUTPUT (GENSYM)) (LENGTH (GENSYM)))
  `(WITH-OPEN-STREAM (,OUT (MAKE-STRING-OUTPUT-STREAM))
     (WITH-OPEN-STREAM (,ECHO (MAKE-ECHO-STREAM ,STREAM ,OUT))
       (WITH-OPEN-STREAM
           (,REWIND
            (MAKE-CONCATENATED-STREAM
             ,@(WHEN PREFIX `((MAKE-STRING-INPUT-STREAM ,PREFIX))) ,ECHO))
         (LET* ((,VALUES
                 (MULTIPLE-VALUE-LIST (READ-PRESERVING-WHITESPACE ,REWIND)))
                (,RAW-OUTPUT (GET-OUTPUT-STREAM-STRING ,OUT))
                (,LENGTH (LENGTH ,RAW-OUTPUT))
                (,ECHOED
                 (SUBSEQ ,RAW-OUTPUT ,0
                         (IF (OR (EOF-P (PEEK-CHAR ,NIL ,REWIND NIL *EOF*))
                                 (TOKEN-DELIMITER-P
                                  (ELT ,RAW-OUTPUT (1- ,LENGTH))))
                             ,LENGTH
                             (1- ,LENGTH)))))
           (DECLARE (IGNORABLE ,VALUES ,ECHOED))
           ,@BODY)))))
(DEFCLASS MARKER NIL ((VALUE :READER MARKER-VALUE :INITARG :VALUE)))
(DEFUN MARKERP (X) (TYPEP X 'MARKER))
(DEFGENERIC MARKER-BOUNDP
    (MARKER))
(DEFMETHOD MARKER-BOUNDP ((MARKER MARKER)) (SLOT-BOUNDP MARKER 'VALUE))
(DEFMETHOD PRINT-OBJECT ((OBJ MARKER) STREAM)
           (IF *PRINT-MARKER*
               (WHEN (MARKER-BOUNDP OBJ)
                 (WRITE (MARKER-VALUE OBJ) :STREAM STREAM))
               (PRINT-UNREADABLE-OBJECT (OBJ STREAM :TYPE T :IDENTITY T)
                 (WHEN (MARKER-BOUNDP OBJ) (PRINC (MARKER-VALUE OBJ) STREAM)))))
(DEFCLASS NEWLINE-MARKER (MARKER)
          ((INDENTATION :ACCESSOR INDENTATION :INITFORM NIL)))
(DEFUN NEWLINEP (OBJ) (TYPEP OBJ 'NEWLINE-MARKER))
(SET-MACRO-CHARACTER #\Newline
                     (LAMBDA (STREAM CHAR)
                       (DECLARE (IGNORE STREAM CHAR))
                       (MAKE-INSTANCE 'NEWLINE-MARKER))
                     NIL (READTABLE-FOR-MODE :LISP))
(DEFCLASS EMPTY-LIST-MARKER (MARKER) NIL (:DEFAULT-INITARGS :VALUE 'NIL))
(DEFVAR *EMPTY-LIST* (MAKE-INSTANCE 'EMPTY-LIST-MARKER))
(DEFCLASS LIST-MARKER (MARKER)
          ((LENGTH :ACCESSOR LIST-MARKER-LENGTH :INITARG :LENGTH)
           (LIST :ACCESSOR LIST-MARKER-LIST :INITARG :LIST)
           (CHARPOS :ACCESSOR LIST-MARKER-CHARPOS :INITARG :CHARPOS)))
(DEFUN LIST-MARKER-P (OBJ) (TYPEP OBJ 'LIST-MARKER))
(DEFCLASS CONSING-DOT-MARKER (MARKER) NIL)
(DEFVAR *CONSING-DOT* (MAKE-INSTANCE 'CONSING-DOT-MARKER))
(DEFMETHOD MARKER-BOUNDP ((MARKER LIST-MARKER)) T)
(DEFMETHOD MARKER-VALUE ((MARKER LIST-MARKER))
           (DO* ((LIST (LIST NIL))
                 (TAIL LIST)
                 (MARKER-LIST (LIST-MARKER-LIST MARKER) (CDR MARKER-LIST))
                 (X (CAR MARKER-LIST) (CAR MARKER-LIST)))
                ((ENDP MARKER-LIST) (CDR LIST))
             (COND
              ((EQ X *CONSING-DOT*)
               (RPLACD TAIL
                       (DOLIST
                           (X MARKER-LIST (ERROR "Nothing after . in list"))
                         (WHEN
                             (OR (NOT (MARKERP X))
                                 (AND (MARKERP X) (MARKER-BOUNDP X)))
                           (RETURN X))))
               (RETURN (CDR LIST)))
              ((MARKERP X)
               (WHEN (MARKER-BOUNDP X)
                 (LET ((OBJ (LIST X)))
                   (RPLACD TAIL OBJ)
                   (SETQ TAIL OBJ))))
              (T
               (LET ((OBJ (LIST X)))
                 (RPLACD TAIL OBJ)
                 (SETQ TAIL OBJ))))))
(DEFUN MAKE-LIST-READER (NEXT)
  (LAMBDA (STREAM CHAR)
    (IF (CHAR= (PEEK-CHAR T STREAM T NIL T) #\))
        (PROGN (READ-CHAR STREAM T NIL T) *EMPTY-LIST*)
        (FUNCALL NEXT STREAM CHAR))))
(SET-MACRO-CHARACTER #\( (MAKE-LIST-READER (GET-MACRO-CHARACTER #\( NIL)) NIL
                     (READTABLE-FOR-MODE :INNER-LISP))
(DEFUN LIST-READER (STREAM CHAR)
  (DECLARE (IGNORE CHAR))
  (LOOP WITH LIST = 'NIL
        WITH CHARPOS-LIST = 'NIL
        FOR N FROM 0
        FOR FIRST-CHAR = (PEEK-CHAR T STREAM T NIL
                                    T) AS CHARPOS = (STREAM-CHARPOS STREAM)
        UNTIL (CHAR= FIRST-CHAR #\))
        IF (CHAR= FIRST-CHAR #\.)
        DO (WITH-REWIND-STREAM (STREAM STREAM)
             (READ-CHAR STREAM T)
             (LET ((NEXT-CHAR (READ-CHAR STREAM T)))
               (COND
                ((TOKEN-DELIMITER-P NEXT-CHAR)
                 (UNLESS (OR LIST *READ-SUPPRESS*)
                   (SIMPLE-READER-ERROR STREAM
                                        "Nothing appears before . in list."))
                 (PUSH *CONSING-DOT* LIST) (PUSH CHARPOS CHARPOS-LIST))
                (T (REWIND) (PUSH (READ STREAM T NIL T) LIST)
                 (PUSH CHARPOS CHARPOS-LIST))))) ELSE
        DO (PUSH (READ STREAM T NIL T) LIST) (PUSH CHARPOS CHARPOS-LIST)
        FINALLY (READ-CHAR STREAM T NIL T) (RETURN
                                            (MAKE-INSTANCE 'LIST-MARKER :LENGTH
                                                           N :LIST
                                                           (NREVERSE LIST)
                                                           :CHARPOS
                                                           (NREVERSE
                                                            CHARPOS-LIST)))))
(SET-MACRO-CHARACTER #\( (MAKE-LIST-READER #'LIST-READER) NIL
                     (READTABLE-FOR-MODE :LISP))
(DEFCLASS QUOTE-MARKER (MARKER)
          ((QUOTE :READER QUOTE-MARKER-QUOTE :INITARG :QUOTE)
           (FORM :READER QUOTED-FORM :INITARG :FORM)))
(DEFMETHOD MARKER-BOUNDP ((MARKER QUOTE-MARKER)) T)
(DEFMETHOD MARKER-VALUE ((MARKER QUOTE-MARKER))
           (LIST (QUOTE-MARKER-QUOTE MARKER) (QUOTED-FORM MARKER)))
(DEFUN SINGLE-QUOTE-READER (STREAM CHAR)
  (DECLARE (IGNORE CHAR))
  (MAKE-INSTANCE 'QUOTE-MARKER :QUOTE 'QUOTE :FORM (READ STREAM T NIL T)))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-MACRO-CHARACTER #\' #'SINGLE-QUOTE-READER NIL (READTABLE-FOR-MODE MODE)))
(DEFCLASS COMMENT-MARKER (MARKER) ((TEXT :READER COMMENT-TEXT :INITARG :TEXT)))
(DEFUN COMMENT-READER (STREAM CHAR)
  (MAKE-INSTANCE 'COMMENT-MARKER :TEXT
                 (WITH-OUTPUT-TO-STRING (S)
                   (WRITE-CHAR CHAR S)
                   (DO ()
                       ((CHAR= (PEEK-CHAR NIL STREAM NIL #\Newline T)
                               #\Newline))
                     (WRITE-CHAR (READ-CHAR STREAM T NIL T) S)))))
(SET-MACRO-CHARACTER #\; #'COMMENT-READER NIL (READTABLE-FOR-MODE :LISP))
(DEFCLASS BACKQUOTE-MARKER (MARKER) ((FORM :READER BACKQ-FORM :INITARG :FORM)))
(DEFMETHOD MARKER-BOUNDP ((MARKER BACKQUOTE-MARKER)) T)
(DEFMETHOD MARKER-VALUE ((MARKER BACKQUOTE-MARKER))
           (LET ((*PRINT-PRETTY* NIL)
                 (*PRINT-READABLY* T)
                 (*PRINT-MARKER* T)
                 (*READTABLE* (READTABLE-FOR-MODE NIL)))
             (VALUES (READ-FROM-STRING (PRIN1-TO-STRING MARKER)))))
(DEFMETHOD PRINT-OBJECT ((OBJ BACKQUOTE-MARKER) STREAM)
           (IF *PRINT-MARKER*
               (FORMAT STREAM "`~W" (BACKQ-FORM OBJ))
               (PRINT-UNREADABLE-OBJECT (OBJ STREAM :TYPE T :IDENTITY T))))
(DEFUN BACKQUOTE-READER (STREAM CHAR)
  (DECLARE (IGNORE CHAR))
  (MAKE-INSTANCE 'BACKQUOTE-MARKER :FORM (READ STREAM T NIL T)))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-MACRO-CHARACTER #\` #'BACKQUOTE-READER NIL (READTABLE-FOR-MODE MODE)))
(DEFCLASS COMMA-MARKER (MARKER)
          ((FORM :READER COMMA-FORM :INITARG :FORM)
           (MODIFIER :READER COMMA-MODIFIER :INITARG :MODIFIER))
          (:DEFAULT-INITARGS :MODIFIER NIL))
(DEFMETHOD MARKER-BOUNDP ((MARKER COMMA-MARKER)) T)
(DEFMETHOD MARKER-VALUE ((MARKER COMMA-MARKER)) MARKER)
(DEFMETHOD PRINT-OBJECT ((OBJ COMMA-MARKER) STREAM)
           (IF *PRINT-MARKER*
               (FORMAT STREAM ",~@[~C~]~W" (COMMA-MODIFIER OBJ)
                       (COMMA-FORM OBJ))
               (PRINT-UNREADABLE-OBJECT (OBJ STREAM :TYPE T :IDENTITY T))))
(DEFUN COMMA-READER (STREAM CHAR)
  (DECLARE (IGNORE CHAR))
  (CASE (PEEK-CHAR NIL STREAM T NIL T)
    ((#\@ #\.)
     (MAKE-INSTANCE 'COMMA-MARKER :MODIFIER (READ-CHAR STREAM) :FORM
                    (READ STREAM T NIL T)))
    (T (MAKE-INSTANCE 'COMMA-MARKER :FORM (READ STREAM T NIL T)))))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-MACRO-CHARACTER #\, #'COMMA-READER NIL (READTABLE-FOR-MODE MODE)))
(DEFCLASS FUNCTION-MARKER (QUOTE-MARKER) NIL)
(DEFUN SHARPSIGN-QUOTE-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR ARG))
  (MAKE-INSTANCE 'FUNCTION-MARKER :QUOTE 'FUNCTION :FORM (READ STREAM T NIL T)))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\' #'SHARPSIGN-QUOTE-READER
                                (READTABLE-FOR-MODE MODE)))
(DEFCLASS SIMPLE-VECTOR-MARKER (MARKER)
          ((LENGTH :INITARG :LENGTH) (ELEMENTS :INITARG :ELEMENTS)
           (ELEMENT-TYPE :INITARG :ELEMENT-TYPE))
          (:DEFAULT-INITARGS :ELEMENT-TYPE T))
(DEFMETHOD MARKER-BOUNDP ((MARKER SIMPLE-VECTOR-MARKER)) T)
(DEFMETHOD MARKER-VALUE ((MARKER SIMPLE-VECTOR-MARKER))
           (WITH-SLOTS (ELEMENTS ELEMENT-TYPE)
               MARKER
             (IF (SLOT-BOUNDP MARKER 'LENGTH)
                 (WITH-SLOTS (LENGTH)
                     MARKER
                   (LET ((SUPPLIED-LENGTH (LENGTH ELEMENTS)))
                     (FILL
                      (REPLACE (MAKE-ARRAY LENGTH :ELEMENT-TYPE ELEMENT-TYPE)
                               ELEMENTS)
                      (ELT ELEMENTS (1- SUPPLIED-LENGTH)) :START
                      SUPPLIED-LENGTH)))
                 (COERCE ELEMENTS `(VECTOR ,ELEMENT-TYPE)))))
(DEFUN SIMPLE-VECTOR-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR))
  (LET* ((LIST (READ-DELIMITED-LIST #\) STREAM T))
         (LENGTH
          (HANDLER-CASE (LENGTH LIST)
                        (TYPE-ERROR (ERROR) (DECLARE (IGNORE ERROR))
                         (SIMPLE-READER-ERROR STREAM "improper list in #(): ~S"
                                              LIST)))))
    (UNLESS *READ-SUPPRESS*
      (IF ARG
          (IF (> LENGTH ARG)
              (SIMPLE-READER-ERROR STREAM
                                   "vector longer than specified length: #~S~S"
                                   ARG LIST)
              (MAKE-INSTANCE 'SIMPLE-VECTOR-MARKER :LENGTH ARG :ELEMENTS LIST))
          (MAKE-INSTANCE 'SIMPLE-VECTOR-MARKER :ELEMENTS LIST)))))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\( #'SIMPLE-VECTOR-READER
                                (READTABLE-FOR-MODE MODE)))
(DEFCLASS BIT-VECTOR-MARKER (SIMPLE-VECTOR-MARKER) NIL
          (:DEFAULT-INITARGS :ELEMENT-TYPE 'BIT))
(DEFUN SIMPLE-BIT-VECTOR-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR))
  (LET ((*READTABLE* (READTABLE-FOR-MODE NIL)))
    (READ-WITH-ECHO (STREAM VALUES BITS :PREFIX (FORMAT NIL "#~@[~D~]*" ARG))
      (APPLY #'MAKE-INSTANCE 'BIT-VECTOR-MARKER :ELEMENTS
             (MAP 'BIT-VECTOR (LAMBDA (C) (ECASE C (#\0 0) (#\1 1)))
                  (SUBSEQ BITS 0
                          (LET ((N (LENGTH BITS)))
                            (CASE (ELT BITS (1- N))
                              ((#\0 #\1) N)
                              (T (1- N))))))
             (IF ARG
                 (LIST :LENGTH ARG))))))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\* #'SIMPLE-BIT-VECTOR-READER
                                (READTABLE-FOR-MODE MODE)))
(DEFCLASS READ-TIME-EVAL NIL
          ((FORM :READER READ-TIME-EVAL-FORM :INITARG :FORM)))
(DEFMETHOD PRINT-OBJECT ((OBJ READ-TIME-EVAL) STREAM)
           (IF *PRINT-MARKER*
               (FORMAT STREAM "#.~W" (READ-TIME-EVAL-FORM OBJ))
               (PRINT-UNREADABLE-OBJECT (OBJ STREAM :TYPE T :IDENTITY T))))
(DEFCLASS READ-TIME-EVAL-MARKER (READ-TIME-EVAL MARKER) NIL)
(DEFMETHOD MARKER-BOUNDP ((MARKER READ-TIME-EVAL-MARKER)) T)
(DEFMETHOD MARKER-VALUE ((MARKER READ-TIME-EVAL-MARKER))
           (IF *EVALUATING*
               (CALL-NEXT-METHOD)
               (MAKE-INSTANCE 'READ-TIME-EVAL :FORM
                              (READ-TIME-EVAL-FORM MARKER))))
(DEFUN SHARPSIGN-DOT-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR ARG))
  (LET* ((*READTABLE*
          (IF *EVALUATING*
              (READTABLE-FOR-MODE NIL)
              *READTABLE*))
         (FORM (READ STREAM T NIL T)))
    (UNLESS *READ-SUPPRESS*
      (UNLESS *READ-EVAL*
        (SIMPLE-READER-ERROR STREAM "can't read #. while *READ-EVAL* is NIL"))
      (MAKE-INSTANCE 'READ-TIME-EVAL-MARKER :FORM FORM :VALUE (EVAL FORM)))))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\. #'SHARPSIGN-DOT-READER
                                (READTABLE-FOR-MODE MODE)))
(DEFCLASS RADIX-MARKER (MARKER)
          ((BASE :READER RADIX-MARKER-BASE :INITARG :BASE)))
(DEFPARAMETER *RADIX-PREFIX-ALIST* '((#\B . 2) (#\O . 8) (#\X . 16) (#\R)))
(DEFUN RADIX-READER (STREAM SUB-CHAR ARG)
  (MAKE-INSTANCE 'RADIX-MARKER :BASE
                 (OR (CDR (ASSOC (CHAR-UPCASE SUB-CHAR) *RADIX-PREFIX-ALIST*))
                     ARG)
                 :VALUE
                 (FUNCALL
                  (GET-DISPATCH-MACRO-CHARACTER #\# SUB-CHAR
                                                (READTABLE-FOR-MODE NIL))
                  STREAM SUB-CHAR ARG)))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (DOLIST (SUB-CHAR '(#\B #\b #\O #\o #\X #\x #\R #\r))
    (SET-DISPATCH-MACRO-CHARACTER #\# SUB-CHAR #'RADIX-READER
                                  (READTABLE-FOR-MODE MODE))))
(DEFCLASS STRUCTURE-MARKER (MARKER)
          ((FORM :READER STRUCTURE-MARKER-FORM :INITARG :FORM)))
(DEFMETHOD MARKER-BOUNDP ((MARKER STRUCTURE-MARKER)) T)
(DEFMETHOD MARKER-VALUE ((MARKER STRUCTURE-MARKER))
           (LET ((*PRINT-PRETTY* NIL)
                 (*PRINT-READABLY* T)
                 (*PRINT-MARKER* T)
                 (*READTABLE* (READTABLE-FOR-MODE NIL)))
             (VALUES (READ-FROM-STRING (PRIN1-TO-STRING MARKER)))))
(DEFMETHOD PRINT-OBJECT ((OBJ STRUCTURE-MARKER) STREAM)
           (IF *PRINT-MARKER*
               (FORMAT STREAM "#S~W" (STRUCTURE-MARKER-FORM OBJ))
               (PRINT-UNREADABLE-OBJECT (OBJ STREAM :TYPE T :IDENTITY T))))
(DEFUN STRUCTURE-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR ARG))
  (MAKE-INSTANCE 'STRUCTURE-MARKER :FORM (READ STREAM T NIL T)))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\S #'STRUCTURE-READER
                                (READTABLE-FOR-MODE MODE)))
(DEFUN FEATUREP (X)
  (ETYPECASE X
    (CONS
     (CASE (CAR X)
       ((:NOT NOT)
        (COND
         ((CDDR X)
          (ERROR "too many subexpressions in feature expression: ~S" X))
         ((NULL (CDR X))
          (ERROR "too few subexpressions in feature expression: ~S" X))
         (T (NOT (FEATUREP (CADR X))))))
       ((:AND AND) (EVERY #'FEATUREP (CDR X)))
       ((:OR OR) (SOME #'FEATUREP (CDR X)))
       (T (ERROR "unknown operator in feature expression: ~S." X))))
    (SYMBOL (NOT (NULL (MEMBER X *FEATURES* :TEST #'EQ))))))
(DEFCLASS READ-TIME-CONDITIONAL NIL
          ((PLUSP :READER READ-TIME-CONDITIONAL-PLUSP :INITARG :PLUSP)
           (TEST :READER READ-TIME-CONDITIONAL-TEST :INITARG :TEST)
           (FORM :READER READ-TIME-CONDITIONAL-FORM :INITARG :FORM)))
(DEFMETHOD PRINT-OBJECT ((OBJ READ-TIME-CONDITIONAL) STREAM)
           (IF *PRINT-MARKER*
               (FORMAT STREAM "#~:[-~;+~]~S ~A"
                       (READ-TIME-CONDITIONAL-PLUSP OBJ)
                       (READ-TIME-CONDITIONAL-TEST OBJ)
                       (READ-TIME-CONDITIONAL-FORM OBJ))
               (PRINT-UNREADABLE-OBJECT (OBJ STREAM :TYPE T :IDENTITY T))))
(DEFCLASS READ-TIME-CONDITIONAL-MARKER (READ-TIME-CONDITIONAL MARKER) NIL)
(DEFMETHOD MARKER-BOUNDP ((MARKER READ-TIME-CONDITIONAL-MARKER))
           (IF *EVALUATING*
               (CALL-NEXT-METHOD)
               T))
(DEFMETHOD MARKER-VALUE ((MARKER READ-TIME-CONDITIONAL-MARKER))
           (IF *EVALUATING*
               (CALL-NEXT-METHOD)
               (MAKE-INSTANCE 'READ-TIME-CONDITIONAL :PLUSP
                              (READ-TIME-CONDITIONAL-PLUSP MARKER) :TEST
                              (READ-TIME-CONDITIONAL-TEST MARKER) :FORM
                              (READ-TIME-CONDITIONAL-FORM MARKER))))
(DEFUN READ-TIME-CONDITIONAL-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE ARG))
  (LET* ((PLUSP (ECASE SUB-CHAR (#\+ T) (#\- NIL)))
         (*READTABLE* (READTABLE-FOR-MODE NIL))
         (TEST
          (LET ((*PACKAGE* (FIND-PACKAGE "KEYWORD")) (*READ-SUPPRESS* NIL))
            (READ STREAM T NIL T)))
         (*READ-SUPPRESS*
          (IF PLUSP
              (NOT (FEATUREP TEST))
              (FEATUREP TEST))))
    (PEEK-CHAR T STREAM T NIL T)
    (READ-WITH-ECHO (STREAM VALUES FORM)
      (APPLY #'MAKE-INSTANCE 'READ-TIME-CONDITIONAL-MARKER :PLUSP PLUSP :TEST
             TEST :FORM FORM
             (AND (NOT *READ-SUPPRESS*) VALUES (LIST :VALUE (CAR VALUES)))))))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\+ #'READ-TIME-CONDITIONAL-READER
                                (READTABLE-FOR-MODE MODE))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\- #'READ-TIME-CONDITIONAL-READER
                                (READTABLE-FOR-MODE MODE)))
(DEFUN SNARF-UNTIL-CONTROL-CHAR
       (STREAM CONTROL-CHARS
        &AUX
        (CONTROL-CHARS
         (IF (LISTP CONTROL-CHARS)
             CONTROL-CHARS
             (LIST CONTROL-CHARS))))
  (WITH-OUTPUT-TO-STRING (STRING)
    (LOOP FOR CHAR = (PEEK-CHAR NIL STREAM NIL *EOF* NIL)
          UNTIL (OR (EOF-P CHAR) (MEMBER CHAR CONTROL-CHARS))
          DO (WRITE-CHAR (READ-CHAR STREAM) STRING))))
(DEFUN READ-INNER-LISP (STREAM CHAR)
  (WITH-MODE :INNER-LISP
    (READ-DELIMITED-LIST CHAR STREAM T)))
(DOLIST (MODE '(:TEX :RESTRICTED))
  (SET-MACRO-CHARACTER #\| #'READ-INNER-LISP NIL (READTABLE-FOR-MODE MODE)))
(SET-MACRO-CHARACTER #\| (GET-MACRO-CHARACTER #\) NIL) NIL
                     (READTABLE-FOR-MODE :INNER-LISP))
(DOLIST (MODE *MODES*)
  (IGNORE-ERRORS
   (MAKE-DISPATCH-MACRO-CHARACTER #\@ T (READTABLE-FOR-MODE MODE))))
(DEFUN GET-CONTROL-CODE (SUB-CHAR MODE)
  (GET-DISPATCH-MACRO-CHARACTER #\@ SUB-CHAR (READTABLE-FOR-MODE MODE)))
(DEFUN SET-CONTROL-CODE (SUB-CHAR FUNCTION &OPTIONAL (MODES *MODES*))
  (DOLIST
      (MODE
       (IF (LISTP MODES)
           MODES
           (LIST MODES)))
    (SET-DISPATCH-MACRO-CHARACTER #\@ SUB-CHAR FUNCTION
                                  (READTABLE-FOR-MODE MODE))))
(SET-CONTROL-CODE #\@
                  (LAMBDA (STREAM SUB-CHAR ARG)
                    (DECLARE (IGNORE SUB-CHAR STREAM ARG))
                    (STRING "@")))
(DEFUN SUPPRESS-LINE-BREAK-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR ARG))
  (WHEN (EQL (PEEK-CHAR NIL STREAM NIL NIL T) #\Newline)
    (READ-CHAR STREAM T NIL T))
  (VALUES))
(SET-CONTROL-CODE #\+ #'SUPPRESS-LINE-BREAK-READER :LISP)
(DEFUN START-SECTION-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE STREAM ARG))
  (MAKE-INSTANCE (ECASE SUB-CHAR (#\  'SECTION) (#\* 'STARRED-SECTION))))
(DOLIST (SUB-CHAR '(#\  #\*))
  (SET-CONTROL-CODE SUB-CHAR #'START-SECTION-READER '(:LIMBO :TEX :LISP)))
(DEFUN START-TEST-SECTION-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR ARG))
  (PROG1
      (IF (AND (CHAR= (PEEK-CHAR T STREAM T NIL T) #\*)
               (READ-CHAR STREAM T NIL T))
          (MAKE-INSTANCE 'STARRED-TEST-SECTION)
          (MAKE-INSTANCE 'TEST-SECTION))
    (LOOP UNTIL (CHAR/= (PEEK-CHAR T STREAM T NIL T) #\Newline)
          DO (READ-CHAR STREAM T NIL T))))
(SET-CONTROL-CODE #\t #'START-TEST-SECTION-READER '(:LIMBO :TEX :LISP))
(DEFCLASS START-CODE-MARKER (MARKER)
          ((NAME :READER SECTION-NAME :INITARG :NAME))
          (:DEFAULT-INITARGS :NAME NIL))
(DEFUN START-CODE-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE STREAM SUB-CHAR ARG))
  (MAKE-INSTANCE 'START-CODE-MARKER))
(DOLIST (SUB-CHAR '(#\l #\p))
  (SET-CONTROL-CODE SUB-CHAR #'START-CODE-READER '(:TEX :LISP)))
(DEFCLASS EVALUATED-FORM-MARKER (MARKER) NIL)
(DEFUN READ-EVALUATED-FORM (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR ARG))
  (LOOP FOR FORM = (READ STREAM T NIL T)
        UNTIL (NOT (NEWLINEP FORM))
        FINALLY (RETURN (MAKE-INSTANCE 'EVALUATED-FORM-MARKER :VALUE FORM))))
(SET-CONTROL-CODE #\e #'READ-EVALUATED-FORM :LISP)
(DEFVAR *END-CONTROL-TEXT* (MAKE-SYMBOL "@>"))
(SET-CONTROL-CODE #\> (CONSTANTLY *END-CONTROL-TEXT*) :RESTRICTED)
(DEFUN READ-CONTROL-TEXT
       (STREAM &OPTIONAL (EOF-ERROR-P T) (EOF-VALUE NIL) (RECURSIVE-P NIL))
  (WITH-MODE :RESTRICTED
    (APPLY #'CONCATENATE 'STRING
           (LOOP FOR TEXT = (SNARF-UNTIL-CONTROL-CHAR STREAM
                                                      #\@) AS X = (READ-PRESERVING-WHITESPACE
                                                                   STREAM
                                                                   EOF-ERROR-P
                                                                   EOF-VALUE
                                                                   RECURSIVE-P)
                 COLLECT TEXT
                 IF (EQ X *END-CONTROL-TEXT*)
                 DO (LOOP-FINISH) ELSE
                 COLLECT X))))
(DEFUN MAKE-SECTION-NAME-READER (DEFINITION-ALLOWED-P)
  (LAMBDA (STREAM SUB-CHAR ARG)
    (DECLARE (IGNORE SUB-CHAR ARG))
    (LET* ((NAME (READ-CONTROL-TEXT STREAM T NIL T))
           (DEFINITIONP (EQL (PEEK-CHAR NIL STREAM NIL NIL T) #\=)))
      (IF DEFINITIONP
          (IF DEFINITION-ALLOWED-P
              (PROGN
               (READ-CHAR STREAM)
               (MAKE-INSTANCE 'START-CODE-MARKER :NAME NAME))
              (RESTART-CASE (ERROR 'SECTION-NAME-DEFINITION-ERROR :NAME NAME)
                (USE-SECTION NIL :REPORT
                 "Don't define the section, just use it."
                 (FIND-SECTION NAME))))
          (IF DEFINITION-ALLOWED-P
              (RESTART-CASE (ERROR 'SECTION-NAME-USE-ERROR :NAME NAME)
                (NAME-SECTION NIL :REPORT
                 "Name the current section and start the code part."
                 (MAKE-INSTANCE 'START-CODE-MARKER :NAME NAME))
                (CITE-SECTION NIL :REPORT
                 "Assume the section is just being cited."
                 (FIND-SECTION NAME)))
              (LET ((NAMED-SECTION (FIND-SECTION NAME)))
                (PUSHNEW *CURRENT-SECTION* (USED-BY NAMED-SECTION))
                NAMED-SECTION))))))
(SET-CONTROL-CODE #\< (MAKE-SECTION-NAME-READER T) :TEX)
(SET-CONTROL-CODE #\< (MAKE-SECTION-NAME-READER NIL) '(:LISP :INNER-LISP))
(DEFCLASS PAR-MARKER (NEWLINE-MARKER) NIL)
(DEFVAR *PAR* (MAKE-INSTANCE 'PAR-MARKER))
(DEFMACRO MAYBE-PUSH (OBJ PLACE &AUX (G (GENSYM)))
  `(LET ((,G ,OBJ))
     (WHEN
         (IF (STRINGP ,G)
             (PLUSP (LENGTH ,G))
             ,G)
       (PUSH ,G ,PLACE))))
(DEFUN READ-SECTIONS (INPUT-STREAM &KEY (APPEND T))
  (WITH-CHARPOS-INPUT-STREAM (STREAM INPUT-STREAM)
    (FLET ((FINISH-SECTION (SECTION COMMENTARY CODE)
             (WHEN (STRINGP (CAR COMMENTARY))
               (RPLACA COMMENTARY
                       (STRING-RIGHT-TRIM *WHITESPACE* (CAR COMMENTARY))))
             (SETQ COMMENTARY (NREVERSE COMMENTARY))
             (WHEN (STRINGP (CAR COMMENTARY))
               (RPLACA COMMENTARY
                       (STRING-LEFT-TRIM *WHITESPACE* (CAR COMMENTARY))))
             (SETQ CODE (NREVERSE (MEMBER-IF-NOT #'NEWLINEP CODE)))
             (SETF (SECTION-COMMENTARY SECTION) COMMENTARY)
             (SETF (SECTION-CODE SECTION) CODE)
             (WHEN (SECTION-NAME SECTION)
               (LET ((NAMED-SECTION (FIND-SECTION (SECTION-NAME SECTION))))
                 (IF APPEND
                     (PUSH SECTION (NAMED-SECTION-SECTIONS NAMED-SECTION))
                     (SETF (NAMED-SECTION-SECTIONS NAMED-SECTION)
                             (LIST SECTION)))))
             SECTION))
      (PROG (FORM COMMENTARY CODE SECTION SECTIONS)
        (SETQ SECTION (MAKE-INSTANCE 'LIMBO-SECTION))
        (WITH-MODE :LIMBO
          (LOOP (MAYBE-PUSH (SNARF-UNTIL-CONTROL-CHAR STREAM #\@) COMMENTARY)
                (SETQ FORM (READ-PRESERVING-WHITESPACE STREAM NIL *EOF* NIL))
                (TYPECASE FORM
                  (EOF (GO EOF))
                  (SECTION (GO COMMENTARY))
                  (T (PUSH FORM COMMENTARY)))))
       COMMENTARY
        (PUSH (FINISH-SECTION SECTION COMMENTARY CODE) SECTIONS)
        (CHECK-TYPE FORM SECTION)
        (SETQ SECTION FORM
              COMMENTARY 'NIL
              CODE 'NIL)
        (WITH-MODE :TEX
          (LOOP
           (MAYBE-PUSH (SNARF-UNTIL-CONTROL-CHAR STREAM '(#\@ #\|)) COMMENTARY)
           (SETQ FORM (READ-PRESERVING-WHITESPACE STREAM NIL *EOF* NIL))
           (TYPECASE FORM
             (EOF (GO EOF))
             (SECTION (GO COMMENTARY))
             (START-CODE-MARKER
              (SETF (SECTION-NAME SECTION) (SECTION-NAME FORM))
              (GO LISP))
             (T (PUSH FORM COMMENTARY)))))
       LISP
        (CHECK-TYPE FORM START-CODE-MARKER)
        (WITH-MODE :LISP
          (LOOP (SETQ FORM (READ-PRESERVING-WHITESPACE STREAM NIL *EOF* NIL))
                (TYPECASE FORM
                  (EOF (GO EOF))
                  (SECTION (GO COMMENTARY))
                  (START-CODE-MARKER
                   (CERROR "Start a new unnamed section with no commentary."
                           'SECTION-LACKS-COMMENTARY :STREAM STREAM)
                   (SETQ FORM (MAKE-INSTANCE 'SECTION))
                   (PUSH (FINISH-SECTION SECTION COMMENTARY CODE) SECTIONS)
                   (CHECK-TYPE FORM SECTION)
                   (SETQ SECTION FORM
                         COMMENTARY 'NIL
                         CODE 'NIL))
                  (NEWLINE-MARKER
                   (UNLESS (NULL CODE)
                     (COND ((NEWLINEP (CAR CODE)) (POP CODE) (PUSH *PAR* CODE))
                           (T (PUSH FORM CODE)))))
                  (EVALUATED-FORM-MARKER
                   (LET ((FORM (MARKER-VALUE FORM)))
                     (LET ((*EVALUATING* T)
                           (*READTABLE* (READTABLE-FOR-MODE NIL)))
                       (EVAL (TANGLE FORM)))
                     (PUSH FORM CODE)))
                  (T (PUSH FORM CODE)))))
       EOF
        (PUSH (FINISH-SECTION SECTION COMMENTARY CODE) SECTIONS)
        (RETURN (NREVERSE SECTIONS))))))
(DEFUN TANGLE-1 (FORM &KEY (EXPAND-NAMED-SECTIONS T))
  (FLET ((TANGLE-1 (FORM)
           (TANGLE-1 FORM :EXPAND-NAMED-SECTIONS EXPAND-NAMED-SECTIONS)))
    (TYPECASE FORM
      (MARKER (VALUES (MARKER-VALUE FORM) T))
      (ATOM (VALUES FORM NIL))
      ((CONS NAMED-SECTION *)
       (MULTIPLE-VALUE-BIND (D CDR-EXPANDED-P)
           (TANGLE-1 (CDR FORM))
         (IF EXPAND-NAMED-SECTIONS
             (VALUES (APPEND (SECTION-CODE (CAR FORM)) D) T)
             (VALUES (CONS (CAR FORM) D) CDR-EXPANDED-P))))
      ((CONS MARKER *)
       (VALUES
        (IF (MARKER-BOUNDP (CAR FORM))
            (CONS (MARKER-VALUE (CAR FORM)) (TANGLE-1 (CDR FORM)))
            (TANGLE-1 (CDR FORM)))
        T))
      (T
       (MULTIPLE-VALUE-BIND (A CAR-EXPANDED-P)
           (TANGLE-1 (CAR FORM))
         (MULTIPLE-VALUE-BIND (D CDR-EXPANDED-P)
             (TANGLE-1 (CDR FORM))
           (VALUES
            (IF (AND (EQL A (CAR FORM)) (EQL D (CDR FORM)))
                FORM
                (CONS A D))
            (OR CAR-EXPANDED-P CDR-EXPANDED-P))))))))
(DEFUN TANGLE (FORM &KEY (EXPAND-NAMED-SECTIONS T))
  (LABELS ((EXPAND (FORM EXPANDED)
             (MULTIPLE-VALUE-BIND (NEW-FORM NEWLY-EXPANDED-P)
                 (TANGLE-1 FORM :EXPAND-NAMED-SECTIONS EXPAND-NAMED-SECTIONS)
               (IF NEWLY-EXPANDED-P
                   (EXPAND NEW-FORM T)
                   (VALUES NEW-FORM EXPANDED)))))
    (EXPAND FORM NIL)))
(DEFUN UNNAMED-SECTION-CODE-PARTS (SECTIONS)
  (MAPAPPEND #'SECTION-CODE (COERCE (REMOVE-IF #'SECTION-NAME SECTIONS) 'LIST)))
(DEFUN LOAD-WEB-FROM-STREAM
       (STREAM PRINT
        &KEY (APPEND T)
        &AUX (*READTABLE* *READTABLE*) (*PACKAGE* *PACKAGE*) (*EVALUATING* T))
  (DOLIST
      (FORM
       (TANGLE
        (UNNAMED-SECTION-CODE-PARTS (READ-SECTIONS STREAM :APPEND APPEND)))
       T)
    (IF PRINT
        (LET ((RESULTS (MULTIPLE-VALUE-LIST (EVAL FORM))))
          (FORMAT T "~&; ~{~S~^, ~}~%" RESULTS))
        (EVAL FORM))))
(DEFUN LOAD-WEB
       (FILESPEC
        &KEY (VERBOSE *LOAD-VERBOSE*) (PRINT *LOAD-PRINT*)
        (IF-DOES-NOT-EXIST T) (EXTERNAL-FORMAT :DEFAULT))
  "Load the web given by FILESPEC into the Lisp environment."
  (SETF (FILL-POINTER *SECTIONS*) 0)
  (SETF *CURRENT-SECTION* NIL)
  (SETF (FILL-POINTER *TEST-SECTIONS*) 0)
  (SETQ *NAMED-SECTIONS* NIL)
  (WHEN VERBOSE (FORMAT T "~&; loading WEB from ~S~%" FILESPEC))
  (IF (STREAMP FILESPEC)
      (LOAD-WEB-FROM-STREAM FILESPEC PRINT)
      (WITH-OPEN-FILE
          (STREAM
           (MERGE-PATHNAMES FILESPEC (MAKE-PATHNAME :TYPE "CLW" :CASE :COMMON))
           :DIRECTION :INPUT :EXTERNAL-FORMAT EXTERNAL-FORMAT
           :IF-DOES-NOT-EXIST
           (IF IF-DOES-NOT-EXIST
               :ERROR
               NIL))
        (LOAD-WEB-FROM-STREAM STREAM PRINT))))
(DEFUN LOAD-SECTIONS-FROM-TEMP-FILE
       (FILE APPEND &AUX (TRUENAME (PROBE-FILE FILE)))
  "Load web sections from FILE, then delete it."
  (WHEN TRUENAME
    (UNWIND-PROTECT
        (WITH-OPEN-FILE (STREAM TRUENAME :DIRECTION :INPUT)
          (LOAD-WEB-FROM-STREAM STREAM T :APPEND APPEND))
      (DELETE-FILE TRUENAME))))
(DEFUN TESTS-FILE-PATHNAME
       (OUTPUT-FILE TYPE
        &KEY (TESTS-FILE NIL TESTS-FILE-SUPPLIED-P) &ALLOW-OTHER-KEYS)
  (IF TESTS-FILE
      (MERGE-PATHNAMES TESTS-FILE (MAKE-PATHNAME :TYPE TYPE :CASE :COMMON))
      (UNLESS TESTS-FILE-SUPPLIED-P
        (MAKE-PATHNAME :NAME
                       (CONCATENATE 'STRING
                                    (PATHNAME-NAME OUTPUT-FILE :CASE :COMMON)
                                    "-TESTS")
                       :TYPE TYPE :DEFAULTS OUTPUT-FILE :CASE :COMMON))))
(DEFUN TANGLE-FILE
       (INPUT-FILE
        &REST ARGS
        &KEY OUTPUT-FILE TESTS-FILE (VERBOSE *COMPILE-VERBOSE*)
        (PRINT *COMPILE-PRINT*) (EXTERNAL-FORMAT :DEFAULT) &ALLOW-OTHER-KEYS
        &AUX
        (INPUT-FILE
         (MERGE-PATHNAMES INPUT-FILE
                          (MAKE-PATHNAME :TYPE "CLW" :CASE :COMMON)))
        (OUTPUT-FILE
         (APPLY #'COMPILE-FILE-PATHNAME INPUT-FILE :ALLOW-OTHER-KEYS T ARGS))
        (LISP-FILE
         (MERGE-PATHNAMES (MAKE-PATHNAME :TYPE "LISP" :CASE :COMMON)
                          OUTPUT-FILE))
        (TESTS-FILE (APPLY #'TESTS-FILE-PATHNAME OUTPUT-FILE "LISP" ARGS))
        (*READTABLE* *READTABLE*) (*PACKAGE* *PACKAGE*))
  "Tangle and compile the web in INPUT-FILE, producing OUTPUT-FILE."
  (DECLARE (IGNORE OUTPUT-FILE TESTS-FILE))
  (WHEN VERBOSE (FORMAT T "~&; tangling web from ~A:~%" INPUT-FILE))
  (SETF (FILL-POINTER *SECTIONS*) 0)
  (SETF *CURRENT-SECTION* NIL)
  (SETF (FILL-POINTER *TEST-SECTIONS*) 0)
  (SETQ *NAMED-SECTIONS* NIL)
  (WITH-OPEN-FILE
      (INPUT INPUT-FILE :DIRECTION :INPUT :EXTERNAL-FORMAT EXTERNAL-FORMAT)
    (READ-SECTIONS INPUT))
  (LET ((UNUSED-SECTIONS 'NIL))
    (LABELS ((COLLECT-UNUSED-SECTIONS (SECTION)
               (WHEN SECTION
                 (COLLECT-UNUSED-SECTIONS (LEFT-CHILD SECTION))
                 (COLLECT-UNUSED-SECTIONS (RIGHT-CHILD SECTION))
                 (WHEN (NULL (USED-BY SECTION))
                   (PUSH SECTION UNUSED-SECTIONS)))))
      (COLLECT-UNUSED-SECTIONS *NAMED-SECTIONS*)
      (MAP NIL
           (LAMBDA (SECTION)
             (WARN 'UNUSED-NAMED-SECTION-WARNING :FORMAT-CONTROL
                   "Unused named section <~A>." :FORMAT-ARGUMENTS
                   (LIST (SECTION-NAME SECTION))))
           (SORT UNUSED-SECTIONS #'< :KEY #'SECTION-NUMBER))))
  (FLET ((WRITE-FORMS (SECTIONS OUTPUT-FILE)
           (WITH-OPEN-FILE
               (OUTPUT OUTPUT-FILE :DIRECTION :OUTPUT :IF-EXISTS :SUPERSEDE
                :EXTERNAL-FORMAT EXTERNAL-FORMAT)
             (FORMAT OUTPUT ";;;; TANGLED WEB FROM \"~A\". DO NOT EDIT."
                     INPUT-FILE)
             (LET ((*EVALUATING* NIL) (*PRINT-MARKER* T))
               (DOLIST (FORM (TANGLE (UNNAMED-SECTION-CODE-PARTS SECTIONS)))
                 (PPRINT FORM OUTPUT))))))
    (WHEN (AND TESTS-FILE (> (LENGTH *TEST-SECTIONS*) 1))
      (WHEN VERBOSE (FORMAT T "~&; writing tests to ~A~%" TESTS-FILE))
      (WRITE-FORMS *TEST-SECTIONS* TESTS-FILE)
      (COMPILE-FILE TESTS-FILE :VERBOSE VERBOSE :PRINT PRINT :EXTERNAL-FORMAT
                    EXTERNAL-FORMAT))
    (WHEN VERBOSE (FORMAT T "~&; writing tangled code to ~A~%" LISP-FILE))
    (WRITE-FORMS *SECTIONS* LISP-FILE)
    (APPLY #'COMPILE-FILE LISP-FILE :ALLOW-OTHER-KEYS T ARGS)))
(DEFUN WEAVE
       (INPUT-FILE
        &REST ARGS
        &KEY OUTPUT-FILE TESTS-FILE (VERBOSE *WEAVE-VERBOSE*)
        (PRINT *WEAVE-PRINT*) (IF-DOES-NOT-EXIST T) (EXTERNAL-FORMAT :DEFAULT)
        &AUX
        (INPUT-FILE
         (MERGE-PATHNAMES INPUT-FILE
                          (MAKE-PATHNAME :TYPE "CLW" :CASE :COMMON)))
        (OUTPUT-FILE
         (IF OUTPUT-FILE
             (MERGE-PATHNAMES OUTPUT-FILE
                              (MAKE-PATHNAME :TYPE "TEX" :CASE :COMMON))
             (MERGE-PATHNAMES (MAKE-PATHNAME :TYPE "TEX" :CASE :COMMON)
                              INPUT-FILE)))
        (TESTS-FILE (APPLY #'TESTS-FILE-PATHNAME OUTPUT-FILE "TEX" ARGS))
        (*READTABLE* *READTABLE*) (*PACKAGE* *PACKAGE*))
  "Weave the web contained in INPUT-FILE, producing the TeX file OUTPUT-FILE."
  (DECLARE (IGNORE TESTS-FILE))
  (WHEN VERBOSE (FORMAT T "~&; weaving web from ~A:~%" INPUT-FILE))
  (SETF (FILL-POINTER *SECTIONS*) 0)
  (SETF *CURRENT-SECTION* NIL)
  (SETF (FILL-POINTER *TEST-SECTIONS*) 0)
  (SETQ *NAMED-SECTIONS* NIL)
  (WITH-OPEN-FILE
      (INPUT INPUT-FILE :DIRECTION :INPUT :EXTERNAL-FORMAT EXTERNAL-FORMAT
       :IF-DOES-NOT-EXIST
       (IF IF-DOES-NOT-EXIST
           :ERROR
           NIL))
    (READ-SECTIONS INPUT))
  (WHEN (AND TESTS-FILE (> (LENGTH *TEST-SECTIONS*) 1))
    (WHEN VERBOSE (FORMAT T "~&; weaving tests to ~A~%" TESTS-FILE))
    (WEAVE-SECTIONS *TEST-SECTIONS* TESTS-FILE :PRINT PRINT :EXTERNAL-FORMAT
                    EXTERNAL-FORMAT))
  (WHEN VERBOSE (FORMAT T "~&; weaving sections to ~A~%" OUTPUT-FILE))
  (WEAVE-SECTIONS *SECTIONS* OUTPUT-FILE :PRINT PRINT :EXTERNAL-FORMAT
                  EXTERNAL-FORMAT))
(DEFUN WEAVE-SECTIONS
       (SECTIONS OUTPUT-FILE
        &KEY (PRINT *WEAVE-PRINT*) (EXTERNAL-FORMAT :DEFAULT))
  (WITH-OPEN-FILE
      (OUTPUT OUTPUT-FILE :DIRECTION :OUTPUT :EXTERNAL-FORMAT EXTERNAL-FORMAT
       :IF-EXISTS :SUPERSEDE)
    (FORMAT OUTPUT "\\input clwebmac~%")
    (FLET ((WRITE-SECTION (SECTION)
             (WRITE SECTION :STREAM OUTPUT :CASE :DOWNCASE :ESCAPE NIL :PRETTY
                    T :PPRINT-DISPATCH *WEAVE-PPRINT-DISPATCH* :RIGHT-MARGIN
                    1000)))
      (IF PRINT
          (PPRINT-LOGICAL-BLOCK (NIL NIL :PER-LINE-PREFIX "; ")
            (MAP NIL
                 (LAMBDA (SECTION)
                   (FORMAT T "~:[~;~:@_*~]~D~:_ "
                           (TYPEP SECTION 'STARRED-SECTION)
                           (SECTION-NUMBER SECTION))
                   (WRITE-SECTION SECTION))
                 SECTIONS))
          (MAP NIL #'WRITE-SECTION SECTIONS)))
    (FORMAT OUTPUT "~&\\bye~%")
    (TRUENAME OUTPUT)))
(DEFUN SET-WEAVE-DISPATCH (TYPE-SPECIFIER FUNCTION &OPTIONAL (PRIORITY 0))
  (SET-PPRINT-DISPATCH TYPE-SPECIFIER FUNCTION PRIORITY
                       *WEAVE-PPRINT-DISPATCH*))
(DEFUN PRINT-TEX (STREAM TEX-MODE-MATERIAL)
  (DOLIST (X TEX-MODE-MATERIAL)
    (ETYPECASE X
      (STRING (WRITE-STRING X STREAM))
      (LIST
       (LET ((*INNER-LISP* T))
         (DOLIST (FORM X) (FORMAT STREAM "\\(~W\\)" FORM)))))))
(DEFUN READ-TEX-FROM-STRING (INPUT-STRING)
  (WITH-MODE :RESTRICTED
    (WITH-INPUT-FROM-STRING (STREAM INPUT-STRING)
      (LOOP FOR TEXT = (SNARF-UNTIL-CONTROL-CHAR STREAM #\|)
            FOR FORMS = (READ-PRESERVING-WHITESPACE STREAM NIL *EOF* NIL)
            IF (PLUSP (LENGTH TEXT))
            COLLECT TEXT
            IF (EOF-P FORMS)
            DO (LOOP-FINISH) ELSE
            COLLECT FORMS))))
(DEFUN PRINT-LIMBO (STREAM SECTION)
  (LET ((COMMENTARY (SECTION-COMMENTARY SECTION)))
    (WHEN COMMENTARY (PRINT-TEX STREAM COMMENTARY) (TERPRI STREAM))))
(SET-WEAVE-DISPATCH 'LIMBO-SECTION #'PRINT-LIMBO 1)
(DEFUN PRINT-SECTION (STREAM SECTION)
  (FORMAT STREAM "~&\\~:[M~;N{1}~]{~:[~;T~]~D}"
          (TYPEP SECTION 'STARRED-SECTION) (TYPEP SECTION 'TEST-SECTION)
          (SECTION-NUMBER SECTION))
  (LET* ((COMMENTARY (SECTION-COMMENTARY SECTION))
         (NAME (SECTION-NAME SECTION))
         (NAMED-SECTION (AND NAME (FIND-SECTION NAME)))
         (CODE (SECTION-CODE SECTION)))
    (PRINT-TEX STREAM COMMENTARY)
    (FRESH-LINE STREAM)
    (COND ((AND COMMENTARY CODE) (FORMAT STREAM "\\Y\\B~%"))
          (CODE (FORMAT STREAM "\\B~%")))
    (WHEN NAMED-SECTION
      (PRINT-SECTION-NAME STREAM NAMED-SECTION)
      (FORMAT STREAM "${}~:[\\mathrel+~;~]\\E{}$~%"
              (= (SECTION-NUMBER SECTION) (SECTION-NUMBER NAMED-SECTION))))
    (WHEN CODE
      (DOLIST (FORM CODE)
        (IF (LIST-MARKER-P FORM)
            (FORMAT STREAM "~@<\\+~@;~W~;\\cr~:>" FORM)
            (FORMAT STREAM "~W~:[\\par~;~]" FORM (NEWLINEP FORM))))
      (FORMAT STREAM "~&\\egroup~%"))
    (WHEN (AND (TYPEP SECTION 'TEST-SECTION) (SECTION-CODE SECTION))
      (FORMAT STREAM "\\T~P~D.~%" (LENGTH (SECTION-CODE SECTION))
              (SECTION-NUMBER (TEST-FOR-SECTION SECTION))))
    (WHEN NAMED-SECTION
      (PRINT-XREFS STREAM #\A
                   (REMOVE SECTION (NAMED-SECTION-SECTIONS NAMED-SECTION)))
      (PRINT-XREFS STREAM #\U (REMOVE SECTION (USED-BY NAMED-SECTION)))))
  (FORMAT STREAM "\\fi~%"))
(SET-WEAVE-DISPATCH 'SECTION #'PRINT-SECTION)
(DEFUN PRINT-XREFS (STREAM KIND XREFS)
  (WHEN XREFS
    (FORMAT STREAM
            "\\~C~{~#[~;~D~;s ~D\\ET~D~:;s~@{~#[~;\\ETs~D~;~D~:;~D, ~]~}~]~}.~%"
            KIND (SORT (MAPCAR #'SECTION-NUMBER XREFS) #'<))))
(DEFUN PRINT-SECTION-NAME (STREAM NAMED-SECTION)
  (FORMAT STREAM "\\X~D:" (SECTION-NUMBER NAMED-SECTION))
  (PRINT-TEX STREAM (READ-TEX-FROM-STRING (SECTION-NAME NAMED-SECTION)))
  (WRITE-STRING "\\X" STREAM))
(SET-WEAVE-DISPATCH 'NAMED-SECTION #'PRINT-SECTION-NAME)
(DEFPARAMETER *TEX-ESCAPE-ALIST*
  '((" \\%&#$^_~<>" . #\\) ("{" . "$\\{$") ("}" . "$\\}$")))
(DEFUN WRITE-STRING-ESCAPED
       (STRING
        &OPTIONAL STREAM (ESCAPE-CHARS *TEX-ESCAPE-ALIST*)
        &AUX
        (STREAM
         (CASE STREAM
           ((T) *TERMINAL-IO*)
           ((NIL) *STANDARD-OUTPUT*)
           (OTHERWISE STREAM))))
  (LOOP FOR CHAR ACROSS STRING AS ESCAPE = (CDR
                                            (ASSOC CHAR ESCAPE-CHARS :TEST
                                                   #'FIND))
        IF ESCAPE
        DO (ETYPECASE ESCAPE
             (CHARACTER (WRITE-CHAR ESCAPE STREAM) (WRITE-CHAR CHAR STREAM))
             (STRING (WRITE-STRING ESCAPE STREAM))) ELSE
        DO (WRITE-CHAR CHAR STREAM)))
(DEFUN PRINT-STRING (STREAM STRING)
  (LOOP FOR LAST = 0 THEN (1+ NEWLINE)
        FOR NEWLINE = (POSITION #\Newline STRING :START LAST) AS LINE = (SUBSEQ
                                                                         STRING
                                                                         LAST
                                                                         NEWLINE)
        DO (FORMAT STREAM "\\.{~:[~;\"~]" (ZEROP LAST)) (WRITE-STRING-ESCAPED
                                                         LINE STREAM
                                                         (LIST* '("{*}" . #\\)
                                                                '("\\"
                                                                  . "\\\\\\\\")
                                                                '("\""
                                                                  . "\\\\\"")
                                                                *TEX-ESCAPE-ALIST*)) (FORMAT
                                                                                      STREAM
                                                                                      "~:[~;\"~]}"
                                                                                      (NULL
                                                                                       NEWLINE))
        WHEN NEWLINE
        DO (FORMAT STREAM "\\cr~:@_") ELSE
        DO (LOOP-FINISH)))
(SET-WEAVE-DISPATCH 'STRING #'PRINT-STRING)
(DEFUN PRINT-CHAR (STREAM CHAR)
  (LET ((GRAPHICP (AND (GRAPHIC-CHAR-P CHAR) (STANDARD-CHAR-P CHAR)))
        (NAME (CHAR-NAME CHAR)))
    (WRITE-STRING "\\#\\CH{" STREAM)
    (WRITE-STRING-ESCAPED
     (IF (AND NAME (NOT GRAPHICP))
         NAME
         (MAKE-STRING 1 :INITIAL-ELEMENT CHAR))
     STREAM (LIST* '("{}" . #\\) *TEX-ESCAPE-ALIST*))
    (WRITE-STRING "}" STREAM)
    CHAR))
(SET-WEAVE-DISPATCH 'CHARACTER #'PRINT-CHAR)
(DEFUN PRINT-SYMBOL (STREAM SYMBOL)
  (LET ((GROUP-P
         (COND
          ((MEMBER SYMBOL LAMBDA-LIST-KEYWORDS) (WRITE-STRING "\\K{" STREAM))
          ((KEYWORDP SYMBOL) (WRITE-STRING "\\:{" STREAM)))))
    (WRITE-STRING-ESCAPED (WRITE-TO-STRING SYMBOL :ESCAPE NIL :PRETTY NIL)
                          STREAM)
    (WHEN GROUP-P (WRITE-STRING "}" STREAM))))
(SET-WEAVE-DISPATCH 'SYMBOL #'PRINT-SYMBOL)
(SET-WEAVE-DISPATCH '(EQL LAMBDA)
                    (LAMBDA (STREAM OBJ)
                      (DECLARE (IGNORE OBJ))
                      (WRITE-STRING "\\L" STREAM))
                    1)
(DEFSTRUCT (LOGICAL-BLOCK (:CONSTRUCTOR MAKE-LOGICAL-BLOCK (LIST))) LIST)
(DEFUN ANALYZE-INDENTATION (LIST-MARKER)
  (DECLARE (TYPE LIST-MARKER LIST-MARKER))
  (LABELS ((FIND-NEXT-NEWLINE (LIST)
             (MEMBER-IF #'NEWLINEP LIST :KEY #'CAR))
           (NEXT-LOGICAL-BLOCK (LIST)
             (DO* ((BLOCK 'NIL)
                   (BLOCK-INDENT (CDAR LIST))
                   (INDENT BLOCK-INDENT)
                   (NEWLINE (FIND-NEXT-NEWLINE LIST))
                   (NEXT-INDENT (CDADR NEWLINE)))
                  ((OR (ENDP LIST)
                       (AND (EQ LIST NEWLINE) NEXT-INDENT
                            (< NEXT-INDENT BLOCK-INDENT)))
                   (VALUES
                    (IF (NOTANY #'NEWLINEP BLOCK)
                        (NREVERSE BLOCK)
                        (MAKE-LOGICAL-BLOCK (NREVERSE BLOCK)))
                    LIST))
               (IF (AND INDENT NEXT-INDENT (> NEXT-INDENT INDENT)
                        (= NEXT-INDENT (CDAR LIST)))
                   (MULTIPLE-VALUE-BIND (SUB-BLOCK TAIL)
                       (NEXT-LOGICAL-BLOCK LIST)
                     (CHECK-TYPE (CAAR TAIL) (OR NEWLINE-MARKER NULL))
                     (PUSH SUB-BLOCK BLOCK)
                     (SETQ LIST TAIL))
                   (LET ((NEXT (CAR (POP LIST))))
                     (PUSH NEXT BLOCK)
                     (WHEN (AND LIST (NEWLINEP NEXT))
                       (SETF INDENT (CDAR LIST)
                             (INDENTATION NEXT) (- INDENT BLOCK-INDENT)
                             NEWLINE (FIND-NEXT-NEWLINE LIST)
                             NEXT-INDENT (CDADR NEWLINE))))))))
    (ASSERT
     (= (LENGTH (LIST-MARKER-LIST LIST-MARKER))
        (LENGTH (LIST-MARKER-CHARPOS LIST-MARKER)))
     ((LIST-MARKER-LIST LIST-MARKER) (LIST-MARKER-CHARPOS LIST-MARKER))
     "List marker's list and charpos-list aren't the same length.")
    (NEXT-LOGICAL-BLOCK
     (MAPCAR #'CONS (LIST-MARKER-LIST LIST-MARKER)
             (LIST-MARKER-CHARPOS LIST-MARKER)))))
(DEFUN PRINT-LIST (STREAM LIST-MARKER)
  (LET ((BLOCK (ANALYZE-INDENTATION LIST-MARKER)))
    (ETYPECASE BLOCK
      (LIST (FORMAT STREAM "~<(~;~@{~W~^ ~}~;)~:>" BLOCK))
      (LOGICAL-BLOCK (FORMAT STREAM "(~W)" BLOCK)))))
(SET-WEAVE-DISPATCH 'LIST-MARKER #'PRINT-LIST)
(DEFUN PRINT-LOGICAL-BLOCK (STREAM BLOCK)
  (WRITE-STRING "\\!" STREAM)
  (PPRINT-LOGICAL-BLOCK
      (STREAM (LOGICAL-BLOCK-LIST BLOCK) :PER-LINE-PREFIX "&")
    (DO (INDENT
         NEXT
         (OBJ (PPRINT-POP) NEXT))
        (NIL)
      (COND
       ((NEWLINEP OBJ) (FORMAT STREAM "\\cr~:@_")
        (SETQ INDENT (INDENTATION OBJ)) (PPRINT-EXIT-IF-LIST-EXHAUSTED)
        (SETQ NEXT (PPRINT-POP)))
       (T (FORMAT STREAM "~@[~[~;\\1~;\\1~:;\\2~]~]~W" INDENT OBJ)
        (SETQ INDENT NIL) (PPRINT-EXIT-IF-LIST-EXHAUSTED)
        (SETQ NEXT (PPRINT-POP))
        (UNLESS (NEWLINEP NEXT) (WRITE-CHAR #\  STREAM)))))))
(SET-WEAVE-DISPATCH 'LOGICAL-BLOCK #'PRINT-LOGICAL-BLOCK)
(SET-WEAVE-DISPATCH 'NEWLINE-MARKER
                    (LAMBDA (STREAM OBJ)
                      (DECLARE (IGNORE OBJ))
                      (TERPRI STREAM)))
(SET-WEAVE-DISPATCH 'PAR-MARKER
                    (LAMBDA (STREAM OBJ)
                      (DECLARE (IGNORE OBJ))
                      (FORMAT STREAM "~&\\Y~%"))
                    1)
(SET-WEAVE-DISPATCH 'EMPTY-LIST-MARKER
                    (LAMBDA (STREAM OBJ)
                      (DECLARE (IGNORE OBJ))
                      (WRITE-STRING "()" STREAM)))
(SET-WEAVE-DISPATCH 'CONSING-DOT-MARKER
                    (LAMBDA (STREAM OBJ)
                      (DECLARE (IGNORE OBJ))
                      (WRITE-CHAR #\. STREAM)))
(SET-WEAVE-DISPATCH 'QUOTE-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\'~W" (QUOTED-FORM OBJ))))
(SET-WEAVE-DISPATCH 'COMMENT-MARKER
                    (LAMBDA (STREAM OBJ)
                      (WRITE-STRING "\\C{" STREAM)
                      (PRINT-TEX STREAM
                                 (READ-TEX-FROM-STRING (COMMENT-TEXT OBJ)))
                      (WRITE-STRING "}" STREAM)))
(SET-WEAVE-DISPATCH 'BACKQUOTE-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\`~W" (BACKQ-FORM OBJ))))
(SET-WEAVE-DISPATCH 'COMMA-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\CO{~@[~C~]}~W" (COMMA-MODIFIER OBJ)
                              (COMMA-FORM OBJ))))
(SET-WEAVE-DISPATCH 'FUNCTION-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\#\\'~S" (QUOTED-FORM OBJ)))
                    1)
(SET-WEAVE-DISPATCH 'SIMPLE-VECTOR-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\#~@[~D~]~S"
                              (AND (SLOT-BOUNDP OBJ 'LENGTH)
                                   (SLOT-VALUE OBJ 'LENGTH))
                              (SLOT-VALUE OBJ 'ELEMENTS))))
(SET-WEAVE-DISPATCH 'BIT-VECTOR-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\#~@[~D~]*~{~[0~;1~]~}"
                              (AND (SLOT-BOUNDP OBJ 'LENGTH)
                                   (SLOT-VALUE OBJ 'LENGTH))
                              (MAP 'LIST #'IDENTITY
                                   (SLOT-VALUE OBJ 'ELEMENTS))))
                    1)
(SET-WEAVE-DISPATCH 'READ-TIME-EVAL-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\#.~W" (READ-TIME-EVAL-FORM OBJ))))
(SET-WEAVE-DISPATCH 'RADIX-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "$~VR_{~2:*~D}$" (RADIX-MARKER-BASE OBJ)
                              (MARKER-VALUE OBJ))))
(SET-WEAVE-DISPATCH 'STRUCTURE-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\#S~W" (STRUCTURE-MARKER-FORM OBJ))))
(SET-WEAVE-DISPATCH 'READ-TIME-CONDITIONAL-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\#~:[--~;+~]\\RC{~S"
                              (READ-TIME-CONDITIONAL-PLUSP OBJ)
                              (READ-TIME-CONDITIONAL-TEST OBJ))
                      (WRITE-CHAR #\  STREAM)
                      (WRITE-STRING-ESCAPED (READ-TIME-CONDITIONAL-FORM OBJ)
                                            STREAM)
                      (WRITE-CHAR #\} STREAM)))
(DEFCLASS WALKER NIL NIL)
(DEFGENERIC WALK-FORM
    (WALKER FORM &OPTIONAL ENV))
(DEFGENERIC WALK-AS-SPECIAL-FORM-P
    (WALKER CAR FORM ENV))
(DEFGENERIC MACROEXPAND-FOR-WALK
    (WALKER FORM ENV))
(DEFGENERIC AUGMENT-WALKER-ENVIRONMENT
    (WALKER ENV &REST ARGS))
(DEFGENERIC WALK-ATOMIC-FORM
    (WALKER FORM ENV &OPTIONAL EVALP))
(DEFGENERIC WALK-COMPOUND-FORM
    (WALKER CAR FORM ENV))
(DEFGENERIC WALK-FUNCTION-NAME
    (WALKER FUNCTION-NAME ENV &KEY &ALLOW-OTHER-KEYS))
(DEFGENERIC WALK-DECLARATION-SPECIFIERS
    (WALKER DECLS ENV))
(UNLESS (FBOUNDP 'ENSURE-PORTABLE-WALKING-ENVIRONMENT)
  (DEFUN ENSURE-PORTABLE-WALKING-ENVIRONMENT (ENV) ENV))
(DEFUN ENCLOSE
       (LAMBDA-EXPRESSION &OPTIONAL ENV (WALKER (MAKE-INSTANCE 'WALKER)))
  (COERCE (WALK-FORM WALKER LAMBDA-EXPRESSION ENV) 'FUNCTION))
(UNLESS (FBOUNDP 'PARSE-MACRO)
  (DEFUN PARSE-MACRO (NAME LAMBDA-LIST BODY &OPTIONAL ENV)
    (DECLARE (IGNORABLE NAME LAMBDA-LIST BODY ENV))
    #+:ALLEGRO (excl::defmacro-expander `(,name ,lambda-list ,@body) env)
    #-:ALLEGRO (error "PARSE-MACRO not implemented")))
(DEFUN REORDER-ENV-INFORMATION (FN)
  (LAMBDA (&REST ARGS)
    (MULTIPLE-VALUE-BIND (TYPE LOCATIVE DECLARATIONS LOCAL)
        (APPLY FN ARGS)
      (DECLARE (IGNORE LOCATIVE))
      (VALUES TYPE LOCAL DECLARATIONS))))
#+:ALLEGRO (setf (symbol-function 'variable-information)
      (reorder-env-information #'sys:variable-information)
      (symbol-function 'function-information)
      (reorder-env-information #'sys:function-information))
(DEFMETHOD WALK-FORM
           ((WALKER WALKER) FORM &OPTIONAL ENV &AUX
            (ENV (ENSURE-PORTABLE-WALKING-ENVIRONMENT ENV)) (EXPANDED T))
           (FLET ((SYMBOL-MACRO-P (FORM ENV)
                    (AND (SYMBOLP FORM)
                         (EQL (VARIABLE-INFORMATION FORM ENV) ':SYMBOL-MACRO))))
             (LOOP
              (COND ((SYMBOL-MACRO-P FORM ENV))
                    ((ATOM FORM) (RETURN (WALK-ATOMIC-FORM WALKER FORM ENV)))
                    ((NOT (SYMBOLP (CAR FORM)))
                     (RETURN (WALK-LIST WALKER FORM ENV)))
                    ((OR (NOT EXPANDED)
                         (WALK-AS-SPECIAL-FORM-P WALKER (CAR FORM) FORM ENV))
                     (RETURN (WALK-COMPOUND-FORM WALKER (CAR FORM) FORM ENV))))
              (MULTIPLE-VALUE-SETQ (FORM EXPANDED)
                (MACROEXPAND-FOR-WALK WALKER FORM ENV)))))
(DEFMETHOD WALK-AS-SPECIAL-FORM-P (WALKER CAR FORM ENV)
           (DECLARE (IGNORE WALKER CAR FORM ENV)) NIL)
(DEFMETHOD MACROEXPAND-FOR-WALK ((WALKER WALKER) FORM ENV)
           (MACROEXPAND-1 FORM ENV))
(DEFMETHOD AUGMENT-WALKER-ENVIRONMENT ((WALKER WALKER) ENV &REST ARGS)
           (APPLY #'AUGMENT-ENVIRONMENT ENV ARGS))
(DEFUN WALK-LIST (WALKER LIST ENV)
  (DO ((FORM LIST (CDR FORM))
       (NEWFORM NIL (CONS (WALK-FORM WALKER (CAR FORM) ENV) NEWFORM)))
      ((ATOM FORM) (NRECONC NEWFORM FORM))))
(DEFMETHOD WALK-ATOMIC-FORM ((WALKER WALKER) FORM ENV &OPTIONAL (EVALP T))
           (DECLARE (IGNORE ENV EVALP)) FORM)
(DEFMETHOD WALK-COMPOUND-FORM ((WALKER WALKER) CAR FORM ENV)
           (DECLARE (IGNORE CAR))
           `(,(WALK-ATOMIC-FORM WALKER (CAR FORM) ENV NIL)
             ,@(WALK-LIST WALKER (CDR FORM) ENV)))
(DEFMETHOD WALK-FUNCTION-NAME ((WALKER WALKER) FUNCTION-NAME ENV &KEY)
           (TYPECASE FUNCTION-NAME
             (SYMBOL (WALK-ATOMIC-FORM WALKER FUNCTION-NAME ENV NIL))
             ((CONS (EQL SETF) (CONS SYMBOL NULL))
              `(SETF ,(WALK-ATOMIC-FORM WALKER (CADR FUNCTION-NAME) ENV NIL)))
             (T
              (CERROR "Use the function name anyway." 'INVALID-FUNCTION-NAME
                      :NAME FUNCTION-NAME)
              FUNCTION-NAME)))
(MACROLET ((WALK-AS-SPECIAL-FORM (OPERATOR)
             `(DEFMETHOD WALK-AS-SPECIAL-FORM-P
                         ((WALKER WALKER) (CAR (EQL ',OPERATOR)) FORM ENV)
                         (DECLARE (IGNORE FORM ENV)) T)))
  (WALK-AS-SPECIAL-FORM CATCH)
  (WALK-AS-SPECIAL-FORM IF)
  (WALK-AS-SPECIAL-FORM LOAD-TIME-VALUE)
  (WALK-AS-SPECIAL-FORM MULTIPLE-VALUE-CALL)
  (WALK-AS-SPECIAL-FORM MULTIPLE-VALUE-PROG1)
  (WALK-AS-SPECIAL-FORM PROGN)
  (WALK-AS-SPECIAL-FORM PROGV)
  (WALK-AS-SPECIAL-FORM SETQ)
  (WALK-AS-SPECIAL-FORM TAGBODY)
  (WALK-AS-SPECIAL-FORM THROW)
  (WALK-AS-SPECIAL-FORM UNWIND-PROTECT))
(DEFMACRO DEFINE-SPECIAL-FORM-WALKER
          (OPERATOR (WALKER FORM ENV &REST REST)
           &BODY BODY
           &AUX (CAR `(CAR (EQL ',OPERATOR))))
  (FLET ((ARG-NAME (ARG)
           (IF (CONSP ARG)
               (CAR ARG)
               ARG)))
    `(PROGN
      (DEFMETHOD WALK-AS-SPECIAL-FORM-P (,WALKER ,CAR ,FORM ,ENV)
                 (DECLARE
                  (IGNORABLE
                   ,@(MAPCAR (FUNCTION ARG-NAME) `(,WALKER ,FORM ,ENV))))
                 T)
      (DEFMETHOD WALK-COMPOUND-FORM (,WALKER ,CAR ,FORM ,ENV ,@REST)
                 (DECLARE
                  (IGNORABLE
                   ,@(MAPCAR (FUNCTION ARG-NAME) `(,WALKER ,FORM ,ENV))))
                 ,@BODY))))
(MACROLET ((DEFINE-BLOCK-LIKE-WALKER (OPERATOR)
             `(DEFINE-SPECIAL-FORM-WALKER ,OPERATOR
                  ((WALKER WALKER) FORM ENV)
                ,'`(,(CAR FORM) ,(WALK-ATOMIC-FORM WALKER (CADR FORM) ENV NIL)
                    ,@(WALK-LIST WALKER (CDDR FORM) ENV)))))
  (DEFINE-BLOCK-LIKE-WALKER BLOCK)
  (DEFINE-BLOCK-LIKE-WALKER EVAL-WHEN)
  (DEFINE-BLOCK-LIKE-WALKER RETURN-FROM)
  (DEFINE-BLOCK-LIKE-WALKER THE))
(MACROLET ((DEFINE-QUOTE-LIKE-WALKER (OPERATOR)
             `(DEFINE-SPECIAL-FORM-WALKER ,OPERATOR
                  ((WALKER WALKER) FORM ENV)
                (DECLARE (IGNORE WALKER ENV))
                FORM)))
  (DEFINE-QUOTE-LIKE-WALKER QUOTE)
  (DEFINE-QUOTE-LIKE-WALKER GO))
(DEFINE-SPECIAL-FORM-WALKER FUNCTION
    ((WALKER WALKER) FORM ENV)
  `(,(CAR FORM)
    ,(IF (AND (CONSP (CADR FORM)) (EQL (CAADR FORM) 'LAMBDA))
         (WALK-LAMBDA-EXPRESSION WALKER (CADR FORM) ENV)
         (WALK-FUNCTION-NAME WALKER (CADR FORM) ENV))))
(DEFUN PARSE-BODY (BODY &KEY DOC-STRING-ALLOWED WALKER ENV &AUX DOC)
  (FLET ((DOC-STRING-P (X REMAINING-FORMS)
           (AND (STRINGP X) DOC-STRING-ALLOWED REMAINING-FORMS (NULL DOC)))
         (DECLARATION-P (X)
           (AND (LISTP X) (EQL (CAR X) 'DECLARE))))
    (LOOP FOR FORMS = BODY THEN (CDR FORMS) AS X = (CAR FORMS)
          WHILE FORMS
          IF (DOC-STRING-P X (CDR FORMS))
          DO (SETQ DOC X) ELSE
          IF (DECLARATION-P X)
          APPEND (CDR X) INTO DECLS ELSE
          DO (LOOP-FINISH)
          FINALLY (RETURN
                   (VALUES FORMS
                           (IF WALKER
                               (WALK-DECLARATION-SPECIFIERS WALKER DECLS ENV)
                               DECLS)
                           DOC)))))
(DEFMETHOD WALK-DECLARATION-SPECIFIERS ((WALKER WALKER) DECLS ENV)
           (DECLARE (IGNORE ENV)) DECLS)
(DEFUN WALK-LAMBDA-LIST
       (WALKER LAMBDA-LIST DECLS ENV &AUX NEW-LAMBDA-LIST (STATE :REQVARS))
  (LABELS ((AUGMENT-ENV (&REST VARS &AUX (VARS (REMOVE-IF #'NULL VARS)))
             (SETQ ENV
                     (AUGMENT-WALKER-ENVIRONMENT WALKER ENV :VARIABLE VARS
                                                 :DECLARE DECLS)))
           (WALK-VAR (VAR)
             (WALK-ATOMIC-FORM WALKER VAR ENV NIL))
           (UPDATE-STATE (KEYWORD)
             (SETQ STATE
                     (ECASE KEYWORD
                       ((NIL) STATE)
                       (&OPTIONAL :OPTVARS)
                       ((&REST &BODY) :RESTVAR)
                       (&KEY :KEYVARS)
                       (&AUX :AUXVARS)
                       (&ENVIRONMENT :ENVVAR))))
           (MAYBE-DESTRUCTURE (VAR/PATTERN)
             (IF (CONSP VAR/PATTERN)
                 (WALK-LAMBDA-LIST WALKER VAR/PATTERN DECLS ENV)
                 (VALUES (WALK-VAR VAR/PATTERN) (AUGMENT-ENV VAR/PATTERN)))))
    (LET ((WHOLEVAR
           (AND (CONSP LAMBDA-LIST) (EQL (CAR LAMBDA-LIST) '&WHOLE)
                (PUSH (POP LAMBDA-LIST) NEW-LAMBDA-LIST)
                (CAR (PUSH (WALK-VAR (POP LAMBDA-LIST)) NEW-LAMBDA-LIST))))
          (ENVVAR
           (DO ((LAMBDA-LIST LAMBDA-LIST (CDR LAMBDA-LIST)))
               ((ATOM LAMBDA-LIST) NIL)
             (WHEN (EQL (CAR LAMBDA-LIST) '&ENVIRONMENT)
               (RETURN (CADR LAMBDA-LIST))))))
      (AUGMENT-ENV WHOLEVAR ENVVAR))
    (DO* ((LAMBDA-LIST LAMBDA-LIST (CDR LAMBDA-LIST))
          (ARG (CAR LAMBDA-LIST) (CAR LAMBDA-LIST)))
         ((NULL LAMBDA-LIST) (VALUES (NREVERSE NEW-LAMBDA-LIST) ENV))
      (ECASE STATE
        (:ENVVAR
         (PUSH (WALK-VAR (POP LAMBDA-LIST)) NEW-LAMBDA-LIST)
         (UPDATE-STATE (CAR LAMBDA-LIST)))
        ((:REQVARS :RESTVAR)
         (ETYPECASE ARG
           (SYMBOL
            (COND
             ((MEMBER ARG LAMBDA-LIST-KEYWORDS) (PUSH ARG NEW-LAMBDA-LIST)
              (UPDATE-STATE ARG))
             (T (SETQ ARG (WALK-VAR ARG)) (AUGMENT-ENV ARG)
              (PUSH ARG NEW-LAMBDA-LIST))))
           (CONS
            (MULTIPLE-VALUE-BIND (PATTERN NEW-ENV)
                (WALK-LAMBDA-LIST WALKER ARG DECLS ENV)
              (SETQ ENV NEW-ENV)
              (PUSH PATTERN NEW-LAMBDA-LIST)))))
        (:OPTVARS
         (ETYPECASE ARG
           (SYMBOL
            (COND
             ((MEMBER ARG LAMBDA-LIST-KEYWORDS) (PUSH ARG NEW-LAMBDA-LIST)
              (UPDATE-STATE ARG))
             (T (SETQ ARG (WALK-VAR ARG)) (AUGMENT-ENV ARG)
              (PUSH ARG NEW-LAMBDA-LIST))))
           (CONS
            (DESTRUCTURING-BIND
                (VAR/PATTERN &OPTIONAL INIT-FORM SUPPLIED-P-PARAMETER)
                ARG
              (WHEN INIT-FORM
                (SETQ INIT-FORM (WALK-FORM WALKER INIT-FORM ENV)))
              (MULTIPLE-VALUE-SETQ (VAR/PATTERN ENV)
                (MAYBE-DESTRUCTURE VAR/PATTERN))
              (WHEN SUPPLIED-P-PARAMETER (AUGMENT-ENV SUPPLIED-P-PARAMETER))
              (PUSH
               (NCONC (LIST VAR/PATTERN) (AND INIT-FORM (LIST INIT-FORM))
                      (AND SUPPLIED-P-PARAMETER (LIST SUPPLIED-P-PARAMETER)))
               NEW-LAMBDA-LIST)))))
        (:KEYVARS
         (COND
          ((EQL ARG '&ALLOW-OTHER-KEYS)
           (PUSH (POP LAMBDA-LIST) NEW-LAMBDA-LIST)
           (UPDATE-STATE (CAR LAMBDA-LIST)))
          (T
           (ETYPECASE ARG
             (SYMBOL
              (COND
               ((MEMBER ARG LAMBDA-LIST-KEYWORDS) (PUSH ARG NEW-LAMBDA-LIST)
                (UPDATE-STATE ARG))
               (T (SETQ ARG (WALK-VAR ARG)) (AUGMENT-ENV ARG)
                (PUSH ARG NEW-LAMBDA-LIST))))
             (CONS
              (DESTRUCTURING-BIND
                  (VAR/KV &OPTIONAL INIT-FORM SUPPLIED-P-PARAMETER)
                  ARG
                (WHEN INIT-FORM
                  (SETQ INIT-FORM (WALK-FORM WALKER INIT-FORM ENV)))
                (IF (CONSP VAR/KV)
                    (DESTRUCTURING-BIND
                        (KEYWORD-NAME VAR/PATTERN)
                        VAR/KV
                      (MULTIPLE-VALUE-SETQ (VAR/PATTERN ENV)
                        (MAYBE-DESTRUCTURE VAR/PATTERN))
                      (SETQ VAR/KV (LIST (WALK-VAR KEYWORD-NAME) VAR/PATTERN)))
                    (AUGMENT-ENV VAR/KV))
                (WHEN SUPPLIED-P-PARAMETER
                  (SETQ SUPPLIED-P-PARAMETER (WALK-VAR SUPPLIED-P-PARAMETER))
                  (AUGMENT-ENV SUPPLIED-P-PARAMETER))
                (PUSH
                 (NCONC (LIST VAR/KV) (AND INIT-FORM (LIST INIT-FORM))
                        (AND SUPPLIED-P-PARAMETER (LIST SUPPLIED-P-PARAMETER)))
                 NEW-LAMBDA-LIST)))))))
        (:AUXVARS
         (ETYPECASE ARG
           (SYMBOL
            (COND
             ((MEMBER ARG LAMBDA-LIST-KEYWORDS) (PUSH ARG NEW-LAMBDA-LIST)
              (UPDATE-STATE ARG))
             (T (SETQ ARG (WALK-VAR ARG)) (AUGMENT-ENV ARG)
              (PUSH ARG NEW-LAMBDA-LIST))))
           (CONS
            (DESTRUCTURING-BIND
                (VAR &OPTIONAL INIT-FORM)
                ARG
              (SETQ VAR (WALK-VAR VAR)
                    INIT-FORM (AND INIT-FORM (WALK-FORM WALKER INIT-FORM ENV)))
              (AUGMENT-ENV VAR)
              (PUSH (NCONC (LIST VAR) (AND INIT-FORM (LIST INIT-FORM)))
                    NEW-LAMBDA-LIST))))))
      (WHEN (AND (CDR LAMBDA-LIST) (ATOM (CDR LAMBDA-LIST)))
        (LET ((VAR (WALK-VAR (CDR LAMBDA-LIST))))
          (AUGMENT-ENV VAR)
          (PUSH '&REST NEW-LAMBDA-LIST)
          (PUSH VAR NEW-LAMBDA-LIST))
        (SETQ LAMBDA-LIST NIL)))))
(DEFUN WALK-LAMBDA-EXPRESSION
       (WALKER FORM ENV
        &REST ARGS
        &AUX (LAMBDA-LIST (CADR FORM)) (BODY (CDDR FORM)))
  (MULTIPLE-VALUE-BIND (FORMS DECLS DOC)
      (PARSE-BODY BODY :WALKER WALKER :ENV ENV :DOC-STRING-ALLOWED T)
    (MULTIPLE-VALUE-BIND (LAMBDA-LIST ENV)
        (WALK-LAMBDA-LIST WALKER LAMBDA-LIST DECLS ENV)
      `(,(APPLY #'WALK-FUNCTION-NAME WALKER (CAR FORM) ENV ARGS) ,LAMBDA-LIST
        ,@(IF DOC
              `(,DOC))
        ,@(IF DECLS
              `((DECLARE ,@DECLS)))
        ,@(WALK-LIST WALKER FORMS ENV)))))
(DEFINE-SPECIAL-FORM-WALKER LAMBDA
    ((WALKER WALKER) FORM ENV)
  (WALK-LAMBDA-EXPRESSION WALKER FORM ENV))
(DEFUN WALK-VARIABLE-BINDING
       (WALKER P ENV
        &AUX
        (BINDING
         (IF (CONSP P)
             P
             (LIST P))))
  (LIST (WALK-ATOMIC-FORM WALKER (CAR BINDING) ENV NIL)
        (AND (CDR BINDING) (WALK-FORM WALKER (CADR BINDING) ENV))))
(DEFUN MAKE-MACRO-DEFINITIONS (WALKER DEFS ENV)
  (MAPCAR
   (LAMBDA (DEF &AUX (NAME (WALK-ATOMIC-FORM WALKER (CAR DEF) ENV NIL)))
     (LIST NAME
           (ENCLOSE (PARSE-MACRO NAME (CADR DEF) (CDDR DEF) ENV) ENV WALKER)))
   DEFS))
(DEFINE-SPECIAL-FORM-WALKER LET
    ((WALKER WALKER) FORM ENV &AUX
     (BINDINGS
      (MAPCAR (LAMBDA (P) (WALK-VARIABLE-BINDING WALKER P ENV)) (CADR FORM)))
     (BODY (CDDR FORM)))
  (MULTIPLE-VALUE-BIND (FORMS DECLS)
      (PARSE-BODY BODY :WALKER WALKER :ENV ENV)
    `(,(CAR FORM) ,BINDINGS
      ,@(IF DECLS
            `((DECLARE ,@DECLS)))
      ,@(WALK-LIST WALKER FORMS
                   (AUGMENT-WALKER-ENVIRONMENT WALKER ENV :VARIABLE
                                               (MAPCAR #'CAR BINDINGS) :DECLARE
                                               DECLS)))))
(DEFINE-SPECIAL-FORM-WALKER FLET
    ((WALKER WALKER) FORM ENV &AUX
     (BINDINGS
      (MAPCAR (LAMBDA (P) (WALK-LAMBDA-EXPRESSION WALKER P ENV :DEF 'FLET))
              (CADR FORM)))
     (BODY (CDDR FORM)))
  (MULTIPLE-VALUE-BIND (FORMS DECLS)
      (PARSE-BODY BODY :WALKER WALKER :ENV ENV)
    `(,(CAR FORM) ,BINDINGS
      ,@(IF DECLS
            `((DECLARE ,@DECLS)))
      ,@(WALK-LIST WALKER FORMS
                   (AUGMENT-WALKER-ENVIRONMENT WALKER ENV :FUNCTION
                                               (MAPCAR #'CAR BINDINGS) :DECLARE
                                               DECLS)))))
(DEFINE-SPECIAL-FORM-WALKER MACROLET
    ((WALKER WALKER) FORM ENV &AUX
     (BINDINGS
      (MAPCAR (LAMBDA (P) (WALK-LAMBDA-EXPRESSION WALKER P ENV :DEF 'MACROLET))
              (CADR FORM)))
     (BODY (CDDR FORM)) (MACROS (MAKE-MACRO-DEFINITIONS WALKER BINDINGS ENV)))
  (MULTIPLE-VALUE-BIND (FORMS DECLS)
      (PARSE-BODY BODY :WALKER WALKER :ENV ENV)
    `(,(CAR FORM) ,BINDINGS
      ,@(IF DECLS
            `((DECLARE ,@DECLS)))
      ,@(WALK-LIST WALKER FORMS
                   (AUGMENT-WALKER-ENVIRONMENT WALKER ENV :MACRO MACROS
                                               :DECLARE DECLS)))))
(DEFINE-SPECIAL-FORM-WALKER SYMBOL-MACROLET
    ((WALKER WALKER) FORM ENV &AUX
     (BINDINGS
      (MAPCAR (LAMBDA (P) (WALK-VARIABLE-BINDING WALKER P ENV)) (CADR FORM)))
     (BODY (CDDR FORM)))
  (MULTIPLE-VALUE-BIND (FORMS DECLS)
      (PARSE-BODY BODY :WALKER WALKER :ENV ENV)
    `(,(CAR FORM) ,BINDINGS
      ,@(IF DECLS
            `((DECLARE ,@DECLS)))
      ,@(WALK-LIST WALKER FORMS
                   (AUGMENT-WALKER-ENVIRONMENT WALKER ENV :SYMBOL-MACRO
                                               BINDINGS :DECLARE DECLS)))))
(DEFINE-SPECIAL-FORM-WALKER LET*
    ((WALKER WALKER) FORM ENV &AUX (BINDINGS (CADR FORM)) (BODY (CDDR FORM)))
  (MULTIPLE-VALUE-BIND (FORMS DECLS)
      (PARSE-BODY BODY :WALKER WALKER :ENV ENV)
    `(,(CAR FORM)
      ,(MAPCAR
        (LAMBDA (P)
          (LET ((WALKED-BINDING (WALK-VARIABLE-BINDING WALKER P ENV)))
            (SETQ ENV
                    (AUGMENT-WALKER-ENVIRONMENT WALKER ENV :VARIABLE
                                                (LIST (CAR WALKED-BINDING))
                                                :DECLARE DECLS))
            WALKED-BINDING))
        BINDINGS)
      ,@(IF DECLS
            `((DECLARE ,@DECLS)))
      ,@(WALK-LIST WALKER FORMS ENV))))
(DEFINE-SPECIAL-FORM-WALKER LABELS
    ((WALKER WALKER) FORM ENV &AUX (BINDINGS (CADR FORM)) (BODY (CDDR FORM)))
  (MULTIPLE-VALUE-BIND (FORMS DECLS)
      (PARSE-BODY BODY :WALKER WALKER :ENV ENV)
    (LET* ((FUNCTION-NAMES
            (MAPCAR
             (LAMBDA (P) (WALK-FUNCTION-NAME WALKER (CAR P) ENV :DEF 'LABELS))
             BINDINGS))
           (ENV
            (AUGMENT-WALKER-ENVIRONMENT WALKER ENV :FUNCTION FUNCTION-NAMES
                                        :DECLARE DECLS)))
      `(,(CAR FORM)
        ,(MAPCAR (LAMBDA (P) (WALK-LAMBDA-EXPRESSION WALKER P ENV)) BINDINGS)
        ,@(IF DECLS
              `((DECLARE ,@DECLS)))
        ,@(WALK-LIST WALKER FORMS ENV)))))
(DEFINE-SPECIAL-FORM-WALKER LOCALLY
    ((WALKER WALKER) FORM ENV)
  (MULTIPLE-VALUE-BIND (FORMS DECLS)
      (PARSE-BODY (CDR FORM) :WALKER WALKER :ENV ENV)
    `(,(CAR FORM)
      ,@(IF DECLS
            `((DECLARE ,@DECLS)))
      ,@(WALK-LIST WALKER FORMS
                   (AUGMENT-WALKER-ENVIRONMENT WALKER ENV :DECLARE DECLS)))))
(DEFUN ENTRY-HEADING-LESSP
       (H1 H2
        &AUX
        (H1
         (IF (LISTP H1)
             H1
             (LIST H1)))
        (H2
         (IF (LISTP H2)
             H2
             (LIST H2))))
  (OR (AND (NULL H1) H2) (STRING-LESSP (STRING (CAR H1)) (STRING (CAR H2)))
      (AND (STRING-EQUAL (STRING (CAR H1)) (STRING (CAR H2))) (CDR H2)
           (ENTRY-HEADING-LESSP (CDR H1) (CDR H2)))))
(DEFCLASS LOCATOR NIL NIL)
(DEFCLASS SECTION-LOCATOR (LOCATOR)
          ((SECTION :ACCESSOR LOCATION :INITARG :SECTION)
           (DEF :ACCESSOR LOCATOR-DEFINITION-P :INITARG :DEF)))
(DEFCLASS XREF-LOCATOR (LOCATOR)
          ((HEADING :ACCESSOR LOCATION :INITARG :HEADING)))
(DEFCLASS SEE-LOCATOR (XREF-LOCATOR) NIL)
(DEFCLASS SEE-ALSO-LOCATOR (XREF-LOCATOR) NIL)
(DEFUN MAKE-LOCATOR (&KEY SECTION DEF SEE SEE-ALSO)
  (ASSERT
   (IF (OR SEE SEE-ALSO)
       (AND (NOT SECTION) (NOT DEF))
       T)
   (SECTION DEF SEE SEE-ALSO)
   "Can't use :SECTION or :DEF with :SEE or :SEE-ALSO.")
  (ASSERT
   (IF DEF
       SECTION
       T)
   (SECTION DEF) "Can't use :DEF without :SECTION.")
  (ASSERT (NOT (AND SEE SEE-ALSO)) (SEE SEE-ALSO)
          "Can't use both :SEE and :SEE-ALSO.")
  (COND (SECTION (MAKE-INSTANCE 'SECTION-LOCATOR :SECTION SECTION :DEF DEF))
        (SEE (MAKE-INSTANCE 'SEE-LOCATOR :HEADING SEE))
        (SEE-ALSO (MAKE-INSTANCE 'SEE-LOCATOR :HEADING SEE-ALSO))))
(DEFCLASS INDEX-ENTRY (BINARY-SEARCH-TREE)
          ((KEY :ACCESSOR ENTRY-HEADING)
           (LOCATORS :ACCESSOR ENTRY-LOCATORS :INITARG :LOCATORS :INITFORM
            'NIL)))
(DEFMETHOD FIND-OR-INSERT
           (ITEM (ROOT INDEX-ENTRY) &KEY (PREDICATE #'ENTRY-HEADING-LESSP)
            (TEST #'EQUALP) (INSERT-IF-NOT-FOUND T))
           (CALL-NEXT-METHOD ITEM ROOT :PREDICATE PREDICATE :TEST TEST
            :INSERT-IF-NOT-FOUND INSERT-IF-NOT-FOUND))
(DEFCLASS INDEX NIL ((ENTRIES :ACCESSOR INDEX-ENTRIES :INITFORM NIL)))
(DEFUN MAKE-INDEX () (MAKE-INSTANCE 'INDEX))
(DEFGENERIC ADD-INDEX-ENTRY
    (INDEX HEADING LOCATOR &KEY))
(DEFGENERIC FIND-INDEX-ENTRIES
    (INDEX HEADING))
(DEFINE-MODIFY-MACRO ORF (&REST ARGS) OR)
(DEFMETHOD ADD-INDEX-ENTRY ((INDEX INDEX) HEADING (SECTION SECTION) &KEY DEF)
           (FLET ((MAKE-LOCATOR ()
                    (MAKE-LOCATOR :SECTION SECTION :DEF DEF)))
             (IF (NULL (INDEX-ENTRIES INDEX))
                 (SETF (INDEX-ENTRIES INDEX)
                         (MAKE-INSTANCE 'INDEX-ENTRY :KEY HEADING :LOCATORS
                                        (LIST (MAKE-LOCATOR))))
                 (LET* ((ENTRY (FIND-OR-INSERT HEADING (INDEX-ENTRIES INDEX)))
                        (OLD-LOCATOR
                         (FIND SECTION (ENTRY-LOCATORS ENTRY) :KEY #'LOCATION)))
                   (IF OLD-LOCATOR
                       (ORF (LOCATOR-DEFINITION-P OLD-LOCATOR) DEF)
                       (PUSH (MAKE-LOCATOR) (ENTRY-LOCATORS ENTRY)))))))
(DEFMETHOD FIND-INDEX-ENTRIES ((INDEX INDEX) HEADING)
           (LET ((ENTRIES (INDEX-ENTRIES INDEX)))
             (WHEN ENTRIES
               (MULTIPLE-VALUE-BIND (ENTRY PRESENT-P)
                   (FIND-OR-INSERT HEADING ENTRIES :INSERT-IF-NOT-FOUND NIL)
                 (WHEN PRESENT-P (ENTRY-LOCATORS ENTRY))))))
(DEFUN KEYWORD-FROM-DEF (SYMBOL)
  (OR (CDR (ASSOC SYMBOL *DEFINING-OPERATORS*))
      (VALUES
       (INTERN
        (LOOP WITH NAME = (SYMBOL-NAME SYMBOL)
              FOR PREFIX IN '("define-" "def") AS N = (MIN (LENGTH PREFIX)
                                                           (LENGTH NAME))
              IF (STRING-EQUAL (SUBSEQ NAME 0 N) PREFIX)
              DO (RETURN (SUBSEQ NAME N))
              FINALLY (WARN "Non-defining symbol ~S" SYMBOL) (RETURN NAME))
        (FIND-PACKAGE "KEYWORD")))))
(DEFUN INDEX-VARIABLE (INDEX VARIABLE SECTION ENV &OPTIONAL DEF)
  (MULTIPLE-VALUE-BIND (TYPE LOCAL)
      (VARIABLE-INFORMATION VARIABLE ENV)
    (WHEN (MEMBER TYPE '(:SPECIAL :SYMBOL-MACRO :CONSTANT))
      (ADD-INDEX-ENTRY INDEX
                       (LIST VARIABLE
                             (ECASE TYPE
                               (:SPECIAL ':SPECIAL-VARIABLE)
                               (:SYMBOL-MACRO
                                (IF LOCAL
                                    ':LOCAL-SYMBOL-MACRO
                                    ':SYMBOL-MACRO))
                               (:CONSTANT ':CONSTANT)))
                       SECTION :DEF DEF))))
(DEFUN INDEX-FUNCTION (INDEX FUNCTION SECTION ENV &OPTIONAL DEF)
  (MULTIPLE-VALUE-BIND (TYPE LOCAL)
      (FUNCTION-INFORMATION FUNCTION ENV)
    (WHEN (MEMBER TYPE '(:FUNCTION :MACRO))
      (ADD-INDEX-ENTRY INDEX
                       (LIST FUNCTION
                             (ECASE TYPE
                               (:FUNCTION
                                (IF LOCAL
                                    ':LOCAL-FUNCTION
                                    ':FUNCTION))
                               (:MACRO
                                (IF LOCAL
                                    ':LOCAL-MACRO
                                    ':MACRO))))
                       SECTION :DEF DEF))))
(DEFUN SUBSTITUTE-SYMBOLS (FORM SECTION &AUX SYMBOLS)
  (LABELS ((GET-SYMBOLS (FORM)
             (COND
              ((AND (SYMBOLP FORM)
                    (MEMBER (SYMBOL-PACKAGE FORM) *INDEX-PACKAGES*))
               (PUSHNEW FORM SYMBOLS))
              ((ATOM FORM) NIL)
              (T (GET-SYMBOLS (CAR FORM)) (GET-SYMBOLS (CDR FORM))))))
    (GET-SYMBOLS FORM)
    (SUBLIS
     (MAP 'LIST
          (LAMBDA (SYM)
            (LET ((REFSYM (MAKE-SYMBOL (SYMBOL-NAME SYM))))
              (SETF (SYMBOL-VALUE REFSYM) SYM)
              (SETF (GET REFSYM 'SECTION) SECTION)
              (CONS SYM REFSYM)))
          SYMBOLS)
     FORM)))
(DEFUN SYMBOL-PROVENANCE (SYMBOL)
  (LET ((SECTION (GET SYMBOL 'SECTION)))
    (IF (AND (NULL (SYMBOL-PACKAGE SYMBOL)) (BOUNDP SYMBOL) SECTION)
        (VALUES (SYMBOL-VALUE SYMBOL) SECTION)
        SYMBOL)))
(DEFMETHOD SECTION-CODE :AROUND ((SECTION SECTION))
           (LET ((CODE (CALL-NEXT-METHOD)))
             (IF *INDEXING*
                 (SUBSTITUTE-SYMBOLS (TANGLE CODE :EXPAND-NAMED-SECTIONS NIL)
                                     SECTION)
                 CODE)))
(DEFUN TANGLE-CODE-FOR-INDEXING (SECTIONS)
  (LET ((*INDEXING* T))
    (TANGLE (UNNAMED-SECTION-CODE-PARTS SECTIONS))))
(DEFCLASS INDEXING-WALKER (WALKER)
          ((INDEX :ACCESSOR WALKER-INDEX :INITFORM (MAKE-INDEX))))
(DEFMETHOD WALK-ATOMIC-FORM
           ((WALKER INDEXING-WALKER) FORM ENV &OPTIONAL (EVALP T))
           (IF (SYMBOLP FORM)
               (MULTIPLE-VALUE-BIND (SYMBOL SECTION)
                   (SYMBOL-PROVENANCE FORM)
                 (WHEN (AND SECTION EVALP)
                   (INDEX-VARIABLE (WALKER-INDEX WALKER) SYMBOL SECTION ENV))
                 SYMBOL)
               FORM))
(DEFMETHOD WALK-COMPOUND-FORM :BEFORE ((WALKER INDEXING-WALKER) CAR FORM ENV)
           (DECLARE (IGNORE FORM))
           (MULTIPLE-VALUE-BIND (SYMBOL SECTION)
               (SYMBOL-PROVENANCE CAR)
             (WHEN SECTION
               (INDEX-FUNCTION (WALKER-INDEX WALKER) SYMBOL SECTION ENV))))
(DEFINE-SPECIAL-FORM-WALKER DEFUN
    ((WALKER INDEXING-WALKER) FORM ENV)
  `(,(CAR FORM)
    ,@(WALK-LAMBDA-EXPRESSION WALKER (CDR FORM) ENV :DEF (CAR FORM))))
(DEFINE-SPECIAL-FORM-WALKER DEFMACRO
    ((WALKER INDEXING-WALKER) FORM ENV)
  `(,(CAR FORM)
    ,@(WALK-LAMBDA-EXPRESSION WALKER (CDR FORM) ENV :DEF (CAR FORM))))
(DEFMETHOD WALK-FUNCTION-NAME :BEFORE
           ((WALKER INDEXING-WALKER) FUNCTION-NAME ENV &KEY DEF)
           (DECLARE (IGNORE ENV))
           (WHEN DEF
             (LET ((KIND (KEYWORD-FROM-DEF DEF)) (INDEX (WALKER-INDEX WALKER)))
               (TYPECASE FUNCTION-NAME
                 (SYMBOL
                  (MULTIPLE-VALUE-BIND (SYMBOL SECTION)
                      (SYMBOL-PROVENANCE FUNCTION-NAME)
                    (WHEN SECTION
                      (ADD-INDEX-ENTRY INDEX (LIST SYMBOL KIND) SECTION :DEF
                                       T))))
                 ((CONS (EQL SETF) (CONS SYMBOL NULL))
                  (MULTIPLE-VALUE-BIND (SYMBOL SECTION)
                      (SYMBOL-PROVENANCE (CADR FUNCTION-NAME))
                    (WHEN SECTION
                      (ADD-INDEX-ENTRY INDEX
                                       (LIST (FORMAT NIL "(SETF ~A)" SYMBOL)
                                             KIND)
                                       SECTION :DEF T))))))))
(MACROLET ((DEFINE-INDEXING-DEFVAR-WALKER (OPERATOR)
             `(DEFINE-SPECIAL-FORM-WALKER ,OPERATOR
                  ((WALKER INDEXING-WALKER) FORM ENV)
                ,'`(,(CAR FORM)
                    ,(MULTIPLE-VALUE-BIND (SYMBOL SECTION)
                         (SYMBOL-PROVENANCE (CADR FORM))
                       (WHEN SECTION
                         (INDEX-VARIABLE (WALKER-INDEX WALKER) SYMBOL SECTION
                                         ENV T))
                       SYMBOL)
                    ,@(WALK-LIST WALKER (CDDR FORM) ENV)))))
  (DEFINE-INDEXING-DEFVAR-WALKER DEFVAR)
  (DEFINE-INDEXING-DEFVAR-WALKER DEFPARAMETER)
  (DEFINE-INDEXING-DEFVAR-WALKER DEFCONSTANT))
(DEFMETHOD WALK-DECLARATION-SPECIFIERS ((WALKER INDEXING-WALKER) DECLS ENV)
           (LOOP FOR (IDENTIFIER . DATA) IN DECLS
                 IF (EQL IDENTIFIER 'SPECIAL)
                 COLLECT `(SPECIAL ,@(WALK-LIST WALKER DATA ENV))))
(DEFUN INDEX-SECTIONS (SECTIONS &KEY (WALKER (MAKE-INSTANCE 'INDEXING-WALKER)))
  (DOLIST (FORM (TANGLE-CODE-FOR-INDEXING SECTIONS) (WALKER-INDEX WALKER))
    (WALK-FORM WALKER FORM)))