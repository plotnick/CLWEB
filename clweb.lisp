;;;; TANGLED WEB FROM "clweb.clw". DO NOT EDIT.
#+ALLEGRO
(EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL)
  (SETQ EXCL:*SOURCE-PATHNAME* "clweb.clw"))

(EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)
  #+:SBCL (require "SB-CLTL2"))
(DEFPACKAGE "CLWEB"
  (:DOCUMENTATION "A literate programming system for Common Lisp.")
  (:USE "COMMON-LISP")
  (:EXPORT "TANGLE-FILE"
           "LOAD-WEB"
           "WEAVE"
           "LOAD-SECTIONS-FROM-TEMP-FILE"
           "INPUT-FILE-PATHNAME"
           "LISP-FILE-PATHNAME"
           "TEX-FILE-PATHNAME"
           "INDEX-FILE-PATHNAME"
           "SECTIONS-FILE-PATHNAME"
           "FASL-FILE-PATHNAME"
           "TESTS-FILE-PATHNAME"
           "TANGLE-FILE-PATHNAMES"
           "WEAVE-PATHNAMES"
           "*WEB-PATHNAME-DEFAULTS*"
           "*LISP-PATHNAME-DEFAULTS*"
           "*TEX-PATHNAME-DEFAULTS*"
           "*INDEX-PATHNAME-DEFAULTS*"
           "*SECTIONS-PATHNAME-DEFAULTS*"
           "*TESTS-FILE-PATHNAME-FUNCTION*"
           "*COMPILE-TESTS-FILE*"
           "*TANGLE-FILE-PATHNAME*"
           "*TANGLE-FILE-TRUENAME*"
           "*WEAVE-PRINT*"
           "*WEAVE-VERBOSE*"
           "*INDEX-LEXICAL-VARIABLES*"
           "AMBIGUOUS-PREFIX-ERROR"
           "SECTION-NAME-CONTEXT-ERROR"
           "SECTION-NAME-USE-ERROR"
           "SECTION-NAME-DEFINITION-ERROR"
           "UNUSED-NAMED-SECTION-WARNING"
           "CLWEB-FILE"
           "WEAVE-OP")
  #+(:OR :SBCL :CCL :ALLEGRO)
  (:import-from #+sbcl "SB-CLTL2" #+ccl "CCL" #+allegro "SYS"
                #-allegro "FUNCTION-INFORMATION"
                #-allegro "VARIABLE-INFORMATION"
                #-allegro "PARSE-MACRO"
                "AUGMENT-ENVIRONMENT")
  #+:SBCL
  (:import-from "SB-INT" "NAMED-LAMBDA"))
(IN-PACKAGE "CLWEB")
(DEFVAR *WEB-PATHNAME-DEFAULTS* (MAKE-PATHNAME :TYPE "clw" :VERSION :NEWEST))
(DEFVAR *LISP-PATHNAME-DEFAULTS* (MAKE-PATHNAME :TYPE "lisp" :VERSION :NEWEST))
(DEFVAR *TEX-PATHNAME-DEFAULTS* (MAKE-PATHNAME :TYPE "tex" :VERSION :NEWEST))
(DEFVAR *INDEX-PATHNAME-DEFAULTS* (MAKE-PATHNAME :TYPE "idx" :VERSION :NEWEST))
(DEFVAR *SECTIONS-PATHNAME-DEFAULTS*
  (MAKE-PATHNAME :TYPE "scn" :VERSION :NEWEST))
(DEFVAR *TESTS-FILE-PATHNAME-FUNCTION*
  (LAMBDA
      (INPUT-FILE OUTPUT-FILE
       &AUX (OUTPUT-FILE (PATHNAME OUTPUT-FILE))
       (TESTS-FILE
        (MAKE-PATHNAME :NAME
                       (CONCATENATE 'STRING (PATHNAME-NAME OUTPUT-FILE)
                                    "-tests")
                       :VERSION :NEWEST :DEFAULTS OUTPUT-FILE)))
    (OUTPUT-FILE-PATHNAME INPUT-FILE :OUTPUT-FILE TESTS-FILE :DEFAULTS
                          OUTPUT-FILE)))
(DEFVAR *SECTIONS* (MAKE-ARRAY 128 :ADJUSTABLE T :FILL-POINTER 0))
(DEFVAR *CURRENT-SECTION* NIL)
(DEFVAR *TEST-SECTIONS* (MAKE-ARRAY 128 :ADJUSTABLE T :FILL-POINTER 0))
(DEFVAR *NAMED-SECTIONS* NIL)
(DEFPARAMETER *WHITESPACE*
  #.(COERCE
     (REMOVE-DUPLICATES
      (REMOVE NIL
              (MAPCAR #'NAME-CHAR
                      '("Newline" "Space" "Tab" "Linefeed" "Return" "Page"))))
     'STRING))
(EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)
  (DEFPARAMETER *MODES* '(:LIMBO :TEX :LISP :INNER-LISP :RESTRICTED)))
(DEFTYPE MODE () `(MEMBER ,@*MODES*))
(DEFVAR *READTABLES*
  (LOOP FOR MODE IN (CONS 'NIL *MODES*)
        COLLECT (CONS MODE (COPY-READTABLE NIL))))
(DEFVAR *EOF* (MAKE-SYMBOL "EOF"))
(DEFPARAMETER *TAB-WIDTH* 8)
(DEFVAR *CHARPOS-STREAMS* (MAKE-HASH-TABLE :TEST #'EQ))
(DEFVAR *EVALUATING* NIL)
(DEFVAR *COMPILE-TESTS-FILE*
  T
  "The default value for the :COMPILE-TESTS-FILE argument to TANGLE-FILE.")
(DEFVAR *TANGLE-FILE-PATHNAME* NIL)
(DEFVAR *TANGLE-FILE-TRUENAME* NIL)
(DEFPARAMETER *TANGLE-PPRINT-DISPATCH* (COPY-PPRINT-DISPATCH NIL))
(DEFVAR *WEAVE-VERBOSE* T "The default for the :VERBOSE argument to WEAVE.")
(DEFVAR *WEAVE-PRINT* T "The default for the :PRINT argument to WEAVE.")
(DEFVAR *WEAVE-SOURCE-LOCATIONS*
  T
  "If true, include src: specials in the woven TeX.")
(DEFPARAMETER *WEAVE-PPRINT-DISPATCH* (COPY-PPRINT-DISPATCH NIL))
(DEFVAR *PRINT-SYMBOL-SUFFIXES*
  '(("/=" . "$\\neq$") ("<=" . "$\\leq$") (">=" . "$\\geq$") ("+-" . "$\\pm$")
    ("+" . "$+$") ("-" . "$-$") ("=" . "$=$") ("'" . "$'$")))
(DEFVAR *INDEX-PACKAGES*
  NIL
  "The list of packages whose symbols should be indexed.")
(DEFVAR *INDEX* NIL)
(DEFVAR *INDEX-LEXICAL-VARIABLES*
  NIL
  "If this flag is non-nil, the indexer will index lexical variables.")
(DEFVAR *REFERRING-CLASSES* 'NIL)
(DEFVAR *INDEXING* NIL)
(DEFINE-CONDITION UNDEFINED-NAMED-SECTION-ERROR
    (SIMPLE-ERROR)
    NIL)
(DEFINE-CONDITION AMBIGUOUS-PREFIX-ERROR
    (ERROR)
    ((PREFIX :READER AMBIGUOUS-PREFIX :INITARG :PREFIX)
     (FIRST-MATCH :READER AMBIGUOUS-PREFIX-FIRST-MATCH :INITARG :FIRST-MATCH)
     (ALT-MATCH :READER AMBIGUOUS-PREFIX-ALT-MATCH :INITARG :ALT-MATCH))
  (:REPORT
   (LAMBDA (CONDITION STREAM)
     (FORMAT STREAM "~@<Ambiguous prefix: <~A> matches both <~A> and <~A>~:@>"
             (AMBIGUOUS-PREFIX CONDITION)
             (AMBIGUOUS-PREFIX-FIRST-MATCH CONDITION)
             (AMBIGUOUS-PREFIX-ALT-MATCH CONDITION)))))
(DEFINE-CONDITION SIMPLE-READER-ERROR
    (READER-ERROR SIMPLE-CONDITION)
    NIL
  (:REPORT
   (LAMBDA (CONDITION STREAM)
     (FORMAT STREAM "~S on ~S:~%~?" CONDITION (STREAM-ERROR-STREAM CONDITION)
             (SIMPLE-CONDITION-FORMAT-CONTROL CONDITION)
             (SIMPLE-CONDITION-FORMAT-ARGUMENTS CONDITION)))))
(DEFINE-CONDITION SECTION-NAME-CONTEXT-ERROR
    (ERROR)
    ((NAME :READER SECTION-NAME :INITARG :NAME)))
(DEFINE-CONDITION SECTION-NAME-DEFINITION-ERROR
    (SECTION-NAME-CONTEXT-ERROR)
    NIL
  (:REPORT
   (LAMBDA (CONDITION STREAM)
     (FORMAT STREAM "Can't define a named section in Lisp mode: ~A"
             (SECTION-NAME CONDITION)))))
(DEFINE-CONDITION SECTION-NAME-USE-ERROR
    (SECTION-NAME-CONTEXT-ERROR)
    NIL
  (:REPORT
   (LAMBDA (CONDITION STREAM)
     (FORMAT STREAM "Can't use a section name in TeX mode: ~A"
             (SECTION-NAME CONDITION)))))
(DEFINE-CONDITION SECTION-LACKS-COMMENTARY
    (PARSE-ERROR)
    ((STREAM :INITARG :STREAM :READER SECTION-LACKS-COMMENTARY-STREAM))
  (:REPORT
   (LAMBDA (ERROR STREAM)
     (LET* ((INPUT-STREAM
             (DO ((STREAM (SECTION-LACKS-COMMENTARY-STREAM ERROR)))
                 (NIL)
               (TYPECASE STREAM
                 (ECHO-STREAM (SETQ STREAM (ECHO-STREAM-INPUT-STREAM STREAM)))
                 (T (RETURN STREAM)))))
            (POSITION (FILE-POSITION INPUT-STREAM))
            (PATHNAME
             (WHEN (TYPEP INPUT-STREAM 'FILE-STREAM) (PATHNAME INPUT-STREAM))))
       (FORMAT STREAM "~@<Can't start a section with a code part ~
~:[~;~:*at position ~D in file ~A.~]~:@>"
               POSITION (OR PATHNAME INPUT-STREAM))))))
(DEFINE-CONDITION UNUSED-NAMED-SECTION-WARNING
    (SIMPLE-WARNING)
    NIL)
(DEFUN ENSURE-LIST (OBJECT)
  (IF (LISTP OBJECT)
      OBJECT
      (LIST OBJECT)))
(DEFUN MAPTREE (FN X)
  (IF (ATOM X)
      (FUNCALL FN X)
      (LET ((A (FUNCALL FN (CAR X))) (D (MAPTREE FN (CDR X))))
        (IF (AND (EQL A (CAR X)) (EQL D (CDR X)))
            X
            (CONS A D)))))
(DEFUN MAPAPPEND (FN &REST ARGS)
  (IF (SOME #'NULL ARGS)
      NIL
      (APPEND (APPLY FN (MAPCAR #'CAR ARGS))
              (APPLY #'MAPAPPEND FN (MAPCAR #'CDR ARGS)))))
(DEFMACRO MAYBE-PUSH (OBJ PLACE &AUX (TEMP (GENSYM)))
  `(LET ((,TEMP ,OBJ))
     (WHEN
         (IF (STRINGP ,TEMP)
             (PLUSP (LENGTH ,TEMP))
             ,TEMP)
       (PUSH ,TEMP ,PLACE))))
(EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)
  (DEFMACRO WITH-UNIQUE-NAMES (SYMBOLS &BODY BODY)
    `(LET ,(LOOP FOR SYMBOL IN SYMBOLS
                 COLLECT `(,SYMBOL (COPY-SYMBOL ',SYMBOL)))
       ,@BODY)))
(DEFUN OUTPUT-FILE-PATHNAME
       (INPUT-FILE &KEY OUTPUT-FILE (DEFAULTS *DEFAULT-PATHNAME-DEFAULTS*))
  (ASSERT
   (OR (AND OUTPUT-FILE (PATHNAME-TYPE OUTPUT-FILE)) (PATHNAME-TYPE DEFAULTS))
   (DEFAULTS) "Missing default output file type.")
  (LET* ((INPUT-FILE (MERGE-PATHNAMES INPUT-FILE *DEFAULT-PATHNAME-DEFAULTS*))
         (DEFAULTS
          (MERGE-PATHNAMES (MAKE-PATHNAME :TYPE NIL :DEFAULTS INPUT-FILE)
                           DEFAULTS)))
    (IF OUTPUT-FILE
        (MERGE-PATHNAMES OUTPUT-FILE DEFAULTS)
        DEFAULTS)))
(MACROLET ((DEFDEFAULTS (NAME (INPUT) DEFAULTS)
             (WITH-UNIQUE-NAMES (ARGS)
               `(DEFUN ,NAME (,INPUT &REST ,ARGS)
                  (APPLY #'OUTPUT-FILE-PATHNAME ,INPUT :DEFAULTS ,DEFAULTS
                         ,ARGS)))))
  (DEFDEFAULTS INPUT-FILE-PATHNAME (INPUT-FILE) *WEB-PATHNAME-DEFAULTS*)
  (DEFDEFAULTS LISP-FILE-PATHNAME (INPUT-FILE) *LISP-PATHNAME-DEFAULTS*)
  (DEFDEFAULTS TEX-FILE-PATHNAME (INPUT-FILE) *TEX-PATHNAME-DEFAULTS*)
  (DEFDEFAULTS INDEX-FILE-PATHNAME (OUTPUT-FILE) *INDEX-PATHNAME-DEFAULTS*)
  (DEFDEFAULTS SECTIONS-FILE-PATHNAME (INDEX-FILE)
   *SECTIONS-PATHNAME-DEFAULTS*))
(DEFUN FASL-FILE-PATHNAME (INPUT-FILE &REST ARGS)
  (APPLY #'COMPILE-FILE-PATHNAME (LISP-FILE-PATHNAME INPUT-FILE)
         :ALLOW-OTHER-KEYS T ARGS))
(DEFUN TESTS-FILE-PATHNAME
       (INPUT-FILE
        &KEY OUTPUT-FILE (TESTS-FILE NIL TESTS-FILE-SUPPLIED)
        &ALLOW-OTHER-KEYS)
  (IF TESTS-FILE
      (OUTPUT-FILE-PATHNAME INPUT-FILE :OUTPUT-FILE TESTS-FILE :DEFAULTS
                            OUTPUT-FILE)
      (UNLESS TESTS-FILE-SUPPLIED
        (FUNCALL *TESTS-FILE-PATHNAME-FUNCTION* INPUT-FILE OUTPUT-FILE))))
(DEFUN TANGLE-FILE-PATHNAMES
       (INPUT-FILE &REST ARGS &KEY OUTPUT-FILE TESTS-FILE &ALLOW-OTHER-KEYS)
  "Compute and return the defaulted names of the tangler output files."
  (DECLARE (IGNORABLE OUTPUT-FILE TESTS-FILE))
  (LET* ((INPUT-FILE (INPUT-FILE-PATHNAME INPUT-FILE))
         (OUTPUT-FILE (APPLY #'FASL-FILE-PATHNAME INPUT-FILE ARGS))
         (LISP-FILE (LISP-FILE-PATHNAME OUTPUT-FILE))
         (TESTS-FILE
          (APPLY #'TESTS-FILE-PATHNAME INPUT-FILE :OUTPUT-FILE LISP-FILE ARGS))
         (TESTS-OUTPUT-FILE (AND TESTS-FILE (FASL-FILE-PATHNAME TESTS-FILE))))
    (VALUES OUTPUT-FILE LISP-FILE TESTS-OUTPUT-FILE TESTS-FILE)))
(DEFUN WEAVE-PATHNAMES
       (INPUT-FILE
        &KEY OUTPUT-FILE (INDEX-FILE NIL INDEX-FILE-SUPPLIED)
        &ALLOW-OTHER-KEYS)
  "Compute and return the defaulted names of the weaver output files."
  (LET* ((INPUT-FILE (INPUT-FILE-PATHNAME INPUT-FILE))
         (OUTPUT-FILE (TEX-FILE-PATHNAME INPUT-FILE :OUTPUT-FILE OUTPUT-FILE))
         (INDEX-FILE
          (UNLESS (AND INDEX-FILE-SUPPLIED (NOT INDEX-FILE))
            (INDEX-FILE-PATHNAME OUTPUT-FILE :OUTPUT-FILE INDEX-FILE)))
         (SECTIONS-FILE (AND INDEX-FILE (SECTIONS-FILE-PATHNAME INDEX-FILE))))
    (VALUES OUTPUT-FILE INDEX-FILE SECTIONS-FILE)))
(DEFCLASS SECTION NIL
          ((NAME :ACCESSOR SECTION-NAME :INITARG :NAME)
           (NUMBER :ACCESSOR SECTION-NUMBER)
           (COMMENTARY :ACCESSOR SECTION-COMMENTARY :INITARG :COMMENTARY)
           (CODE :ACCESSOR SECTION-CODE :INITARG :CODE)
           (SOURCE-LOCATION :READER SECTION-SOURCE-LOCATION :INITARG
            :SOURCE-LOCATION))
          (:DEFAULT-INITARGS :NAME NIL :COMMENTARY NIL :CODE NIL
           :SOURCE-LOCATION NIL))
(DEFCLASS STARRED-SECTION (SECTION)
          ((DEPTH :READER SECTION-DEPTH :INITARG :DEPTH))
          (:DEFAULT-INITARGS :DEPTH 0))
(DEFUN STARRED-SECTION-P (OBJECT) (TYPEP OBJECT 'STARRED-SECTION))
(DEFMETHOD SECTION-DEPTH ((SECTION SECTION)) NIL)
(DEFCLASS TEST-SECTION (SECTION)
          ((TEST-FOR :ACCESSOR TEST-FOR-SECTION :INITFORM NIL)))
(DEFCLASS STARRED-TEST-SECTION (TEST-SECTION STARRED-SECTION) NIL)
(DEFUN TEST-SECTION-P (OBJECT) (TYPEP OBJECT 'TEST-SECTION))
(DEFMETHOD INITIALIZE-INSTANCE :AFTER ((SECTION TEST-SECTION) &KEY)
  (WHEN (> (FILL-POINTER *SECTIONS*) 0)
    (SETF (TEST-FOR-SECTION SECTION)
            (ELT *SECTIONS* (1- (FILL-POINTER *SECTIONS*))))))
(DEFCLASS LIMBO-SECTION (SECTION) NIL)
(DEFGENERIC PUSH-SECTION
    (SECTION))
(DEFMETHOD PUSH-SECTION ((SECTION SECTION))
  (SETF (SECTION-NUMBER SECTION) (VECTOR-PUSH-EXTEND SECTION *SECTIONS*))
  SECTION)
(DEFMETHOD INITIALIZE-INSTANCE :AFTER ((SECTION SECTION) &KEY)
  (SETQ *CURRENT-SECTION* (PUSH-SECTION SECTION)))
(DEFMETHOD PUSH-SECTION ((SECTION TEST-SECTION))
  (LET ((*SECTIONS* *TEST-SECTIONS*))
    (CALL-NEXT-METHOD)))
(DEFMETHOD PUSH-SECTION :AFTER ((SECTION LIMBO-SECTION))
  (VECTOR-PUSH-EXTEND SECTION *TEST-SECTIONS*))
(DEFCLASS BINARY-SEARCH-TREE NIL
          ((KEY :ACCESSOR NODE-KEY :INITARG :KEY)
           (LEFT-CHILD :ACCESSOR LEFT-CHILD :INITARG :LEFT)
           (RIGHT-CHILD :ACCESSOR RIGHT-CHILD :INITARG :RIGHT))
          (:DEFAULT-INITARGS :LEFT NIL :RIGHT NIL))
(DEFGENERIC FIND-OR-INSERT
    (ITEM ROOT &KEY PREDICATE TEST INSERT-IF-NOT-FOUND))
(DEFMETHOD FIND-OR-INSERT
           (ITEM (ROOT BINARY-SEARCH-TREE)
            &KEY (PREDICATE #'<) (TEST #'EQL) (INSERT-IF-NOT-FOUND T))
  (FLET ((LESSP (ITEM NODE)
           (FUNCALL PREDICATE ITEM (NODE-KEY NODE)))
         (SAMEP (ITEM NODE)
           (FUNCALL TEST ITEM (NODE-KEY NODE))))
    (DO ((PARENT NIL NODE)
         (NODE ROOT
               (IF (LESSP ITEM NODE)
                   (LEFT-CHILD NODE)
                   (RIGHT-CHILD NODE))))
        ((OR (NULL NODE) (SAMEP ITEM NODE))
         (IF NODE
             (VALUES NODE T)
             (IF INSERT-IF-NOT-FOUND
                 (LET ((NODE (MAKE-INSTANCE (CLASS-OF ROOT) :KEY ITEM)))
                   (WHEN PARENT
                     (IF (LESSP ITEM PARENT)
                         (SETF (LEFT-CHILD PARENT) NODE)
                         (SETF (RIGHT-CHILD PARENT) NODE)))
                   (VALUES NODE NIL))
                 (VALUES NIL NIL)))))))
(DEFGENERIC MAP-BST
    #'TREE)
(DEFMETHOD MAP-BST (FUNCTION (TREE NULL)) (DECLARE (IGNORE FUNCTION)))
(DEFMETHOD MAP-BST (FUNCTION (TREE BINARY-SEARCH-TREE))
  (MAP-BST FUNCTION (LEFT-CHILD TREE))
  (FUNCALL FUNCTION TREE)
  (MAP-BST FUNCTION (RIGHT-CHILD TREE)))
(DEFCLASS NAMED-SECTION (BINARY-SEARCH-TREE)
          ((KEY :ACCESSOR SECTION-NAME :INITARG :NAME)
           (SECTIONS :ACCESSOR NAMED-SECTION-SECTIONS :INITFORM 'NIL)
           (USED-BY :ACCESSOR USED-BY :INITFORM 'NIL)
           (CITED-BY :ACCESSOR CITED-BY :INITFORM 'NIL)))
(DEFMETHOD NAMED-SECTION-SECTIONS :AROUND ((SECTION NAMED-SECTION))
  (SORT (COPY-LIST (CALL-NEXT-METHOD)) #'< :KEY #'SECTION-NUMBER))
(DEFMETHOD SECTION-CODE ((SECTION NAMED-SECTION))
  (MAPAPPEND #'SECTION-CODE (NAMED-SECTION-SECTIONS SECTION)))
(DEFMETHOD SECTION-NUMBER ((SECTION NAMED-SECTION))
  (LET ((SECTIONS (NAMED-SECTION-SECTIONS SECTION)))
    (WHEN (NULL SECTIONS)
      (ERROR 'UNDEFINED-NAMED-SECTION-ERROR :FORMAT-CONTROL
             "Undefined named section <~A>." :FORMAT-ARGUMENTS
             (LIST (SECTION-NAME SECTION))))
    (SECTION-NUMBER (FIRST SECTIONS))))
(DEFUN SECTION-NAME-PREFIX-P (NAME)
  (LET ((LEN (LENGTH NAME)))
    (IF (STRING= NAME "..." :START1 (MAX (- LEN 3) 0) :END1 LEN)
        (VALUES T (- LEN 3))
        (VALUES NIL LEN))))
(DEFUN SECTION-NAME-LESSP (NAME1 NAME2)
  (LET ((LEN1 (NTH-VALUE 1 (SECTION-NAME-PREFIX-P NAME1)))
        (LEN2 (NTH-VALUE 1 (SECTION-NAME-PREFIX-P NAME2))))
    (STRING-LESSP NAME1 NAME2 :END1 LEN1 :END2 LEN2)))
(DEFUN SECTION-NAME-EQUAL (NAME1 NAME2)
  (MULTIPLE-VALUE-BIND (PREFIX-1-P LEN1)
      (SECTION-NAME-PREFIX-P NAME1)
    (MULTIPLE-VALUE-BIND (PREFIX-2-P LEN2)
        (SECTION-NAME-PREFIX-P NAME2)
      (LET ((END (MIN LEN1 LEN2)))
        (IF (OR PREFIX-1-P PREFIX-2-P)
            (STRING-EQUAL NAME1 NAME2 :END1 END :END2 END)
            (STRING-EQUAL NAME1 NAME2))))))
(DEFMETHOD FIND-OR-INSERT
           (ITEM (ROOT NAMED-SECTION)
            &KEY (PREDICATE #'SECTION-NAME-LESSP) (TEST #'SECTION-NAME-EQUAL)
            (INSERT-IF-NOT-FOUND T))
  (MULTIPLE-VALUE-BIND (NODE PRESENT-P)
      (CALL-NEXT-METHOD ITEM ROOT :PREDICATE PREDICATE :TEST TEST
       :INSERT-IF-NOT-FOUND INSERT-IF-NOT-FOUND)
    (IF PRESENT-P
        (OR
         (DOLIST (CHILD (LIST (LEFT-CHILD NODE) (RIGHT-CHILD NODE)))
           (WHEN CHILD
             (MULTIPLE-VALUE-BIND (ALT PRESENT-P)
                 (CALL-NEXT-METHOD ITEM CHILD :PREDICATE PREDICATE :TEST TEST
                  :INSERT-IF-NOT-FOUND NIL)
               (WHEN PRESENT-P
                 (RESTART-CASE (ERROR 'AMBIGUOUS-PREFIX-ERROR :PREFIX ITEM
                                      :FIRST-MATCH (NODE-KEY NODE) :ALT-MATCH
                                      (NODE-KEY ALT))
                   (USE-FIRST-MATCH NIL :REPORT "Use the first match."
                    (RETURN (VALUES NODE T)))
                   (USE-ALT-MATCH NIL :REPORT "Use alternate match."
                    (RETURN (VALUES ALT T))))))))
         (VALUES NODE T))
        (VALUES NODE NIL))))
(DEFUN SQUEEZE (STRING)
  (WITH-INPUT-FROM-STRING (*STANDARD-INPUT* STRING)
    (WITH-OUTPUT-TO-STRING (*STANDARD-OUTPUT*)
      (HANDLER-CASE
       (FLET ((SNARF-WHITESPACE ()
                (LOOP FOR CHAR = (READ-CHAR)
                      WHILE (WHITESPACEP CHAR)
                      FINALLY (UNREAD-CHAR CHAR))))
         (LOOP INITIALLY (SNARF-WHITESPACE)
               FOR CHAR = (READ-CHAR)
               DO (WRITE-CHAR
                   (IF (WHITESPACEP CHAR)
                       (PROGN (SNARF-WHITESPACE) #\ )
                       CHAR))))
       (END-OF-FILE NIL)))))
(DEFUN WHITESPACEP (CHAR) (FIND CHAR *WHITESPACE* :TEST #'CHAR=))
(DEFUN FIND-SECTION (NAME &AUX (NAME (SQUEEZE NAME)))
  (IF (NULL *NAMED-SECTIONS*)
      (SETQ *NAMED-SECTIONS* (MAKE-INSTANCE 'NAMED-SECTION :NAME NAME))
      (MULTIPLE-VALUE-BIND (SECTION PRESENT-P)
          (FIND-OR-INSERT NAME *NAMED-SECTIONS*)
        (WHEN PRESENT-P
          (MULTIPLE-VALUE-BIND (NEW-PREFIX-P NEW-LEN)
              (SECTION-NAME-PREFIX-P NAME)
            (MULTIPLE-VALUE-BIND (OLD-PREFIX-P OLD-LEN)
                (SECTION-NAME-PREFIX-P (SECTION-NAME SECTION))
              (WHEN
                  (OR (AND OLD-PREFIX-P (NOT NEW-PREFIX-P))
                      (AND OLD-PREFIX-P NEW-PREFIX-P (< NEW-LEN OLD-LEN)))
                (SETF (SECTION-NAME SECTION) NAME)))))
        SECTION)))
(DEFUN READTABLE-FOR-MODE (MODE)
  (DECLARE (TYPE (OR MODE NULL) MODE))
  (CDR (ASSOC MODE *READTABLES*)))
(DEFMACRO WITH-MODE (MODE &BODY BODY)
  `(LET ((*READTABLE* (READTABLE-FOR-MODE ,MODE)))
     ,@BODY))
(DEFUN SIMPLE-READER-ERROR (STREAM CONTROL &REST ARGS)
  (ERROR 'SIMPLE-READER-ERROR :STREAM STREAM :FORMAT-CONTROL CONTROL
         :FORMAT-ARGUMENTS ARGS))
(EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)
  (DEFINE-SYMBOL-MACRO EOF (LOAD-TIME-VALUE *EOF* T)))
(DEFUN EOF-P (OBJECT) (EQ OBJECT EOF))
(DEFTYPE EOF () '(SATISFIES EOF-P))
(DEFUN TOKEN-DELIMITER-P (CHAR)
  (DECLARE (TYPE CHARACTER CHAR))
  (OR (WHITESPACEP CHAR)
      (MULTIPLE-VALUE-BIND #'NON-TERMINATING-P
          (GET-MACRO-CHARACTER CHAR)
        (AND FUNCTION (NOT NON-TERMINATING-P)))))
(DEFUN WRAP-READER-MACRO-FUNCTION (FUNCTION)
  (LAMBDA (&REST ARGS)
    (LET ((VALUES (MULTIPLE-VALUE-LIST (APPLY FUNCTION ARGS))))
      (ASSERT (NULL (CDR VALUES)) (VALUES)
              "Reader macro function ~S returned more than one value."
              FUNCTION)
      (IF VALUES
          (VALUES-LIST VALUES)
          (THROW 'READ-NOTHING (VALUES))))))
(DEFUN READ-MAYBE-NOTHING-INTERNAL
       (READ STREAM EOF-ERROR-P EOF-VALUE RECURSIVE-P)
  (MULTIPLE-VALUE-LIST
   (CATCH 'READ-NOTHING
     (FUNCALL READ STREAM EOF-ERROR-P EOF-VALUE RECURSIVE-P))))
(DEFUN READ-MAYBE-NOTHING
       (STREAM &OPTIONAL (EOF-ERROR-P T) EOF-VALUE RECURSIVE-P)
  (READ-MAYBE-NOTHING-INTERNAL #'READ STREAM EOF-ERROR-P EOF-VALUE RECURSIVE-P))
(DEFUN READ-MAYBE-NOTHING-PRESERVING-WHITESPACE
       (STREAM &OPTIONAL (EOF-ERROR-P T) EOF-VALUE RECURSIVE-P)
  (READ-MAYBE-NOTHING-INTERNAL #'READ-PRESERVING-WHITESPACE STREAM EOF-ERROR-P
                               EOF-VALUE RECURSIVE-P))
(DEFCLASS CHARPOS-STREAM NIL
          ((CHARPOS :INITARG :CHARPOS :READER CHARPOS :INITFORM 0)
           (LINENO :INITARG :LINENO :READER LINENO :INITFORM 1)
           (PROXY-STREAM :ACCESSOR CHARPOS-PROXY-STREAM :INITARG :PROXY)))
(DEFGENERIC GET-CHARPOS-STREAM-BUFFER
    (STREAM))
(DEFMETHOD CHARPOS :BEFORE ((STREAM CHARPOS-STREAM))
  (UPDATE-CHARPOS-STREAM-POSITIONS STREAM))
(DEFMETHOD LINENO ((STREAM STREAM)) NIL)
(DEFMETHOD LINENO :BEFORE ((STREAM CHARPOS-STREAM))
  (UPDATE-CHARPOS-STREAM-POSITIONS STREAM))
(DEFUN UPDATE-CHARPOS-STREAM-POSITIONS (STREAM)
  (WITH-SLOTS (CHARPOS LINENO)
      STREAM
    (LOOP FOR CHAR ACROSS (GET-CHARPOS-STREAM-BUFFER STREAM)
          DO (CASE CHAR
               (#\Tab (INCF CHARPOS (- *TAB-WIDTH* (REM CHARPOS *TAB-WIDTH*))))
               (#\Newline (INCF LINENO) (SETF CHARPOS 0))
               (T (INCF CHARPOS))))))
(DEFCLASS CHARPOS-INPUT-STREAM (CHARPOS-STREAM) NIL)
(DEFMETHOD SHARED-INITIALIZE
           ((INSTANCE CHARPOS-INPUT-STREAM) SLOT-NAMES
            &REST INITARGS
            &KEY STREAM
            &AUX (ELEMENT-TYPE (STREAM-ELEMENT-TYPE STREAM)))
  (APPLY #'CALL-NEXT-METHOD INSTANCE SLOT-NAMES :PROXY
         (MAKE-ECHO-STREAM STREAM
                           (MAKE-STRING-OUTPUT-STREAM :ELEMENT-TYPE
                                                      ELEMENT-TYPE))
         INITARGS))
(DEFMETHOD GET-CHARPOS-STREAM-BUFFER ((STREAM CHARPOS-INPUT-STREAM))
  (GET-OUTPUT-STREAM-STRING
   (ECHO-STREAM-OUTPUT-STREAM (CHARPOS-PROXY-STREAM STREAM))))
(DEFCLASS CHARPOS-OUTPUT-STREAM (CHARPOS-STREAM) NIL)
(DEFMETHOD SHARED-INITIALIZE
           ((INSTANCE CHARPOS-OUTPUT-STREAM) SLOT-NAMES
            &REST INITARGS
            &KEY STREAM
            &AUX (ELEMENT-TYPE (STREAM-ELEMENT-TYPE STREAM)))
  (APPLY #'CALL-NEXT-METHOD INSTANCE SLOT-NAMES :PROXY
         (MAKE-BROADCAST-STREAM
          (MAKE-STRING-OUTPUT-STREAM :ELEMENT-TYPE ELEMENT-TYPE) STREAM)
         INITARGS))
(DEFMETHOD GET-CHARPOS-STREAM-BUFFER ((STREAM CHARPOS-OUTPUT-STREAM))
  (GET-OUTPUT-STREAM-STRING
   (FIRST (BROADCAST-STREAM-STREAMS (CHARPOS-PROXY-STREAM STREAM)))))
(DEFMETHOD INITIALIZE-INSTANCE :AFTER ((INSTANCE CHARPOS-STREAM) &KEY)
  (SETF (GETHASH (CHARPOS-PROXY-STREAM INSTANCE) *CHARPOS-STREAMS*) INSTANCE))
(DEFUN STREAM-CHARPOS (STREAM)
  (CHARPOS
   (OR (GETHASH STREAM *CHARPOS-STREAMS*)
       (ERROR "Not tracking charpos for ~S" STREAM))))
(DEFUN STREAM-LINENO (STREAM)
  (LINENO
   (OR (GETHASH STREAM *CHARPOS-STREAMS*)
       (ERROR "Not tracking lineno for ~S" STREAM))))
(DEFUN RELEASE-CHARPOS-STREAM (STREAM)
  (MULTIPLE-VALUE-BIND (CHARPOS-STREAM PRESENT-P)
      (GETHASH STREAM *CHARPOS-STREAMS*)
    (COND
     (PRESENT-P (SETF (CHARPOS-PROXY-STREAM CHARPOS-STREAM) NIL)
      (REMHASH STREAM *CHARPOS-STREAMS*))
     (T (WARN "Not tracking charpos for ~S" STREAM)))))
(DEFUN MAKE-CHARPOS-INPUT-STREAM (INPUT-STREAM &KEY (CHARPOS 0))
  (MAKE-INSTANCE 'CHARPOS-INPUT-STREAM :STREAM
                 (CASE INPUT-STREAM
                   ((T) *TERMINAL-IO*)
                   ((NIL) *STANDARD-INPUT*)
                   (OTHERWISE INPUT-STREAM))
                 :CHARPOS CHARPOS))
(DEFUN MAKE-CHARPOS-OUTPUT-STREAM (OUTPUT-STREAM &KEY (CHARPOS 0))
  (MAKE-INSTANCE 'CHARPOS-OUTPUT-STREAM :STREAM
                 (CASE OUTPUT-STREAM
                   ((T) *TERMINAL-IO*)
                   ((NIL) *STANDARD-OUTPUT*)
                   (OTHERWISE OUTPUT-STREAM))
                 :CHARPOS CHARPOS))
(DEFMACRO WITH-CHARPOS-INPUT-STREAM ((VAR STREAM &KEY (CHARPOS 0)) &BODY BODY)
  `(LET ((,VAR
          (CHARPOS-PROXY-STREAM
           (MAKE-CHARPOS-INPUT-STREAM ,STREAM :CHARPOS ,CHARPOS))))
     (UNWIND-PROTECT (PROGN ,@BODY) (RELEASE-CHARPOS-STREAM ,VAR))))
(DEFMACRO WITH-CHARPOS-OUTPUT-STREAM ((VAR STREAM &KEY (CHARPOS 0)) &BODY BODY)
  `(LET ((,VAR
          (CHARPOS-PROXY-STREAM
           (MAKE-CHARPOS-OUTPUT-STREAM ,STREAM :CHARPOS ,CHARPOS))))
     (UNWIND-PROTECT (PROGN ,@BODY) (RELEASE-CHARPOS-STREAM ,VAR))))
(DEFMACRO WITH-REWIND-STREAM
          ((VAR STREAM &OPTIONAL (REWIND 'REWIND)) &BODY BODY)
  (WITH-UNIQUE-NAMES (IN OUT CLOSE)
    `(LET* ((,OUT (MAKE-STRING-OUTPUT-STREAM))
            (,VAR (MAKE-ECHO-STREAM ,STREAM ,OUT))
            (,CLOSE (LIST ,VAR ,OUT)))
       (FLET ((,REWIND ()
                (LET ((,IN
                       (MAKE-STRING-INPUT-STREAM
                        (GET-OUTPUT-STREAM-STRING ,OUT))))
                  (PROG1 (SETQ ,VAR (MAKE-CONCATENATED-STREAM ,IN ,VAR))
                    (PUSHNEW ,VAR ,CLOSE)
                    (PUSHNEW ,IN ,CLOSE)))))
         (DECLARE (IGNORABLE (FUNCTION ,REWIND)))
         (UNWIND-PROTECT (PROGN ,@BODY) (MAP NIL #'CLOSE ,CLOSE))))))
(DEFMACRO READ-WITH-ECHO ((STREAM OBJECT ECHOED) &BODY BODY)
  (WITH-UNIQUE-NAMES (OUT ECHO RAW-OUTPUT LENGTH CHAR)
    `(WITH-OPEN-STREAM (,OUT (MAKE-STRING-OUTPUT-STREAM))
       (WITH-OPEN-STREAM (,ECHO (MAKE-ECHO-STREAM ,STREAM ,OUT))
         (LET* ((,OBJECT (READ-PRESERVING-WHITESPACE ,ECHO))
                (,RAW-OUTPUT (GET-OUTPUT-STREAM-STRING ,OUT))
                (,LENGTH (LENGTH ,RAW-OUTPUT))
                (,ECHOED
                 (SUBSEQ ,RAW-OUTPUT 0
                         (IF (LET ((,CHAR (READ-CHAR ,ECHO NIL EOF)))
                               (OR (EOF-P ,CHAR)
                                   (PROGN
                                    (UNREAD-CHAR ,CHAR ,ECHO)
                                    (PLUSP
                                     (LENGTH
                                      (GET-OUTPUT-STREAM-STRING ,OUT))))))
                             ,LENGTH
                             (1- ,LENGTH)))))
           (DECLARE (IGNORABLE ,OBJECT ,ECHOED))
           ,@BODY)))))
(DEFCLASS MARKER NIL ((VALUE :READER MARKER-VALUE :INITARG :VALUE)))
(DEFUN MARKERP (OBJECT) (TYPEP OBJECT 'MARKER))
(DEFGENERIC MARKER-BOUNDP
    (MARKER))
(DEFMETHOD MARKER-BOUNDP ((MARKER MARKER)) (SLOT-BOUNDP MARKER 'VALUE))
(DEFUN SET-TANGLE-DISPATCH (TYPE-SPECIFIER FUNCTION &OPTIONAL (PRIORITY 0))
  (SET-PPRINT-DISPATCH TYPE-SPECIFIER FUNCTION PRIORITY
                       *TANGLE-PPRINT-DISPATCH*))
(DEFUN SET-WEAVE-DISPATCH (TYPE-SPECIFIER FUNCTION &OPTIONAL (PRIORITY 0))
  (SET-PPRINT-DISPATCH TYPE-SPECIFIER FUNCTION PRIORITY
                       *WEAVE-PPRINT-DISPATCH*))
(SET-TANGLE-DISPATCH 'MARKER
                     (LAMBDA (STREAM MARKER)
                       (WHEN (MARKER-BOUNDP MARKER)
                         (WRITE (MARKER-VALUE MARKER) :STREAM STREAM))))
(DEFCLASS NEWLINE-MARKER (MARKER)
          ((INDENTATION :ACCESSOR INDENTATION :INITFORM NIL)))
(DEFCLASS PAR-MARKER (NEWLINE-MARKER) NIL)
(DEFUN NEWLINEP (OBJ) (TYPEP OBJ 'NEWLINE-MARKER))
(SET-MACRO-CHARACTER #\Newline
                     (LAMBDA (STREAM CHAR)
                       (DECLARE (IGNORE CHAR))
                       (CASE (PEEK-CHAR NIL STREAM NIL EOF T)
                         (#\Newline
                          (READ-CHAR STREAM T NIL T)
                          (MAKE-INSTANCE 'PAR-MARKER))
                         (OTHERWISE (MAKE-INSTANCE 'NEWLINE-MARKER))))
                     NIL (READTABLE-FOR-MODE :LISP))
(DEFCLASS EMPTY-LIST-MARKER (MARKER) NIL (:DEFAULT-INITARGS :VALUE 'NIL))
(DEFVAR *EMPTY-LIST* (MAKE-INSTANCE 'EMPTY-LIST-MARKER))
(DEFCLASS LIST-MARKER (MARKER)
          ((LENGTH :ACCESSOR LIST-MARKER-LENGTH :INITARG :LENGTH)
           (LIST :ACCESSOR LIST-MARKER-LIST :INITARG :LIST)
           (CHARPOS :ACCESSOR LIST-MARKER-CHARPOS :INITARG :CHARPOS)))
(DEFUN LIST-MARKER-P (OBJ) (TYPEP OBJ 'LIST-MARKER))
(DEFCLASS CONSING-DOT-MARKER (MARKER) NIL)
(DEFVAR *CONSING-DOT* (MAKE-INSTANCE 'CONSING-DOT-MARKER))
(DEFMETHOD MARKER-BOUNDP ((MARKER LIST-MARKER)) T)
(DEFMETHOD MARKER-VALUE ((MARKER LIST-MARKER))
  (DO* ((LIST (LIST NIL))
        (TAIL LIST)
        (MARKER-LIST (LIST-MARKER-LIST MARKER) (CDR MARKER-LIST))
        (X (CAR MARKER-LIST) (CAR MARKER-LIST)))
       ((ENDP MARKER-LIST) (CDR LIST))
    (COND
     ((EQ X *CONSING-DOT*)
      (RPLACD TAIL
              (DOLIST (X MARKER-LIST (ERROR "Nothing after . in list"))
                (WHEN
                    (OR (NOT (MARKERP X)) (AND (MARKERP X) (MARKER-BOUNDP X)))
                  (RETURN X))))
      (RETURN (CDR LIST)))
     ((MARKERP X)
      (WHEN (MARKER-BOUNDP X)
        (LET ((OBJ (LIST X)))
          (RPLACD TAIL OBJ)
          (SETQ TAIL OBJ))))
     (T
      (LET ((OBJ (LIST X)))
        (RPLACD TAIL OBJ)
        (SETQ TAIL OBJ))))))
(DEFUN MAKE-LIST-READER (NEXT)
  (LAMBDA (STREAM CHAR)
    (IF (CHAR= (PEEK-CHAR T STREAM T NIL T) #\))
        (PROGN (READ-CHAR STREAM T NIL T) *EMPTY-LIST*)
        (FUNCALL NEXT STREAM CHAR))))
(SET-MACRO-CHARACTER #\( (MAKE-LIST-READER (GET-MACRO-CHARACTER #\( NIL)) NIL
                     (READTABLE-FOR-MODE :INNER-LISP))
(DEFUN LIST-READER (STREAM CHAR)
  (DECLARE (IGNORE CHAR))
  (LOOP WITH LIST = 'NIL
        WITH CHARPOS-LIST = 'NIL
        FOR N UPFROM 0
        AND NEXT-CHAR = (PEEK-CHAR T STREAM T NIL
                                   T) AS CHARPOS = (STREAM-CHARPOS STREAM)
        UNTIL (CHAR= #\) NEXT-CHAR)
        IF (CHAR= #\. NEXT-CHAR)
        DO (WITH-REWIND-STREAM (STREAM STREAM)
             (READ-CHAR STREAM T NIL T)
             (LET ((FOLLOWING-CHAR (READ-CHAR STREAM T NIL T)))
               (COND
                ((TOKEN-DELIMITER-P FOLLOWING-CHAR)
                 (UNLESS (OR LIST *READ-SUPPRESS*)
                   (SIMPLE-READER-ERROR STREAM
                                        "Nothing appears before . in list."))
                 (UNREAD-CHAR FOLLOWING-CHAR STREAM) (PUSH *CONSING-DOT* LIST)
                 (PUSH CHARPOS CHARPOS-LIST))
                (T (REWIND)
                 (LET ((VALUES (READ-MAYBE-NOTHING STREAM T NIL T)))
                   (WHEN VALUES
                     (PUSH (CAR VALUES) LIST)
                     (PUSH CHARPOS CHARPOS-LIST))))))) ELSE
        DO (LET ((VALUES (READ-MAYBE-NOTHING STREAM T NIL T)))
             (WHEN VALUES
               (PUSH (CAR VALUES) LIST)
               (PUSH CHARPOS CHARPOS-LIST)))
        FINALLY (READ-CHAR STREAM T NIL T) (RETURN
                                            (MAKE-INSTANCE 'LIST-MARKER :LENGTH
                                                           N :LIST
                                                           (NREVERSE LIST)
                                                           :CHARPOS
                                                           (NREVERSE
                                                            CHARPOS-LIST)))))
(SET-MACRO-CHARACTER #\( (MAKE-LIST-READER #'LIST-READER) NIL
                     (READTABLE-FOR-MODE :LISP))
(DEFCLASS QUOTE-MARKER (MARKER)
          ((QUOTE :READER QUOTE-MARKER-QUOTE :INITARG :QUOTE)
           (FORM :READER QUOTED-FORM :INITARG :FORM)))
(DEFMETHOD MARKER-BOUNDP ((MARKER QUOTE-MARKER)) T)
(DEFMETHOD MARKER-VALUE ((MARKER QUOTE-MARKER))
  (LIST (QUOTE-MARKER-QUOTE MARKER) (QUOTED-FORM MARKER)))
(DEFUN SINGLE-QUOTE-READER (STREAM CHAR)
  (DECLARE (IGNORE CHAR))
  (MAKE-INSTANCE 'QUOTE-MARKER :QUOTE 'QUOTE :FORM (READ STREAM T NIL T)))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-MACRO-CHARACTER #\' #'SINGLE-QUOTE-READER NIL (READTABLE-FOR-MODE MODE)))
(DEFCLASS COMMENT-MARKER (MARKER) ((TEXT :READER COMMENT-TEXT :INITARG :TEXT)))
(DEFUN COMMENT-READER (STREAM CHAR)
  (IF (CHAR= (PEEK-CHAR NIL STREAM NIL #\Newline T) #\Newline)
      (PROGN (READ-CHAR STREAM T NIL T) (VALUES))
      (MAKE-INSTANCE 'COMMENT-MARKER :TEXT
                     (WITH-OUTPUT-TO-STRING (S)
                       (WRITE-CHAR CHAR S)
                       (DO ()
                           ((CHAR= (PEEK-CHAR NIL STREAM NIL #\Newline T)
                                   #\Newline))
                         (WRITE-CHAR (READ-CHAR STREAM T NIL T) S))))))
(SET-MACRO-CHARACTER #\; (WRAP-READER-MACRO-FUNCTION #'COMMENT-READER) NIL
                     (READTABLE-FOR-MODE :LISP))
(DEFVAR *BACKQUOTE* (MAKE-SYMBOL "BACKQUOTE"))
(DEFUN BACKQUOTEP (OBJECT) (EQ OBJECT *BACKQUOTE*))
(DEFTYPE BACKQUOTE-FORM () '(CONS (SATISFIES BACKQUOTEP)))
(DEFCLASS COMMA NIL ((FORM :INITARG :FORM :INITFORM NIL)))
(DEFCLASS SPLICING-COMMA (COMMA)
          ((MODIFIER :READER COMMA-MODIFIER :INITARG :MODIFIER :TYPE
            CHARACTER)))
(DEFMETHOD COMMA-MODIFIER ((COMMA COMMA)) NIL)
(DEFUN MAKE-COMMA (MODIFIER FORM)
  (IF MODIFIER
      (MAKE-INSTANCE 'SPLICING-COMMA :MODIFIER MODIFIER :FORM FORM)
      (MAKE-INSTANCE 'COMMA :FORM FORM)))
(DEFUN COMMAP (OBJ) (TYPEP OBJ 'COMMA))
(DEFGENERIC COMMA-FORM
    (COMMA &KEY TANGLE))
(DEFMETHOD COMMA-FORM ((COMMA COMMA) &KEY (TANGLE T))
  (LET ((FORM (SLOT-VALUE COMMA 'FORM)))
    (UNLESS TANGLE (RETURN-FROM COMMA-FORM FORM))
    (LET ((TANGLED-FORM (TANGLE FORM)))
      (TYPECASE FORM
        (NAMED-SECTION
         (WHEN (REST TANGLED-FORM)
           (CERROR "Ignore the extra forms."
                   "Tried to unquote more than one form from section @<~A@>."
                   (SECTION-NAME FORM)))
         (FIRST TANGLED-FORM))
        (T TANGLED-FORM)))))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-MACRO-CHARACTER #\`
                       (LAMBDA (STREAM CHAR)
                         (DECLARE (IGNORE CHAR))
                         (LIST *BACKQUOTE* (READ STREAM T NIL T)))
                       NIL (READTABLE-FOR-MODE MODE))
  (SET-MACRO-CHARACTER #\,
                       (LAMBDA (STREAM CHAR)
                         (DECLARE (IGNORE CHAR))
                         (CASE (PEEK-CHAR NIL STREAM T NIL T)
                           ((#\@ #\.)
                            (MAKE-COMMA (READ-CHAR STREAM T NIL T)
                                        (READ STREAM T NIL T)))
                           (OTHERWISE (MAKE-COMMA NIL (READ STREAM T NIL T)))))
                       NIL (READTABLE-FOR-MODE MODE)))
(DEFMACRO BACKQUOTE (X) (BQ-PROCESS X))
(SETF (MACRO-FUNCTION *BACKQUOTE*) (MACRO-FUNCTION 'BACKQUOTE))
(DEFUN BQ-PROCESS (X &AUX (X (TANGLE X)))
  (TYPECASE X
    (SIMPLE-VECTOR `(APPLY #'VECTOR ,(BQ-PROCESS (COERCE X 'LIST))))
    (SPLICING-COMMA (ERROR ",~C~S after `" (COMMA-MODIFIER X) (COMMA-FORM X)))
    (COMMA (COMMA-FORM X))
    (ATOM `',X)
    (BACKQUOTE-FORM (BQ-PROCESS (BQ-PROCESS (CADR X))))
    (T
     (DO ((P X (CDR P))
          (Q 'NIL (CONS (BRACKET (CAR P)) Q)))
         ((AND (ATOM P) (NOT (COMMAP P)))
          (CONS 'APPEND (NRECONC Q (AND P (LIST (LIST 'QUOTE P))))))
       (TYPECASE P
         (SPLICING-COMMA
          (ERROR "Dotted ,~C~S" (COMMA-MODIFIER P) (COMMA-FORM P)))
         (COMMA (RETURN (CONS 'APPEND (NRECONC Q (LIST (COMMA-FORM P)))))))))))
(DEFUN BRACKET (X)
  (TYPECASE X
    (SPLICING-COMMA (COMMA-FORM X))
    (COMMA `(LIST ,(COMMA-FORM X)))
    (T `(LIST ,(BQ-PROCESS X)))))
(SET-TANGLE-DISPATCH 'BACKQUOTE-FORM
                     (LAMBDA (STREAM OBJ) (FORMAT STREAM "`~W" (CADR OBJ))))
(SET-TANGLE-DISPATCH 'COMMA
                     (LAMBDA (STREAM OBJ)
                       (FORMAT STREAM ",~@[~C~]~W" (COMMA-MODIFIER OBJ)
                               (COMMA-FORM OBJ))))
(DEFCLASS FUNCTION-MARKER (QUOTE-MARKER) NIL)
(DEFUN SHARPSIGN-QUOTE-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR ARG))
  (MAKE-INSTANCE 'FUNCTION-MARKER :QUOTE 'FUNCTION :FORM (READ STREAM T NIL T)))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\' #'SHARPSIGN-QUOTE-READER
                                (READTABLE-FOR-MODE MODE)))
(DEFCLASS SIMPLE-VECTOR-MARKER (MARKER)
          ((LENGTH :INITARG :LENGTH)
           (ELEMENTS :READER SIMPLE-VECTOR-MARKER-ELEMENTS :INITARG :ELEMENTS)
           (ELEMENT-TYPE :READER SIMPLE-VECTOR-MARKER-ELEMENT-TYPE :INITARG
            :ELEMENT-TYPE))
          (:DEFAULT-INITARGS :ELEMENT-TYPE T))
(DEFMETHOD MARKER-BOUNDP ((MARKER SIMPLE-VECTOR-MARKER)) T)
(DEFMETHOD MARKER-VALUE ((MARKER SIMPLE-VECTOR-MARKER))
  (LET ((ELEMENTS (TANGLE (SIMPLE-VECTOR-MARKER-ELEMENTS MARKER)))
        (ELEMENT-TYPE (SIMPLE-VECTOR-MARKER-ELEMENT-TYPE MARKER)))
    (IF (AND ELEMENTS (SLOT-BOUNDP MARKER 'LENGTH))
        (WITH-SLOTS (LENGTH)
            MARKER
          (LET ((SUPPLIED-LENGTH (LENGTH ELEMENTS)))
            (FILL
             (REPLACE (MAKE-ARRAY LENGTH :ELEMENT-TYPE ELEMENT-TYPE) ELEMENTS)
             (ELT ELEMENTS (1- SUPPLIED-LENGTH)) :START SUPPLIED-LENGTH)))
        (COERCE ELEMENTS `(VECTOR ,ELEMENT-TYPE)))))
(DEFUN SIMPLE-VECTOR-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR))
  (LET* ((LIST (READ-DELIMITED-LIST #\) STREAM T))
         (LENGTH
          (HANDLER-CASE (LENGTH LIST)
                        (TYPE-ERROR (ERROR) (DECLARE (IGNORE ERROR))
                         (SIMPLE-READER-ERROR STREAM "improper list in #(): ~S"
                                              LIST))))
         (ELEMENTS (OR LIST *EMPTY-LIST*)))
    (UNLESS *READ-SUPPRESS*
      (IF ARG
          (IF (> LENGTH ARG)
              (SIMPLE-READER-ERROR STREAM
                                   "vector longer than specified length: #~S~S"
                                   ARG LIST)
              (MAKE-INSTANCE 'SIMPLE-VECTOR-MARKER :LENGTH ARG :ELEMENTS
                             ELEMENTS))
          (MAKE-INSTANCE 'SIMPLE-VECTOR-MARKER :ELEMENTS ELEMENTS)))))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\( #'SIMPLE-VECTOR-READER
                                (READTABLE-FOR-MODE MODE)))
(DEFCLASS BIT-VECTOR-MARKER (SIMPLE-VECTOR-MARKER) NIL
          (:DEFAULT-INITARGS :ELEMENT-TYPE 'BIT))
(DEFUN SIMPLE-BIT-VECTOR-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR))
  (APPLY #'MAKE-INSTANCE 'BIT-VECTOR-MARKER :ELEMENTS
         (COERCE
          (LOOP FOR CHAR = (READ-CHAR STREAM NIL NIL T)
                WHILE (AND CHAR (OR (CHAR= CHAR #\0) (CHAR= CHAR #\1)))
                COLLECT (ECASE CHAR (#\0 0) (#\1 1))
                FINALLY (WHEN CHAR (UNREAD-CHAR CHAR STREAM)))
          'BIT-VECTOR)
         (WHEN ARG `(:LENGTH ,ARG))))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\* #'SIMPLE-BIT-VECTOR-READER
                                (READTABLE-FOR-MODE MODE)))
(DEFCLASS READ-TIME-EVAL NIL
          ((FORM :READER READ-TIME-EVAL-FORM :INITARG :FORM)))
(SET-TANGLE-DISPATCH 'READ-TIME-EVAL
                     (LAMBDA (STREAM OBJ)
                       (FORMAT STREAM "#.~W" (READ-TIME-EVAL-FORM OBJ))))
(DEFCLASS READ-TIME-EVAL-MARKER (READ-TIME-EVAL MARKER) NIL)
(DEFMETHOD MARKER-BOUNDP ((MARKER READ-TIME-EVAL-MARKER)) T)
(DEFMETHOD MARKER-VALUE ((MARKER READ-TIME-EVAL-MARKER))
  (IF *EVALUATING*
      (CALL-NEXT-METHOD)
      (MAKE-INSTANCE 'READ-TIME-EVAL :FORM (READ-TIME-EVAL-FORM MARKER))))
(DEFUN SHARPSIGN-DOT-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR ARG))
  (LET ((FORM (READ STREAM T NIL T)))
    (UNLESS *READ-SUPPRESS*
      (UNLESS *READ-EVAL*
        (SIMPLE-READER-ERROR STREAM "can't read #. while *READ-EVAL* is NIL"))
      (MAKE-INSTANCE 'READ-TIME-EVAL-MARKER :FORM FORM :VALUE
                     (EVAL (TANGLE FORM))))))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\. #'SHARPSIGN-DOT-READER
                                (READTABLE-FOR-MODE MODE)))
(DEFCLASS RADIX-MARKER (MARKER)
          ((BASE :READER RADIX-MARKER-BASE :INITARG :BASE)))
(DEFPARAMETER *RADIX-PREFIX-ALIST* '((#\B . 2) (#\O . 8) (#\X . 16) (#\R)))
(DEFUN RADIX-READER (STREAM SUB-CHAR ARG)
  (MAKE-INSTANCE 'RADIX-MARKER :BASE
                 (OR (CDR (ASSOC (CHAR-UPCASE SUB-CHAR) *RADIX-PREFIX-ALIST*))
                     ARG)
                 :VALUE
                 (FUNCALL
                  (GET-DISPATCH-MACRO-CHARACTER #\# SUB-CHAR
                                                (READTABLE-FOR-MODE NIL))
                  STREAM SUB-CHAR ARG)))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (DOLIST (SUB-CHAR '(#\B #\b #\O #\o #\X #\x #\R #\r))
    (SET-DISPATCH-MACRO-CHARACTER #\# SUB-CHAR #'RADIX-READER
                                  (READTABLE-FOR-MODE MODE))))
(DEFCLASS COMPLEX-MARKER (MARKER)
          ((COMPONENTS :READER COMPLEX-COMPONENTS :INITARG :COMPONENTS)))
(DEFMETHOD MARKER-BOUNDP ((MARKER COMPLEX-MARKER)) T)
(DEFMETHOD MARKER-VALUE ((MARKER COMPLEX-MARKER))
  (APPLY #'COMPLEX (TANGLE (COMPLEX-COMPONENTS MARKER))))
(DEFUN COMPLEX-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR ARG))
  (MAKE-INSTANCE 'COMPLEX-MARKER :COMPONENTS (READ STREAM T NIL T)))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\C #'COMPLEX-READER
                                (READTABLE-FOR-MODE MODE)))
(DEFCLASS ARRAY-MARKER (MARKER)
          ((RANK :READER ARRAY-MARKER-RANK :INITARG :RANK)
           (INITIAL-CONTENTS :READER ARRAY-MARKER-INITIAL-CONTENTS :INITARG
            :INITIAL-CONTENTS)))
(DEFMETHOD MARKER-BOUNDP ((MARKER ARRAY-MARKER)) T)
(DEFMETHOD MARKER-VALUE ((MARKER ARRAY-MARKER))
  (LOOP WITH CONTENTS = (TANGLE (ARRAY-MARKER-INITIAL-CONTENTS MARKER))
        REPEAT (ARRAY-MARKER-RANK MARKER)
        FOR SEQ = CONTENTS THEN (AND SEQ (ELT SEQ 0))
        COLLECT (LENGTH SEQ) INTO DIMENSIONS
        FINALLY (RETURN (MAKE-ARRAY DIMENSIONS :INITIAL-CONTENTS CONTENTS))))
(DEFUN ARRAY-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR))
  (UNLESS ARG (SIMPLE-READER-ERROR STREAM "no rank supplied with #A"))
  (MAKE-INSTANCE 'ARRAY-MARKER :RANK ARG :INITIAL-CONTENTS
                 (READ STREAM T NIL T)))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\A #'ARRAY-READER
                                (READTABLE-FOR-MODE MODE)))
(DEFCLASS STRUCTURE-MARKER (MARKER)
          ((FORM :READER STRUCTURE-MARKER-FORM :INITARG :FORM)))
(DEFMETHOD MARKER-BOUNDP ((MARKER STRUCTURE-MARKER)) T)
(DEFMETHOD MARKER-VALUE ((MARKER STRUCTURE-MARKER))
  (LET ((*READTABLE* (READTABLE-FOR-MODE NIL)))
    (VALUES
     (READ-FROM-STRING
      (WRITE-TO-STRING MARKER :PPRINT-DISPATCH *TANGLE-PPRINT-DISPATCH* :PRETTY
                       T :READABLY T)))))
(SET-TANGLE-DISPATCH 'STRUCTURE-MARKER
                     (LAMBDA (STREAM OBJ)
                       (FORMAT STREAM "#S~W" (STRUCTURE-MARKER-FORM OBJ)))
                     1)
(DEFUN STRUCTURE-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR ARG))
  (MAKE-INSTANCE 'STRUCTURE-MARKER :FORM (READ STREAM T NIL T)))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\S #'STRUCTURE-READER
                                (READTABLE-FOR-MODE MODE)))
(DEFCLASS PATHNAME-MARKER (MARKER)
          ((NAMESTRING :READER PATHNAME-MARKER-NAMESTRING :INITARG
                       :NAMESTRING)))
(DEFMETHOD MARKER-BOUNDP ((MARKER PATHNAME-MARKER)) T)
(DEFMETHOD MARKER-VALUE ((MARKER PATHNAME-MARKER))
  (PARSE-NAMESTRING (PATHNAME-MARKER-NAMESTRING MARKER)))
(SET-TANGLE-DISPATCH 'LOGICAL-PATHNAME
                     (LAMBDA (STREAM OBJ)
                       (FORMAT STREAM "#P~W"
                               (STRING-DOWNCASE
                                (WITH-STANDARD-IO-SYNTAX (NAMESTRING OBJ)))))
                     1)
(SET-TANGLE-DISPATCH 'PATHNAME-MARKER
                     (LAMBDA (STREAM OBJ)
                       (FORMAT STREAM "#P~W"
                               (ETYPECASE (MARKER-VALUE OBJ)
                                 (LOGICAL-PATHNAME
                                  (STRING-DOWNCASE
                                   (PATHNAME-MARKER-NAMESTRING OBJ)))
                                 (PATHNAME (PATHNAME-MARKER-NAMESTRING OBJ)))))
                     1)
(DEFUN PATHNAME-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR ARG))
  (MAKE-INSTANCE 'PATHNAME-MARKER :NAMESTRING (READ STREAM T NIL T)))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\P #'PATHNAME-READER
                                (READTABLE-FOR-MODE MODE)))
(DEFUN FEATUREP (X)
  (ETYPECASE X
    (SYMBOL (NOT (NULL (MEMBER X *FEATURES* :TEST #'EQ))))
    (CONS
     (CASE (CAR X)
       ((:NOT NOT)
        (COND
         ((CDDR X)
          (ERROR "Too many subexpressions in feature expression: ~S." X))
         ((NULL (CDR X))
          (ERROR "Too few subexpressions in feature expression: ~S." X))
         (T (NOT (FEATUREP (CADR X))))))
       ((:AND AND) (EVERY #'FEATUREP (CDR X)))
       ((:OR OR) (SOME #'FEATUREP (CDR X)))
       (T (ERROR "Unknown operator in feature expression: ~S." X))))))
(DEFCLASS READ-TIME-CONDITIONAL NIL
          ((PLUSP :READER READ-TIME-CONDITIONAL-PLUSP :INITARG :PLUSP)
           (TEST :READER READ-TIME-CONDITIONAL-TEST :INITARG :TEST)
           (FORM :READER READ-TIME-CONDITIONAL-FORM :INITARG :FORM)))
(SET-TANGLE-DISPATCH 'READ-TIME-CONDITIONAL
                     (LAMBDA (STREAM OBJ)
                       (FORMAT STREAM "#~:[-~;+~]~S~A"
                               (READ-TIME-CONDITIONAL-PLUSP OBJ)
                               (READ-TIME-CONDITIONAL-TEST OBJ)
                               (READ-TIME-CONDITIONAL-FORM OBJ))))
(DEFCLASS READ-TIME-CONDITIONAL-MARKER (READ-TIME-CONDITIONAL MARKER) NIL)
(DEFMETHOD MARKER-BOUNDP ((MARKER READ-TIME-CONDITIONAL-MARKER))
  (IF *EVALUATING*
      (CALL-NEXT-METHOD)
      T))
(DEFMETHOD MARKER-VALUE ((MARKER READ-TIME-CONDITIONAL-MARKER))
  (IF *EVALUATING*
      (CALL-NEXT-METHOD)
      (MAKE-INSTANCE 'READ-TIME-CONDITIONAL :PLUSP
                     (READ-TIME-CONDITIONAL-PLUSP MARKER) :TEST
                     (READ-TIME-CONDITIONAL-TEST MARKER) :FORM
                     (READ-TIME-CONDITIONAL-FORM MARKER))))
(DEFUN READ-TIME-CONDITIONAL-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE ARG))
  (LET* ((PLUSP (ECASE SUB-CHAR (#\+ T) (#\- NIL)))
         (*READTABLE* (READTABLE-FOR-MODE NIL))
         (TEST
          (LET ((*PACKAGE* (FIND-PACKAGE "KEYWORD")) (*READ-SUPPRESS* NIL))
            (READ-PRESERVING-WHITESPACE STREAM T NIL NIL)))
         (*READ-SUPPRESS*
          (IF PLUSP
              (NOT (FEATUREP TEST))
              (FEATUREP TEST))))
    (READ-WITH-ECHO (STREAM VALUE FORM)
      (APPLY #'MAKE-INSTANCE 'READ-TIME-CONDITIONAL-MARKER :PLUSP PLUSP :TEST
             TEST :FORM FORM (AND (NOT *READ-SUPPRESS*) (LIST :VALUE VALUE))))))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\+ #'READ-TIME-CONDITIONAL-READER
                                (READTABLE-FOR-MODE MODE))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\- #'READ-TIME-CONDITIONAL-READER
                                (READTABLE-FOR-MODE MODE)))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\|
                                (WRAP-READER-MACRO-FUNCTION
                                 (GET-DISPATCH-MACRO-CHARACTER #\# #\| NIL))
                                (READTABLE-FOR-MODE MODE)))
(DEFUN SNARF-UNTIL-CONTROL-CHAR
       (STREAM CONTROL-CHARS &AUX (CONTROL-CHARS (ENSURE-LIST CONTROL-CHARS)))
  (WITH-OUTPUT-TO-STRING (STRING)
    (LOOP FOR CHAR = (PEEK-CHAR NIL STREAM NIL EOF NIL)
          UNTIL (OR (EOF-P CHAR) (MEMBER CHAR CONTROL-CHARS))
          DO (WRITE-CHAR (READ-CHAR STREAM) STRING))))
(DEFUN READ-INNER-LISP (STREAM CHAR)
  (WITH-MODE :INNER-LISP
    (READ-DELIMITED-LIST CHAR STREAM)))
(DOLIST (MODE '(:TEX :RESTRICTED))
  (SET-MACRO-CHARACTER #\| #'READ-INNER-LISP NIL (READTABLE-FOR-MODE MODE)))
(SET-MACRO-CHARACTER #\| (GET-MACRO-CHARACTER #\) NIL) NIL
                     (READTABLE-FOR-MODE :INNER-LISP))
(DOLIST (MODE *MODES*)
  (IGNORE-ERRORS
   (MAKE-DISPATCH-MACRO-CHARACTER #\@ T (READTABLE-FOR-MODE MODE))))
(DEFUN GET-CONTROL-CODE (SUB-CHAR MODE)
  (GET-DISPATCH-MACRO-CHARACTER #\@ SUB-CHAR (READTABLE-FOR-MODE MODE)))
(DEFUN SET-CONTROL-CODE (SUB-CHAR FUNCTION &OPTIONAL (MODES *MODES*))
  (DOLIST (MODE (ENSURE-LIST MODES))
    (SET-DISPATCH-MACRO-CHARACTER #\@ SUB-CHAR FUNCTION
                                  (READTABLE-FOR-MODE MODE))))
(SET-CONTROL-CODE #\@
                  (LAMBDA (STREAM SUB-CHAR ARG)
                    (DECLARE (IGNORE SUB-CHAR STREAM ARG))
                    (STRING "@")))
(SET-CONTROL-CODE #\q
                  (LAMBDA (STREAM SUB-CHAR ARG)
                    (DECLARE (IGNORE SUB-CHAR ARG))
                    (READ-LINE STREAM)
                    (VALUES)))
(DEFSTRUCT
    (SOURCE-LOCATION (:CONSTRUCTOR CREATE-SOURCE-LOCATION (LINENO FILE)))
  LINENO
  FILE)
(DEFUN SOURCE-LOCATION-FOR-READER (STREAM)
  (LABELS ((STREAM-PATHNAME (STREAM)
             (TYPECASE STREAM
               (FILE-STREAM (IGNORE-ERRORS (PATHNAME STREAM)))
               (SYNONYM-STREAM
                (STREAM-PATHNAME
                 (SYMBOL-VALUE (SYNONYM-STREAM-SYMBOL STREAM))))
               (TWO-WAY-STREAM
                (STREAM-PATHNAME (TWO-WAY-STREAM-INPUT-STREAM STREAM)))
               (CONCATENATED-STREAM
                (STREAM-PATHNAME
                 (FIRST (CONCATENATED-STREAM-STREAMS STREAM)))))))
    (LET ((LINENO (STREAM-LINENO STREAM)) (PATHNAME (STREAM-PATHNAME STREAM)))
      (WHEN (AND LINENO PATHNAME) (CREATE-SOURCE-LOCATION LINENO PATHNAME)))))
(DEFUN START-SECTION-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR ARG))
  (MAKE-INSTANCE 'SECTION :SOURCE-LOCATION (SOURCE-LOCATION-FOR-READER STREAM)))
(DOLIST (SUB-CHAR '(#\  #\Newline))
  (SET-CONTROL-CODE SUB-CHAR #'START-SECTION-READER '(:LIMBO :TEX :LISP)))
(DEFUN START-STARRED-SECTION-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR))
  (APPLY #'MAKE-INSTANCE 'STARRED-SECTION :SOURCE-LOCATION
         (SOURCE-LOCATION-FOR-READER STREAM) (WHEN ARG `(:DEPTH ,ARG))))
(SET-CONTROL-CODE #\* #'START-STARRED-SECTION-READER '(:LIMBO :TEX :LISP))
(DEFUN START-TEST-SECTION-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR))
  (PROG1
      (IF (AND (CHAR= (PEEK-CHAR T STREAM T NIL T) #\*)
               (READ-CHAR STREAM T NIL T))
          (APPLY #'MAKE-INSTANCE 'STARRED-TEST-SECTION :SOURCE-LOCATION
                 (SOURCE-LOCATION-FOR-READER STREAM) (WHEN ARG `(:DEPTH ,ARG)))
          (MAKE-INSTANCE 'TEST-SECTION))
    (LOOP UNTIL (CHAR/= (PEEK-CHAR T STREAM T NIL T) #\Newline)
          DO (READ-CHAR STREAM T NIL T))))
(SET-CONTROL-CODE #\t #'START-TEST-SECTION-READER '(:LIMBO :TEX :LISP))
(DEFCLASS START-CODE-MARKER (MARKER)
          ((NAME :READER SECTION-NAME :INITARG :NAME))
          (:DEFAULT-INITARGS :NAME NIL))
(DEFUN START-CODE-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE STREAM SUB-CHAR ARG))
  (MAKE-INSTANCE 'START-CODE-MARKER))
(DOLIST (SUB-CHAR '(#\l #\p))
  (SET-CONTROL-CODE SUB-CHAR #'START-CODE-READER '(:TEX :LISP)))
(DEFCLASS EVALUATED-FORM-MARKER (MARKER) NIL)
(DEFUN READ-EVALUATED-FORM (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR ARG))
  (LOOP FOR FORM = (READ STREAM T NIL T)
        UNTIL (NOT (NEWLINEP FORM))
        FINALLY (RETURN (MAKE-INSTANCE 'EVALUATED-FORM-MARKER :VALUE FORM))))
(SET-CONTROL-CODE #\e #'READ-EVALUATED-FORM :LISP)
(DEFVAR *END-CONTROL-TEXT* (MAKE-SYMBOL "@>"))
(SET-CONTROL-CODE #\> (CONSTANTLY *END-CONTROL-TEXT*) :RESTRICTED)
(DEFUN READ-CONTROL-TEXT
       (STREAM &OPTIONAL (EOF-ERROR-P T) EOF-VALUE RECURSIVE-P)
  (WITH-OUTPUT-TO-STRING (STRING)
    (WITH-MODE :RESTRICTED
      (LOOP FOR TEXT = (SNARF-UNTIL-CONTROL-CHAR STREAM #\@)
            FOR NEXT = (READ-PRESERVING-WHITESPACE STREAM EOF-ERROR-P EOF-VALUE
                                                   RECURSIVE-P)
            DO (WRITE-STRING TEXT STRING)
            IF (EQ NEXT *END-CONTROL-TEXT*)
            DO (LOOP-FINISH) ELSE
            DO (WRITE-STRING NEXT STRING)))))
(DEFUN MAKE-SECTION-NAME-READER (DEFINITION-ALLOWED-P USE)
  (LAMBDA (STREAM SUB-CHAR ARG)
    (DECLARE (IGNORE SUB-CHAR ARG))
    (LET* ((NAME (READ-CONTROL-TEXT STREAM T NIL T))
           (DEFINITIONP (EQL (PEEK-CHAR NIL STREAM NIL NIL T) #\=)))
      (IF DEFINITIONP
          (IF DEFINITION-ALLOWED-P
              (PROGN
               (READ-CHAR STREAM)
               (MAKE-INSTANCE 'START-CODE-MARKER :NAME NAME))
              (RESTART-CASE (ERROR 'SECTION-NAME-DEFINITION-ERROR :NAME NAME)
                (USE-SECTION NIL :REPORT
                 "Don't define the section, just use it."
                 (FIND-SECTION NAME))))
          (IF DEFINITION-ALLOWED-P
              (RESTART-CASE (ERROR 'SECTION-NAME-USE-ERROR :NAME NAME)
                (NAME-SECTION NIL :REPORT
                 "Name the current section and start the code part."
                 (MAKE-INSTANCE 'START-CODE-MARKER :NAME NAME))
                (CITE-SECTION NIL :REPORT
                 "Assume the section is just being cited."
                 (FIND-SECTION NAME)))
              (LET ((NAMED-SECTION (FIND-SECTION NAME)))
                (IF USE
                    (PUSHNEW *CURRENT-SECTION* (USED-BY NAMED-SECTION))
                    (PUSHNEW *CURRENT-SECTION* (CITED-BY NAMED-SECTION)))
                NAMED-SECTION))))))
(SET-CONTROL-CODE #\< (MAKE-SECTION-NAME-READER T NIL) :TEX)
(SET-CONTROL-CODE #\< (MAKE-SECTION-NAME-READER NIL T) :LISP)
(SET-CONTROL-CODE #\< (MAKE-SECTION-NAME-READER NIL NIL) :INNER-LISP)
(DEFUN SYMBOL-REPLACEMENT-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR ARG))
  (LET* ((SYMBOL (READ STREAM)) (REPLACEMENT (READ STREAM)))
    (CHECK-TYPE SYMBOL SYMBOL "a symbol")
    (CHECK-TYPE REPLACEMENT STRING "a replacement string")
    (WEAVE-SYMBOL-REPLACE SYMBOL REPLACEMENT))
  (VALUES))
(SET-CONTROL-CODE #\w #'SYMBOL-REPLACEMENT-READER :LISP)
(DEFUN INDEX-PACKAGE-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR ARG))
  (LET ((FORM (READ STREAM)))
    (INDEX-PACKAGE FORM)
    FORM))
(SET-CONTROL-CODE #\x #'INDEX-PACKAGE-READER :LISP)
(DEFUN INDEX-ENTRY-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE ARG))
  (ADD-INDEX-ENTRY *INDEX*
                   (MAKE-INSTANCE
                    (ECASE SUB-CHAR
                      (#\^ 'HEADING)
                      (#\. 'TT-HEADING)
                      (#\: 'CUSTOM-HEADING))
                    :NAME (READ-CONTROL-TEXT STREAM))
                   *CURRENT-SECTION*)
  (VALUES))
(DOLIST (SUB-CHAR '(#\^ #\. #\:))
  (SET-CONTROL-CODE SUB-CHAR (WRAP-READER-MACRO-FUNCTION #'INDEX-ENTRY-READER)
                    '(:TEX :LISP)))
(DEFUN READ-SECTIONS (INPUT-STREAM &KEY (APPEND T))
  (WITH-CHARPOS-INPUT-STREAM (STREAM INPUT-STREAM)
    (FLET ((FINISH-SECTION (SECTION COMMENTARY CODE)
             (WHEN (STRINGP (CAR COMMENTARY))
               (RPLACA COMMENTARY
                       (STRING-RIGHT-TRIM *WHITESPACE* (CAR COMMENTARY))))
             (SETQ COMMENTARY (NREVERSE COMMENTARY))
             (WHEN (STRINGP (CAR COMMENTARY))
               (RPLACA COMMENTARY
                       (STRING-LEFT-TRIM *WHITESPACE* (CAR COMMENTARY))))
             (SETQ CODE (NREVERSE (MEMBER-IF-NOT #'NEWLINEP CODE)))
             (SETF (SECTION-COMMENTARY SECTION) COMMENTARY)
             (SETF (SECTION-CODE SECTION) CODE)
             (WHEN (SECTION-NAME SECTION)
               (LET ((NAMED-SECTION (FIND-SECTION (SECTION-NAME SECTION))))
                 (IF APPEND
                     (PUSH SECTION (NAMED-SECTION-SECTIONS NAMED-SECTION))
                     (SETF (NAMED-SECTION-SECTIONS NAMED-SECTION)
                             (LIST SECTION)))))
             SECTION))
      (PROG (FORM COMMENTARY CODE SECTION SECTIONS)
        (SETQ SECTION (MAKE-INSTANCE 'LIMBO-SECTION))
        (WITH-MODE :LIMBO
          (LOOP (MAYBE-PUSH (SNARF-UNTIL-CONTROL-CHAR STREAM #\@) COMMENTARY)
                (LET ((NEXT-INPUT
                       (READ-MAYBE-NOTHING-PRESERVING-WHITESPACE STREAM NIL EOF
                                                                 NIL)))
                  (WHEN NEXT-INPUT
                    (TYPECASE (SETQ FORM (CAR NEXT-INPUT))
                      (EOF (GO EOF))
                      (SECTION (GO COMMENTARY))
                      (T (PUSH FORM COMMENTARY)))))))
       COMMENTARY
        (PUSH (FINISH-SECTION SECTION COMMENTARY CODE) SECTIONS)
        (CHECK-TYPE FORM SECTION)
        (SETQ SECTION FORM
              COMMENTARY 'NIL
              CODE 'NIL)
        (WITH-MODE :TEX
          (LOOP
           (MAYBE-PUSH (SNARF-UNTIL-CONTROL-CHAR STREAM '(#\@ #\|)) COMMENTARY)
           (LET ((NEXT-INPUT
                  (READ-MAYBE-NOTHING-PRESERVING-WHITESPACE STREAM NIL EOF
                                                            NIL)))
             (WHEN NEXT-INPUT
               (TYPECASE (SETQ FORM (CAR NEXT-INPUT))
                 (EOF (GO EOF))
                 (SECTION (GO COMMENTARY))
                 (START-CODE-MARKER
                  (SETF (SECTION-NAME SECTION) (SECTION-NAME FORM))
                  (GO LISP))
                 (T (PUSH FORM COMMENTARY)))))))
       LISP
        (CHECK-TYPE FORM START-CODE-MARKER)
        (WITH-MODE :LISP
          (LOOP
           (LET ((NEXT-INPUT
                  (READ-MAYBE-NOTHING-PRESERVING-WHITESPACE STREAM NIL EOF
                                                            NIL)))
             (WHEN NEXT-INPUT
               (TYPECASE (SETQ FORM (CAR NEXT-INPUT))
                 (EOF (GO EOF))
                 (SECTION (GO COMMENTARY))
                 (START-CODE-MARKER
                  (CERROR "Start a new unnamed section with no commentary."
                          'SECTION-LACKS-COMMENTARY :STREAM STREAM)
                  (SETQ FORM (MAKE-INSTANCE 'SECTION))
                  (PUSH (FINISH-SECTION SECTION COMMENTARY CODE) SECTIONS)
                  (CHECK-TYPE FORM SECTION)
                  (SETQ SECTION FORM
                        COMMENTARY 'NIL
                        CODE 'NIL))
                 (NEWLINE-MARKER (WHEN CODE (PUSH FORM CODE)))
                 (EVALUATED-FORM-MARKER
                  (LET ((FORM (MARKER-VALUE FORM)))
                    (LET ((*EVALUATING* T)
                          (*READTABLE* (READTABLE-FOR-MODE NIL)))
                      (EVAL (TANGLE FORM)))
                    (PUSH FORM CODE)))
                 (T (PUSH FORM CODE)))))))
       EOF
        (PUSH (FINISH-SECTION SECTION COMMENTARY CODE) SECTIONS)
        (RETURN (NREVERSE SECTIONS))))))
(DEFUN TANGLE-1 (FORM &KEY (EXPAND-NAMED-SECTIONS T))
  (FLET ((TANGLE-1 (FORM)
           (TANGLE-1 FORM :EXPAND-NAMED-SECTIONS EXPAND-NAMED-SECTIONS)))
    (TYPECASE FORM
      (MARKER (VALUES (MARKER-VALUE FORM) T))
      (NAMED-SECTION
       (IF EXPAND-NAMED-SECTIONS
           (VALUES (SECTION-CODE FORM) T)
           (VALUES FORM NIL)))
      (ATOM (VALUES FORM NIL))
      ((CONS NAMED-SECTION *)
       (MULTIPLE-VALUE-BIND (D CDR-EXPANDED-P)
           (TANGLE-1 (CDR FORM))
         (IF EXPAND-NAMED-SECTIONS
             (VALUES (APPEND (SECTION-CODE (CAR FORM)) D) T)
             (VALUES (CONS (CAR FORM) D) CDR-EXPANDED-P))))
      ((CONS MARKER *)
       (VALUES
        (IF (MARKER-BOUNDP (CAR FORM))
            (CONS (MARKER-VALUE (CAR FORM)) (TANGLE-1 (CDR FORM)))
            (TANGLE-1 (CDR FORM)))
        T))
      (T
       (MULTIPLE-VALUE-BIND (A CAR-EXPANDED-P)
           (TANGLE-1 (CAR FORM))
         (MULTIPLE-VALUE-BIND (D CDR-EXPANDED-P)
             (TANGLE-1 (CDR FORM))
           (VALUES
            (IF (AND (EQL A (CAR FORM)) (EQL D (CDR FORM)))
                FORM
                (CONS A D))
            (OR CAR-EXPANDED-P CDR-EXPANDED-P))))))))
(DEFUN TANGLE (FORM &KEY (EXPAND-NAMED-SECTIONS T))
  (LABELS ((EXPAND (FORM EXPANDED)
             (MULTIPLE-VALUE-BIND (NEW-FORM NEWLY-EXPANDED-P)
                 (TANGLE-1 FORM :EXPAND-NAMED-SECTIONS EXPAND-NAMED-SECTIONS)
               (IF NEWLY-EXPANDED-P
                   (EXPAND NEW-FORM T)
                   (VALUES NEW-FORM EXPANDED)))))
    (EXPAND FORM NIL)))
(DEFUN UNNAMED-SECTION-CODE-PARTS (SECTIONS)
  (MAPAPPEND #'SECTION-CODE (COERCE (REMOVE-IF #'SECTION-NAME SECTIONS) 'LIST)))
(DEFUN LOAD-WEB-FROM-STREAM
       (STREAM PRINT
        &KEY (APPEND T)
        &AUX (*READTABLE* *READTABLE*) (*PACKAGE* *PACKAGE*) (*EVALUATING* T))
  (DOLIST
      (FORM
       (TANGLE
        (UNNAMED-SECTION-CODE-PARTS (READ-SECTIONS STREAM :APPEND APPEND)))
       T)
    (IF PRINT
        (LET ((RESULTS (MULTIPLE-VALUE-LIST (EVAL FORM))))
          (FORMAT T "~&; ~{~S~^, ~}~%" RESULTS))
        (EVAL FORM))))
(DEFUN LOAD-WEB
       (FILESPEC
        &KEY (VERBOSE *LOAD-VERBOSE*) (PRINT *LOAD-PRINT*)
        (IF-DOES-NOT-EXIST T) (EXTERNAL-FORMAT :DEFAULT))
  "Load the web given by FILESPEC into the Lisp environment."
  (SETF (FILL-POINTER *SECTIONS*) 0)
  (SETF *CURRENT-SECTION* NIL)
  (SETF (FILL-POINTER *TEST-SECTIONS*) 0)
  (SETQ *NAMED-SECTIONS* NIL)
  (SETQ *INDEX-PACKAGES* NIL)
  (SETQ *INDEX* (MAKE-INDEX))
  (SETQ *REFERRING-CLASSES* 'NIL)
  (WHEN VERBOSE (FORMAT T "~&; loading WEB from ~S~%" FILESPEC))
  (IF (STREAMP FILESPEC)
      (LOAD-WEB-FROM-STREAM FILESPEC PRINT)
      (WITH-OPEN-FILE
          (STREAM (INPUT-FILE-PATHNAME FILESPEC) :DIRECTION :INPUT
           :EXTERNAL-FORMAT EXTERNAL-FORMAT :IF-DOES-NOT-EXIST
           (IF IF-DOES-NOT-EXIST
               :ERROR
               NIL))
        (LOAD-WEB-FROM-STREAM STREAM PRINT))))
(DEFUN LOAD-SECTIONS-FROM-TEMP-FILE (FILE APPEND &AUX (FILE (PROBE-FILE FILE)))
  "Load web sections from FILE, then delete it. If APPEND is true, named
section definitions in FILE will be appended to existing definitions;
otherwise, they will replace them."
  (WHEN FILE
    (UNWIND-PROTECT
        (WITH-OPEN-FILE (STREAM FILE :DIRECTION :INPUT)
          (LOAD-WEB-FROM-STREAM STREAM T :APPEND APPEND))
      (DELETE-FILE FILE))))
(DEFUN TANGLE-FILE
       (INPUT-FILE
        &REST ARGS
        &KEY OUTPUT-FILE TESTS-FILE (VERBOSE *COMPILE-VERBOSE*)
        (PRINT *COMPILE-PRINT*)
        (IF-EXISTS #+:SBCL :supersede #-:SBCL :new-version) (COMPILE-FILE T)
        (COMPILE-TESTS-FILE *COMPILE-TESTS-FILE*) (EXTERNAL-FORMAT :DEFAULT)
        &ALLOW-OTHER-KEYS
        &AUX (INPUT-FILE (INPUT-FILE-PATHNAME INPUT-FILE))
        (READTABLE *READTABLE*) (PACKAGE *PACKAGE*))
  "Tangle and compile the web in INPUT-FILE, producing OUTPUT-FILE."
  (DECLARE (IGNORABLE OUTPUT-FILE TESTS-FILE))
  (MULTIPLE-VALUE-BIND (OUTPUT-FILE LISP-FILE TESTS-OUTPUT-FILE TESTS-FILE)
      (APPLY #'TANGLE-FILE-PATHNAMES INPUT-FILE ARGS)
    (WITH-STANDARD-IO-SYNTAX
     (LET* ((*READTABLE* READTABLE)
            (*PACKAGE* PACKAGE)
            (*PRINT-READABLY* NIL)
            (*TANGLE-FILE-PATHNAME* INPUT-FILE)
            (*TANGLE-FILE-TRUENAME* (TRUENAME *TANGLE-FILE-PATHNAME*)))
       (WHEN VERBOSE (FORMAT T "~&; tangling web from ~A:~%" INPUT-FILE))
       (SETF (FILL-POINTER *SECTIONS*) 0)
       (SETF *CURRENT-SECTION* NIL)
       (SETF (FILL-POINTER *TEST-SECTIONS*) 0)
       (SETQ *NAMED-SECTIONS* NIL)
       (SETQ *INDEX-PACKAGES* NIL)
       (SETQ *INDEX* (MAKE-INDEX))
       (SETQ *REFERRING-CLASSES* 'NIL)
       (WITH-OPEN-FILE
           (INPUT INPUT-FILE :DIRECTION :INPUT :EXTERNAL-FORMAT
            EXTERNAL-FORMAT)
         (READ-SECTIONS INPUT))
       (LET ((UNUSED-SECTIONS 'NIL))
         (FLET ((NOTE-UNUSED-SECTION (SECTION)
                  (WHEN (NULL (USED-BY SECTION))
                    (PUSH SECTION UNUSED-SECTIONS))))
           (MAP-BST #'NOTE-UNUSED-SECTION *NAMED-SECTIONS*)
           (MAP NIL
                (LAMBDA (SECTION)
                  (WARN 'UNUSED-NAMED-SECTION-WARNING :FORMAT-CONTROL
                        "Unused named section <~A>." :FORMAT-ARGUMENTS
                        (LIST (SECTION-NAME SECTION))))
                (SORT UNUSED-SECTIONS #'< :KEY #'SECTION-NUMBER))))
       (MAP-BST #'SECTION-NUMBER *NAMED-SECTIONS*)
       (COND
        ((AND TESTS-FILE (> (LENGTH *TEST-SECTIONS*) 1))
         (WHEN VERBOSE (FORMAT T "~&; writing tests to ~A~%" TESTS-FILE))
         (TANGLE-SECTIONS *TEST-SECTIONS* :INPUT-FILE INPUT-FILE :OUTPUT-FILE
                          TESTS-FILE :IF-EXISTS IF-EXISTS :EXTERNAL-FORMAT
                          EXTERNAL-FORMAT))
        (T (SETQ TESTS-FILE NIL)))
       (WHEN VERBOSE (FORMAT T "~&; writing tangled code to ~A~%" LISP-FILE))
       (TANGLE-SECTIONS *SECTIONS* :INPUT-FILE INPUT-FILE :OUTPUT-FILE
                        LISP-FILE :IF-EXISTS IF-EXISTS :EXTERNAL-FORMAT
                        EXTERNAL-FORMAT)
       (IF COMPILE-FILE
           (WITH-COMPILATION-UNIT NIL
             (MULTIPLE-VALUE-PROG1
                 (COMPILE-FILE LISP-FILE :OUTPUT-FILE OUTPUT-FILE :VERBOSE
                               VERBOSE :PRINT PRINT :EXTERNAL-FORMAT
                               EXTERNAL-FORMAT)
               (WHEN (AND TESTS-FILE COMPILE-TESTS-FILE)
                 (COMPILE-FILE TESTS-FILE :OUTPUT-FILE TESTS-OUTPUT-FILE
                               :VERBOSE VERBOSE :PRINT PRINT :EXTERNAL-FORMAT
                               EXTERNAL-FORMAT))))
           LISP-FILE)))))
(DEFUN TANGLE-SECTIONS
       (SECTIONS &KEY INPUT-FILE OUTPUT-FILE IF-EXISTS EXTERNAL-FORMAT)
  (WITH-OPEN-FILE
      (OUTPUT OUTPUT-FILE :DIRECTION :OUTPUT :IF-EXISTS IF-EXISTS
       :EXTERNAL-FORMAT EXTERNAL-FORMAT)
    (FORMAT OUTPUT ";;;; TANGLED WEB FROM \"~A\". DO NOT EDIT.~%"
            (ENOUGH-NAMESTRING INPUT-FILE))
    (LET ((*EVALUATING* NIL)
          (*PRINT-PPRINT-DISPATCH* *TANGLE-PPRINT-DISPATCH*)
          (*PRINT-READABLY* NIL))
      (FORMAT OUTPUT "#+ALLEGRO~
         ~&(EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL)~
         ~&  (SETQ EXCL:*SOURCE-PATHNAME* ~S))~%"
              (ENOUGH-NAMESTRING *TANGLE-FILE-PATHNAME*))
      (DOLIST (FORM (TANGLE (UNNAMED-SECTION-CODE-PARTS SECTIONS)))
        (PPRINT FORM OUTPUT)))))
(DEFUN WEAVE
       (INPUT-FILE
        &REST ARGS
        &KEY OUTPUT-FILE TESTS-FILE INDEX-FILE (VERBOSE *WEAVE-VERBOSE*)
        (PRINT *WEAVE-PRINT*)
        ((:SOURCE-LOCATIONS *WEAVE-SOURCE-LOCATIONS*) *WEAVE-SOURCE-LOCATIONS*)
        (EXTERNAL-FORMAT :DEFAULT)
        &AUX (INPUT-FILE (INPUT-FILE-PATHNAME INPUT-FILE))
        (READTABLE *READTABLE*) (PACKAGE *PACKAGE*))
  "Weave the web contained in INPUT-FILE, producing the TeX file OUTPUT-FILE."
  (DECLARE (IGNORABLE OUTPUT-FILE TESTS-FILE INDEX-FILE))
  (MULTIPLE-VALUE-BIND (OUTPUT-FILE INDEX-FILE SECTIONS-FILE)
      (APPLY #'WEAVE-PATHNAMES INPUT-FILE ARGS)
    (WITH-STANDARD-IO-SYNTAX
     (LET ((*READTABLE* READTABLE) (*PACKAGE* PACKAGE) (*PRINT-READABLY* NIL))
       (WHEN VERBOSE (FORMAT T "~&; weaving web from ~A:~%" INPUT-FILE))
       (SETF (FILL-POINTER *SECTIONS*) 0)
       (SETF *CURRENT-SECTION* NIL)
       (SETF (FILL-POINTER *TEST-SECTIONS*) 0)
       (SETQ *NAMED-SECTIONS* NIL)
       (SETQ *INDEX-PACKAGES* NIL)
       (SETQ *INDEX* (MAKE-INDEX))
       (SETQ *REFERRING-CLASSES* 'NIL)
       (WITH-OPEN-FILE
           (INPUT INPUT-FILE :DIRECTION :INPUT :EXTERNAL-FORMAT
            EXTERNAL-FORMAT)
         (READ-SECTIONS INPUT))
       (LET ((TESTS-FILE
              (APPLY #'TESTS-FILE-PATHNAME INPUT-FILE :OUTPUT-FILE OUTPUT-FILE
                     ARGS)))
         (WHEN (AND TESTS-FILE (> (LENGTH *TEST-SECTIONS*) 1))
           (WHEN VERBOSE (FORMAT T "~&; weaving tests to ~A~%" TESTS-FILE))
           (MULTIPLE-VALUE-BIND (OUTPUT-FILE INDEX-FILE SECTIONS-FILE)
               (APPLY #'WEAVE-PATHNAMES INPUT-FILE :OUTPUT-FILE TESTS-FILE
                      ARGS)
             (WHEN INDEX-FILE
               (LET ((OUTPUT-FILE-NAME
                      (MAKE-PATHNAME :NAME (PATHNAME-NAME OUTPUT-FILE))))
                 (SETQ INDEX-FILE (MERGE-PATHNAMES OUTPUT-FILE-NAME INDEX-FILE)
                       SECTIONS-FILE
                         (MERGE-PATHNAMES OUTPUT-FILE-NAME SECTIONS-FILE))))
             (WEAVE-SECTIONS *TEST-SECTIONS* :INPUT-FILE INPUT-FILE
                             :OUTPUT-FILE OUTPUT-FILE :INDEX-FILE INDEX-FILE
                             :SECTIONS-FILE SECTIONS-FILE :VERBOSE VERBOSE
                             :PRINT PRINT :EXTERNAL-FORMAT EXTERNAL-FORMAT
                             :WEAVING-TESTS T))))
       (WHEN VERBOSE (FORMAT T "~&; weaving sections to ~A~%" OUTPUT-FILE))
       (WEAVE-SECTIONS *SECTIONS* :INPUT-FILE INPUT-FILE :OUTPUT-FILE
                       OUTPUT-FILE :INDEX-FILE INDEX-FILE :SECTIONS-FILE
                       SECTIONS-FILE :VERBOSE VERBOSE :PRINT PRINT
                       :EXTERNAL-FORMAT EXTERNAL-FORMAT)))))
(DEFUN WEAVE-SECTIONS
       (SECTIONS
        &KEY INPUT-FILE OUTPUT-FILE INDEX-FILE SECTIONS-FILE WEAVING-TESTS
        VERBOSE PRINT (IF-EXISTS #+:SBCL :supersede #-:SBCL :new-version)
        EXTERNAL-FORMAT)
  (MACROLET ((WITH-OUTPUT-FILE ((STREAM FILESPEC) &BODY BODY)
               `(WITH-OPEN-FILE
                    (,STREAM ,FILESPEC :DIRECTION :OUTPUT :EXTERNAL-FORMAT
                     EXTERNAL-FORMAT :IF-EXISTS IF-EXISTS)
                  ,@BODY)))
    (WITH-OUTPUT-FILE (OUT OUTPUT-FILE) (FORMAT OUT "\\input clwebmac~%")
     (WHEN WEAVING-TESTS
       (FORMAT OUT "\\def\\progname{~/clweb::print-escaped/}~%"
               (IF INPUT-FILE
                   (STRING-CAPITALIZE (PATHNAME-NAME INPUT-FILE))
                   "program")))
     (IF PRINT
         (FLET ((WEAVE-SECTION (SECTION)
                  (FORMAT T "~:[~;*~]~D" (STARRED-SECTION-P SECTION)
                          (SECTION-NUMBER SECTION))
                  (WEAVE-OBJECT SECTION OUT)))
           (PPRINT-LOGICAL-BLOCK
               (NIL (COERCE SECTIONS 'LIST) :PER-LINE-PREFIX ";  ")
             (WEAVE-SECTION (PPRINT-POP))
             (LOOP (PPRINT-EXIT-IF-LIST-EXHAUSTED)
                   (WRITE-CHAR #\ )
                   (PPRINT-NEWLINE :FILL)
                   (WEAVE-SECTION (PPRINT-POP)))))
         (MAP NIL (LAMBDA (SECTION) (WEAVE-OBJECT SECTION OUT)) SECTIONS))
     (WHEN INDEX-FILE
       (WHEN VERBOSE (FORMAT T "~&; writing the index to ~A~%" INDEX-FILE))
       (WITH-OUTPUT-FILE (IDX INDEX-FILE)
        (WEAVE-OBJECT
         (INDEX-SECTIONS SECTIONS :INDEX
                         (IF WEAVING-TESTS
                             (MAKE-INDEX)
                             *INDEX*))
         IDX))
       (WITH-OUTPUT-FILE (SCN SECTIONS-FILE)
        (MAP-BST
         (LAMBDA (SECTION)
           (UNLESS
               (EVERY
                (IF WEAVING-TESTS
                    (COMPLEMENT #'TEST-SECTION-P)
                    #'TEST-SECTION-P)
                (NAMED-SECTION-SECTIONS SECTION))
             (WEAVE-OBJECT (MAKE-SECTION-NAME-INDEX-ENTRY SECTION) SCN)))
         *NAMED-SECTIONS*))
       (FORMAT OUT "~&\\inx~%\\fin~%\\con~%"))
     (FORMAT OUT "~&\\end~%") (TRUENAME OUT))))
(DEFUN WEAVE-OBJECT (OBJECT STREAM)
  (WRITE OBJECT :STREAM STREAM :CASE :DOWNCASE :PRETTY T :PPRINT-DISPATCH
         *WEAVE-PPRINT-DISPATCH* :RIGHT-MARGIN 1000))
(DEFUN PRINT-TEX (STREAM TEX-MODE-MATERIAL &REST ARGS)
  (DECLARE (IGNORE ARGS))
  (DOLIST (X TEX-MODE-MATERIAL)
    (ETYPECASE X
      (STRING (WRITE-STRING X STREAM))
      (LIST (DOLIST (FORM X) (FORMAT STREAM "\\(~W\\)" FORM))))))
(DEFUN READ-TEX-FROM-STRING (INPUT-STRING)
  (WITH-MODE :RESTRICTED
    (WITH-INPUT-FROM-STRING (STREAM INPUT-STRING)
      (LOOP FOR TEXT = (SNARF-UNTIL-CONTROL-CHAR STREAM #\|)
            FOR FORMS = (READ-PRESERVING-WHITESPACE STREAM NIL EOF NIL)
            IF (PLUSP (LENGTH TEXT))
            COLLECT TEXT
            IF (EOF-P FORMS)
            DO (LOOP-FINISH) ELSE
            COLLECT FORMS))))
(DEFUN PRINT-LIMBO (STREAM SECTION)
  (LET ((COMMENTARY (SECTION-COMMENTARY SECTION)))
    (WHEN COMMENTARY (PRINT-TEX STREAM COMMENTARY) (TERPRI STREAM))))
(SET-WEAVE-DISPATCH 'LIMBO-SECTION #'PRINT-LIMBO 1)
(DEFUN PRINT-SECTION (STREAM SECTION)
  (FORMAT STREAM "~&~:[~*~;~@[\\SL~W~]~%~]\\~:[M~*~;N{~D}~]{~D}"
          *WEAVE-SOURCE-LOCATIONS* (SECTION-SOURCE-LOCATION SECTION)
          (STARRED-SECTION-P SECTION) (SECTION-DEPTH SECTION)
          (SECTION-NUMBER SECTION))
  (LET* ((COMMENTARY (SECTION-COMMENTARY SECTION))
         (NAME (SECTION-NAME SECTION))
         (NAMED-SECTION (AND NAME (FIND-SECTION NAME)))
         (CODE (SECTION-CODE SECTION))
         (TEST-SECTION-P (TYPEP SECTION 'TEST-SECTION)))
    (PRINT-TEX STREAM COMMENTARY)
    (COND ((AND COMMENTARY CODE) (FORMAT STREAM "~&\\Y\\B~%"))
          (CODE (FORMAT STREAM "~&\\B~%")))
    (WHEN NAMED-SECTION
      (PRINT-SECTION-NAME STREAM NAMED-SECTION)
      (FORMAT STREAM "${}~:[\\mathrel+~;~]\\E{}$\\6~%"
              (= (SECTION-NUMBER SECTION) (SECTION-NUMBER NAMED-SECTION))))
    (WHEN CODE
      (DOLIST (FORM CODE)
        (TYPECASE FORM
          (NEWLINE-MARKER (FORMAT STREAM "~W" FORM))
          (T (FORMAT STREAM "~@<\\+~@;~W~;\\cr~:>" FORM))))
      (FORMAT STREAM "~&\\egroup~%"))
    (WHEN
        (AND (NOT NAMED-SECTION) (TYPEP SECTION 'TEST-SECTION)
             (SECTION-CODE SECTION))
      (FORMAT STREAM "\\T~P~D.~%" (LENGTH (SECTION-CODE SECTION))
              (SECTION-NUMBER (TEST-FOR-SECTION SECTION))))
    (WHEN
        (AND NAMED-SECTION
             (= (SECTION-NUMBER SECTION) (SECTION-NUMBER NAMED-SECTION)))
      (FLET ((FILTER-XREF (XREF-SECTION)
               (OR (EQL XREF-SECTION SECTION)
                   (IF TEST-SECTION-P
                       NIL
                       (TYPEP XREF-SECTION 'TEST-SECTION)))))
        (PRINT-XREFS STREAM #\A
                     (REMOVE-IF #'FILTER-XREF
                                (NAMED-SECTION-SECTIONS NAMED-SECTION)))
        (PRINT-XREFS STREAM #\U
                     (REMOVE-IF #'FILTER-XREF (USED-BY NAMED-SECTION)))
        (PRINT-XREFS STREAM #\Q
                     (REMOVE-IF #'FILTER-XREF (CITED-BY NAMED-SECTION))))))
  (FORMAT STREAM "~&\\fi~%"))
(SET-WEAVE-DISPATCH 'SECTION #'PRINT-SECTION)
(DEFUN PRINT-SOURCE-LOCATION (STREAM SOURCE-LOCATION)
  (FORMAT STREAM "[~D ~A]" (SOURCE-LOCATION-LINENO SOURCE-LOCATION)
          (FILE-NAMESTRING (SOURCE-LOCATION-FILE SOURCE-LOCATION))))
(SET-WEAVE-DISPATCH 'SOURCE-LOCATION #'PRINT-SOURCE-LOCATION)
(DEFUN PRINT-XREFS (STREAM KIND XREFS)
  (WHEN XREFS
    (FORMAT STREAM
            "\\~C~{~#[~;~D~;s ~D\\ET~D~:;s~@{~#[~;\\ETs~D~;~D~:;~D, ~]~}~]~}.~%"
            KIND (SORT (MAPCAR #'SECTION-NUMBER XREFS) #'<))))
(DEFUN PRINT-SECTION-NAME (STREAM SECTION &KEY (INDEXING NIL))
  (FORMAT STREAM "~:[~;\\I~]\\X~{~D~^, ~}:~/clweb::print-TeX/\\X" INDEXING
          (IF INDEXING
              (SORT (MAPCAR #'SECTION-NUMBER (NAMED-SECTION-SECTIONS SECTION))
                    #'<)
              (LIST (SECTION-NUMBER SECTION)))
          (READ-TEX-FROM-STRING (SECTION-NAME SECTION))))
(SET-WEAVE-DISPATCH 'NAMED-SECTION #'PRINT-SECTION-NAME)
(DEFCLASS SECTION-NAME-INDEX-ENTRY NIL
          ((NAMED-SECTION :ACCESSOR NAMED-SECTION :INITARG :NAMED-SECTION)))
(DEFUN MAKE-SECTION-NAME-INDEX-ENTRY (SECTION)
  (MAKE-INSTANCE 'SECTION-NAME-INDEX-ENTRY :NAMED-SECTION SECTION))
(SET-WEAVE-DISPATCH 'SECTION-NAME-INDEX-ENTRY
                    (LAMBDA
                        (STREAM SECTION-NAME
                         &AUX (SECTION (NAMED-SECTION SECTION-NAME)))
                      (PRINT-SECTION-NAME STREAM SECTION :INDEXING T)
                      (TERPRI STREAM)
                      (PRINT-XREFS STREAM #\U
                                   (REMOVE SECTION (USED-BY SECTION)))
                      (PRINT-XREFS STREAM #\Q
                                   (REMOVE SECTION (CITED-BY SECTION)))))
(DEFPARAMETER *PRINT-ESCAPE-LIST*
  '((" \\%&#$^_" . #\\) ("~" . "$\\sim$") ("{" . "$\\{$") ("}" . "$\\}$")
    ("<" . "$<$") (">" . "$>$")))
(DEFUN PRINT-ESCAPED
       (STREAM STRING
        &REST ARGS
        &AUX
        (STREAM
         (CASE STREAM
           ((T) *TERMINAL-IO*)
           ((NIL) *STANDARD-OUTPUT*)
           (OTHERWISE STREAM))))
  (DECLARE (IGNORE ARGS))
  (LOOP FOR CHAR ACROSS STRING AS ESCAPE = (CDR
                                            (ASSOC CHAR *PRINT-ESCAPE-LIST*
                                                   :TEST #'FIND))
        IF ESCAPE
        DO (ETYPECASE ESCAPE
             (CHARACTER (WRITE-CHAR ESCAPE STREAM) (WRITE-CHAR CHAR STREAM))
             (STRING (WRITE-STRING ESCAPE STREAM))) ELSE
        DO (WRITE-CHAR CHAR STREAM)))
(DEFUN PRINT-STRING (STREAM STRING)
  (LOOP WITH *PRINT-ESCAPE-LIST* = `(("{*~}" . #\\) ("\\" . "\\\\\\\\")
                                     ("\"" . "\\\\\"") ,@*PRINT-ESCAPE-LIST*)
        FOR LAST = 0 THEN (IF (CHAR= (ELT STRING (1- NEWLINE)) #\~)
                              (POSITION-IF-NOT #'WHITESPACEP STRING :START
                                               NEWLINE)
                              (1+ NEWLINE))
        FOR NEWLINE = (POSITION #\Newline STRING :START LAST) AS LINE = (SUBSEQ
                                                                         STRING
                                                                         LAST
                                                                         NEWLINE)
        DO (FORMAT STREAM
                   "~:[~;\\.{~]~:[~;\"~]~/clweb::print-escaped/~:[~;\"~]~:[~;}~]"
                   *PRINT-ESCAPE* (AND *PRINT-ESCAPE* (ZEROP LAST)) LINE
                   (AND *PRINT-ESCAPE* (NULL NEWLINE)) *PRINT-ESCAPE*)
        WHILE NEWLINE
        DO (FORMAT STREAM "\\cr~:@_")))
(SET-WEAVE-DISPATCH 'STRING #'PRINT-STRING)
(DEFUN PRINT-CHAR (STREAM CHAR)
  (LET ((GRAPHICP (AND (GRAPHIC-CHAR-P CHAR) (STANDARD-CHAR-P CHAR)))
        (NAME (CHAR-NAME CHAR))
        (*PRINT-ESCAPE-LIST* `(("{~}" . #\\) ,@*PRINT-ESCAPE-LIST*)))
    (FORMAT STREAM "\\#\\CH{~/clweb::print-escaped/}"
            (IF (AND NAME (NOT GRAPHICP))
                NAME
                (STRING CHAR)))
    CHAR))
(SET-WEAVE-DISPATCH 'CHARACTER #'PRINT-CHAR)
(SET-WEAVE-DISPATCH '(CONS (EQL FUNCTION))
                    (LAMBDA (STREAM OBJ) (FORMAT STREAM "(~{~W~^ ~})" OBJ)) 1)
(DEFUN PRINT-SYMBOL (STREAM SYMBOL)
  (FLET ((PRINT-CASE (STRING)
           (FUNCALL
            (ECASE *PRINT-CASE*
              (:UPCASE #'STRING-UPCASE)
              (:DOWNCASE #'STRING-DOWNCASE)
              (:CAPITALIZE #'STRING-CAPITALIZE))
            STRING)))
    (LET* ((GROUP-P
            (COND
             ((MEMBER SYMBOL LAMBDA-LIST-KEYWORDS)
              (WRITE-STRING "\\K{" STREAM))
             ((KEYWORDP SYMBOL) (WRITE-STRING "\\:{" STREAM))))
           (SYMBOL-NAME (SYMBOL-NAME SYMBOL))
           (PACKAGE (SYMBOL-PACKAGE SYMBOL)))
      (COND ((KEYWORDP SYMBOL)) ((EQ PACKAGE *PACKAGE*))
            ((NULL PACKAGE) (WRITE-STRING "\\#:" STREAM))
            (T
             (MULTIPLE-VALUE-BIND (FOUND ACCESSIBLE)
                 (FIND-SYMBOL SYMBOL-NAME *PACKAGE*)
               (UNLESS (AND ACCESSIBLE (EQ FOUND SYMBOL))
                 (PRINT-ESCAPED STREAM (PRINT-CASE (PACKAGE-NAME PACKAGE)))
                 (CASE (NTH-VALUE 1 (FIND-SYMBOL SYMBOL-NAME PACKAGE))
                   (:EXTERNAL (WRITE-CHAR #\: STREAM))
                   (OTHERWISE (WRITE-STRING "::" STREAM)))))))
      (MULTIPLE-VALUE-BIND (PREFIX SUFFIX)
          (LOOP WITH LENGTH = (LENGTH SYMBOL-NAME)
                FOR (SUFFIX
                     . REPLACEMENT) IN *PRINT-SYMBOL-SUFFIXES* AS PREFIX-END = (MAX
                                                                                0
                                                                                (-
                                                                                 LENGTH
                                                                                 (LENGTH
                                                                                  SUFFIX)))
                WHEN (STRING= SYMBOL-NAME SUFFIX :START1 PREFIX-END)
                DO (RETURN
                    (VALUES (SUBSEQ SYMBOL-NAME 0 PREFIX-END) REPLACEMENT))
                FINALLY (RETURN SYMBOL-NAME))
        (PRINT-ESCAPED STREAM (PRINT-CASE PREFIX))
        (WHEN SUFFIX (WRITE-STRING SUFFIX STREAM)))
      (WHEN GROUP-P (WRITE-STRING "}" STREAM)))))
(SET-WEAVE-DISPATCH 'SYMBOL #'PRINT-SYMBOL)
(DEFUN WEAVE-SYMBOL-REPLACE (SYMBOL REPLACEMENT)
  (SET-WEAVE-DISPATCH `(EQL ,SYMBOL)
                      (LAMBDA (STREAM OBJ)
                        (DECLARE (IGNORE OBJ))
                        (WRITE-STRING REPLACEMENT STREAM))
                      1))
(WEAVE-SYMBOL-REPLACE 'LAMBDA "\\L")
(WEAVE-SYMBOL-REPLACE 'PI "$\\pi$")
(DEFCLASS LOGICAL-BLOCK NIL ((LIST :READER LOGICAL-BLOCK-LIST :INITARG :LIST)))
(DEFUN MAKE-LOGICAL-BLOCK (LIST) (MAKE-INSTANCE 'LOGICAL-BLOCK :LIST LIST))
(DEFUN ANALYZE-INDENTATION (LIST-MARKER)
  (DECLARE (TYPE LIST-MARKER LIST-MARKER))
  (LABELS ((FIND-NEXT-NEWLINE (LIST)
             (MEMBER-IF #'NEWLINEP LIST :KEY #'CAR))
           (NEXT-LOGICAL-BLOCK (LIST)
             (DO* ((BLOCK 'NIL)
                   (BLOCK-INDENT (CDAR LIST))
                   (INDENT BLOCK-INDENT)
                   (NEWLINE (FIND-NEXT-NEWLINE LIST))
                   (NEXT-INDENT (CDADR NEWLINE)))
                  ((OR (ENDP LIST)
                       (AND (EQ LIST NEWLINE) NEXT-INDENT
                            (< 0 NEXT-INDENT BLOCK-INDENT)))
                   (VALUES
                    (IF (NOTANY #'NEWLINEP BLOCK)
                        (NREVERSE BLOCK)
                        (MAKE-LOGICAL-BLOCK (NREVERSE BLOCK)))
                    LIST))
               (IF (AND INDENT NEXT-INDENT (> NEXT-INDENT INDENT)
                        (= NEXT-INDENT (CDAR LIST)))
                   (MULTIPLE-VALUE-BIND (SUB-BLOCK TAIL)
                       (NEXT-LOGICAL-BLOCK LIST)
                     (CHECK-TYPE (CAAR TAIL) (OR NEWLINE-MARKER NULL))
                     (PUSH SUB-BLOCK BLOCK)
                     (SETQ LIST TAIL))
                   (LET ((NEXT (CAR (POP LIST))))
                     (PUSH NEXT BLOCK)
                     (WHEN (AND LIST (NEWLINEP NEXT))
                       (SETF INDENT (CDAR LIST)
                             (INDENTATION NEXT) (- INDENT BLOCK-INDENT)
                             NEWLINE (FIND-NEXT-NEWLINE LIST)
                             NEXT-INDENT (CDADR NEWLINE))))))))
    (ASSERT
     (= (LENGTH (LIST-MARKER-LIST LIST-MARKER))
        (LENGTH (LIST-MARKER-CHARPOS LIST-MARKER)))
     ((LIST-MARKER-LIST LIST-MARKER) (LIST-MARKER-CHARPOS LIST-MARKER))
     "List marker's list and charpos-list aren't the same length.")
    (NEXT-LOGICAL-BLOCK
     (MAPCAR #'CONS (LIST-MARKER-LIST LIST-MARKER)
             (LIST-MARKER-CHARPOS LIST-MARKER)))))
(DEFUN PRINT-LIST (STREAM LIST-MARKER)
  (LET ((BLOCK (ANALYZE-INDENTATION LIST-MARKER)))
    (ETYPECASE BLOCK
      (LIST (FORMAT STREAM "~<(~;~@{~W~^ ~}~;)~:>" BLOCK))
      (LOGICAL-BLOCK (FORMAT STREAM "(~W)" BLOCK)))))
(SET-WEAVE-DISPATCH 'LIST-MARKER #'PRINT-LIST)
(DEFUN PRINT-LOGICAL-BLOCK (STREAM BLOCK)
  (WRITE-STRING "\\!" STREAM)
  (PPRINT-LOGICAL-BLOCK
      (STREAM (LOGICAL-BLOCK-LIST BLOCK) :PER-LINE-PREFIX "&")
    (DO (INDENT
         NEXT
         (OBJ (PPRINT-POP) NEXT))
        (NIL)
      (COND
       ((NEWLINEP OBJ)
        (FORMAT STREAM "\\cr~:[~;\\Y~]~:@_" (TYPEP OBJ 'PAR-MARKER))
        (SETQ INDENT (INDENTATION OBJ)) (PPRINT-EXIT-IF-LIST-EXHAUSTED)
        (SETQ NEXT (PPRINT-POP)))
       (T (FORMAT STREAM "~@[~[~;\\1~;\\1~:;\\2~]~]~W" INDENT OBJ)
        (SETQ INDENT NIL) (PPRINT-EXIT-IF-LIST-EXHAUSTED)
        (SETQ NEXT (PPRINT-POP))
        (UNLESS (NEWLINEP NEXT) (WRITE-CHAR #\  STREAM)))))))
(SET-WEAVE-DISPATCH 'LOGICAL-BLOCK #'PRINT-LOGICAL-BLOCK)
(SET-WEAVE-DISPATCH 'NEWLINE-MARKER
                    (LAMBDA (STREAM OBJ)
                      (DECLARE (IGNORE OBJ))
                      (TERPRI STREAM)))
(SET-WEAVE-DISPATCH 'PAR-MARKER
                    (LAMBDA (STREAM OBJ)
                      (DECLARE (IGNORE OBJ))
                      (FORMAT STREAM "~&\\Y~%"))
                    1)
(SET-WEAVE-DISPATCH 'EMPTY-LIST-MARKER
                    (LAMBDA (STREAM OBJ)
                      (DECLARE (IGNORE OBJ))
                      (WRITE-STRING "()" STREAM)))
(SET-WEAVE-DISPATCH 'CONSING-DOT-MARKER
                    (LAMBDA (STREAM OBJ)
                      (DECLARE (IGNORE OBJ))
                      (WRITE-CHAR #\. STREAM)))
(SET-WEAVE-DISPATCH 'QUOTE-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\'~W" (QUOTED-FORM OBJ))))
(SET-WEAVE-DISPATCH 'COMMENT-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\C{~/clweb::print-TeX/}"
                              (READ-TEX-FROM-STRING (COMMENT-TEXT OBJ)))))
(SET-WEAVE-DISPATCH 'BACKQUOTE-FORM
                    (LAMBDA (STREAM OBJ) (FORMAT STREAM "\\`~W" (CADR OBJ))))
(SET-WEAVE-DISPATCH 'COMMA
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\CO{~@[~C~]}~W" (COMMA-MODIFIER OBJ)
                              (COMMA-FORM OBJ :TANGLE NIL))))
(SET-WEAVE-DISPATCH 'FUNCTION-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\#\\'~S" (QUOTED-FORM OBJ)))
                    1)
(SET-WEAVE-DISPATCH 'SIMPLE-VECTOR-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\#~@[~D~]~W"
                              (AND (SLOT-BOUNDP OBJ 'LENGTH)
                                   (SLOT-VALUE OBJ 'LENGTH))
                              (SLOT-VALUE OBJ 'ELEMENTS))))
(SET-WEAVE-DISPATCH 'BIT-VECTOR-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\#~@[~D~]*~{~[0~;1~]~}"
                              (AND (SLOT-BOUNDP OBJ 'LENGTH)
                                   (SLOT-VALUE OBJ 'LENGTH))
                              (MAP 'LIST #'IDENTITY
                                   (SLOT-VALUE OBJ 'ELEMENTS))))
                    1)
(SET-WEAVE-DISPATCH 'READ-TIME-EVAL-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\#.~W" (READ-TIME-EVAL-FORM OBJ))))
(SET-WEAVE-DISPATCH 'RADIX-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "$~VR_{~2:*~D}$" (RADIX-MARKER-BASE OBJ)
                              (MARKER-VALUE OBJ))))
(SET-WEAVE-DISPATCH 'COMPLEX-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\#C\\/~W" (COMPLEX-COMPONENTS OBJ))))
(SET-WEAVE-DISPATCH 'ARRAY-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\#~D\\/A~W" (ARRAY-MARKER-RANK OBJ)
                              (ARRAY-MARKER-INITIAL-CONTENTS OBJ))))
(SET-WEAVE-DISPATCH 'STRUCTURE-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\#S\\/~W" (STRUCTURE-MARKER-FORM OBJ))))
(SET-WEAVE-DISPATCH 'PATHNAME-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\#P\\/~W"
                              (PATHNAME-MARKER-NAMESTRING OBJ))))
(SET-WEAVE-DISPATCH 'READ-TIME-CONDITIONAL-MARKER
                    (LAMBDA (STREAM OBJ)
                      (LET* ((FORM (READ-TIME-CONDITIONAL-FORM OBJ))
                             (LINES
                              (LOOP WITH INDENT = (IF (CHAR= (ELT FORM 0)
                                                             #\Newline)
                                                      (1-
                                                       (POSITION-IF-NOT
                                                        #'WHITESPACEP FORM
                                                        :START 1))
                                                      0)
                                    FOR LAST = 0 THEN (+ INDENT NEWLINE 1)
                                    FOR NEWLINE = (POSITION #\Newline FORM
                                                            :START
                                                            LAST) AS LINE = (SUBSEQ
                                                                             FORM
                                                                             LAST
                                                                             NEWLINE)
                                    COLLECT LINE
                                    WHILE NEWLINE))
                             (*PRINT-ESCAPE-LIST*
                              `((" " . " ") ,@*PRINT-ESCAPE-LIST*)))
                        (FLET ((PRINT-RC-PREFIX ()
                                 (FORMAT STREAM "\\#$~:[-~;+~]$~S"
                                         (READ-TIME-CONDITIONAL-PLUSP OBJ)
                                         (READ-TIME-CONDITIONAL-TEST OBJ)))
                               (PRINT-RC-LINE (LINE)
                                 (FORMAT STREAM "\\RC{~/clweb::print-escaped/}"
                                         LINE)))
                          (COND
                           ((= (LENGTH LINES) 1) (PRINT-RC-PREFIX)
                            (PRINT-RC-LINE (FIRST LINES)))
                           (T (WRITE-STRING "\\!" STREAM)
                            (PPRINT-LOGICAL-BLOCK
                                (STREAM LINES :PER-LINE-PREFIX "&")
                              (PRINT-RC-PREFIX)
                              (PPRINT-EXIT-IF-LIST-EXHAUSTED)
                              (LOOP FOR LINE = (PPRINT-POP)
                                    WHEN (PLUSP (LENGTH LINE))
                                    DO (PRINT-RC-LINE LINE)
                                    DO (PPRINT-EXIT-IF-LIST-EXHAUSTED) (FORMAT
                                                                        STREAM
                                                                        "\\cr~:@_")))))))))
(DEFUN ENSURE-PORTABLE-WALKING-ENVIRONMENT (ENV)
  #+:ALLEGRO (sys:ensure-portable-walking-environment env)
  #-:ALLEGRO env)
(DEFUN ENCLOSE
       (LAMBDA-EXPRESSION &OPTIONAL ENV (WALKER (MAKE-INSTANCE 'WALKER)))
  (COERCE (WALK-LAMBDA-EXPRESSION WALKER LAMBDA-EXPRESSION NIL ENV) 'FUNCTION))
#+:ALLEGRO
(defun parse-macro (name lambda-list body &optional env)
  (declare (ignorable name lambda-list body env))
  (excl::defmacro-expander `(,name ,lambda-list ,@body) env))
(DEFMACRO REORDER-ENV-INFORMATION (FN ORIG)
  `(DEFUN ,FN (&REST ARGS)
     (MULTIPLE-VALUE-BIND (TYPE LOCATIVE DECLARATIONS LOCAL)
         (APPLY ,ORIG ARGS)
       (DECLARE (IGNORE LOCATIVE))
       (VALUES TYPE LOCAL DECLARATIONS))))
#+:ALLEGRO
(reorder-env-information variable-information #'sys:variable-information)
#+:ALLEGRO
(reorder-env-information function-information #'sys:function-information)
(DEFCLASS WALK-CONTEXT NIL NIL)
(DEFUN MAKE-CONTEXT (CONTEXT &REST ARGS) (APPLY #'MAKE-INSTANCE CONTEXT ARGS))
(DEFCLASS NAMESPACE (WALK-CONTEXT)
          ((NAME :READER NAMESPACE-NAME :INITFORM NIL :ALLOCATION :CLASS)
           (LOCAL :READER LOCAL-BINDING-P :INITARG :LOCAL :TYPE BOOLEAN))
          (:DEFAULT-INITARGS :LOCAL NIL))
(DEFPARAMETER *NAMESPACE-CLASSES* (MAKE-HASH-TABLE :TEST 'EQ))
(DEFUN (SETF FIND-NAMESPACE-CLASS) (CLASS NAMESPACE-NAME)
  (SETF (GETHASH NAMESPACE-NAME *NAMESPACE-CLASSES*) CLASS))
(DEFUN FIND-NAMESPACE-CLASS (NAMESPACE-NAME)
  (FLET ((READ-NAMESPACE-CLASS-NAME ()
           (LOOP (FORMAT *QUERY-IO* "Enter a namespace class name: ")
                 (LET ((CLASS (FIND-CLASS (READ *QUERY-IO*) NIL)))
                   (WHEN (AND CLASS (SUBTYPEP CLASS 'NAMESPACE))
                     (RETURN (LIST CLASS)))))))
    (RESTART-CASE (OR (GETHASH NAMESPACE-NAME *NAMESPACE-CLASSES*)
                      (ERROR "Can't find namespace class for namespace ~S."
                             NAMESPACE-NAME))
      (USE-VALUE (VALUE) :REPORT "Specify a class to use this time."
                 :INTERACTIVE READ-NAMESPACE-CLASS-NAME VALUE)
      (STORE-VALUE (VALUE) :REPORT
                   "Specify a class to store and use in the future."
                   :INTERACTIVE READ-NAMESPACE-CLASS-NAME
                   (SETF (FIND-NAMESPACE-CLASS NAMESPACE-NAME) VALUE)))))
(DEFMACRO DEFNAMESPACE
          (CLASS-NAME (&REST SUPERS) &OPTIONAL NAMESPACE-NAME OTHER-SLOT-SPECS)
  `(PROGN
    (DEFCLASS ,CLASS-NAME ,(OR SUPERS '(NAMESPACE))
              (,@(WHEN NAMESPACE-NAME
                   `((NAME :INITFORM ',NAMESPACE-NAME :ALLOCATION :CLASS)))
               ,@OTHER-SLOT-SPECS))
    ,@(WHEN NAMESPACE-NAME
        `((SETF (FIND-NAMESPACE-CLASS ',NAMESPACE-NAME)
                  (FIND-CLASS ',CLASS-NAME))))))
(DEFNAMESPACE VARIABLE-NAME NIL :VARIABLE)
(DEFNAMESPACE LEXICAL-VARIABLE-NAME (VARIABLE-NAME) :LEXICAL)
(DEFNAMESPACE SPECIAL-VARIABLE-NAME (VARIABLE-NAME) :SPECIAL)
(DEFNAMESPACE CONSTANT-NAME NIL :CONSTANT)
(DEFNAMESPACE SYMBOL-MACRO-NAME NIL :SYMBOL-MACRO)
(DEFNAMESPACE OPERATOR NIL :OPERATOR)
(DEFNAMESPACE FUNCTION-NAME (OPERATOR) :FUNCTION)
(DEFNAMESPACE SETF-FUNCTION-NAME (FUNCTION-NAME) :SETF-FUNCTION)
(DEFNAMESPACE MACRO-NAME (OPERATOR) :MACRO)
(DEFNAMESPACE COMPILER-MACRO-NAME (OPERATOR) :COMPILER-MACRO)
(DEFNAMESPACE SPECIAL-OPERATOR (OPERATOR) :SPECIAL-FORM)
(DEFNAMESPACE BLOCK-NAME NIL :BLOCK)
(DEFNAMESPACE TAG-NAME NIL :TAG)
(DEFNAMESPACE CATCH-TAG NIL :CATCH-TAG)
(DEFNAMESPACE TYPE-NAME NIL :TYPE)
(DEFNAMESPACE CLASS-NAME% NIL :CLASS)
(DEFNAMESPACE CONDITION-CLASS-NAME (CLASS-NAME%) :CONDITION-CLASS)
(DEFNAMESPACE SYMBOL-MACRO-DEFINITION (SYMBOL-MACRO-NAME))
(DEFNAMESPACE MACRO-DEFINITION (MACRO-NAME))
(DEFNAMESPACE STRUCT-NAME NIL :STRUCTURE)
(DEFNAMESPACE STRUCT-CONSTRUCTOR-NAME (FUNCTION-NAME) :CONSTRUCTOR-FUNCTION)
(DEFNAMESPACE STRUCT-BOA-CONSTRUCTOR (FUNCTION-NAME) :BOA-CONSTRUCTOR)
(DEFNAMESPACE STRUCT-COPIER-NAME (FUNCTION-NAME) :COPIER-FUNCTION)
(DEFNAMESPACE STRUCT-PREDICATE-NAME (FUNCTION-NAME) :TYPE-PREDICATE)
(DEFNAMESPACE STRUCT-SLOT-READER (FUNCTION-NAME) :SLOT-READER)
(DEFNAMESPACE STRUCT-SLOT-ACCESSOR (FUNCTION-NAME) :SLOT-ACCESSOR)
(DEFNAMESPACE GENERIC-FUNCTION-NAME (FUNCTION-NAME) :GENERIC-FUNCTION)
(DEFNAMESPACE GENERIC-SETF-FUNCTION-NAME
              (GENERIC-FUNCTION-NAME SETF-FUNCTION-NAME) :GENERIC-SETF-FUNCTION)
(DEFNAMESPACE METHOD-NAME (FUNCTION-NAME) :METHOD
              ((QUALIFIERS :READER METHOD-QUALIFIER-NAMES :INITARG :QUALIFIERS
                :INITFORM NIL)))
(DEFNAMESPACE SETF-METHOD-NAME (METHOD-NAME SETF-FUNCTION-NAME) :SETF-METHOD)
(DEFNAMESPACE SLOT-NAME NIL :SLOT)
(DEFNAMESPACE METHOD-COMBINATION-NAME NIL :METHOD-COMBINATION)
(SETF (FIND-NAMESPACE-CLASS :SPECIAL-OPERATOR) (FIND-CLASS 'SPECIAL-OPERATOR))
(DEFGENERIC UPDATE-CONTEXT
    (NAME CONTEXT ENV))
(DEFMETHOD UPDATE-CONTEXT (NAME (CONTEXT WALK-CONTEXT) ENV)
  (DECLARE (IGNORE NAME ENV))
  CONTEXT)
(DEFMETHOD UPDATE-CONTEXT (NAME (CONTEXT VARIABLE-NAME) ENV)
  (MULTIPLE-VALUE-BIND (TYPE LOCAL)
      (VARIABLE-INFORMATION NAME ENV)
    (IF TYPE
        (MAKE-CONTEXT (FIND-NAMESPACE-CLASS TYPE) :LOCAL LOCAL)
        CONTEXT)))
(DEFTYPE SETF-FUNCTION () '(CONS (EQL SETF) (CONS SYMBOL NULL)))
(DEFMETHOD UPDATE-CONTEXT (NAME (CONTEXT OPERATOR) ENV)
  (MULTIPLE-VALUE-BIND (TYPE LOCAL)
      (HANDLER-CASE (FUNCTION-INFORMATION NAME ENV)
                    (TYPE-ERROR NIL (VALUES NIL NIL)))
    (COND
     ((AND (NOT LOCAL) (GENERIC-FUNCTION-P NAME))
      (MAKE-CONTEXT
       (ETYPECASE NAME
         (SYMBOL 'GENERIC-FUNCTION-NAME)
         (SETF-FUNCTION 'GENERIC-SETF-FUNCTION-NAME))))
     ((OR TYPE (NOT (SYMBOLP NAME)))
      (MAKE-CONTEXT
       (FIND-NAMESPACE-CLASS
        (ETYPECASE NAME (SYMBOL TYPE) (SETF-FUNCTION :SETF-FUNCTION)))
       :LOCAL (OR LOCAL (LOCAL-BINDING-P CONTEXT))))
     (T CONTEXT))))
(DEFMETHOD UPDATE-CONTEXT (NAME (CONTEXT MACRO-DEFINITION) ENV)
  (MULTIPLE-VALUE-BIND (TYPE LOCAL)
      (FUNCTION-INFORMATION (CAR NAME) ENV)
    (IF TYPE
        (MAKE-CONTEXT (FIND-NAMESPACE-CLASS TYPE) :LOCAL LOCAL)
        CONTEXT)))
(DEFCLASS WALKER NIL NIL)
(DEFGENERIC MACROEXPAND-FOR-WALK
    (WALKER FORM ENV))
(DEFGENERIC WALK-FORM
    (WALKER FORM &OPTIONAL ENV TOPLEVEL))
(DEFGENERIC WALK-AS-SPECIAL-FORM-P
    (WALKER OPERATOR FORM ENV))
(DEFGENERIC WALK-ATOMIC-FORM
    (WALKER FORM CONTEXT ENV &KEY TOPLEVEL))
(DEFGENERIC WALK-COMPOUND-FORM
    (WALKER OPERATOR FORM ENV &KEY TOPLEVEL))
(DEFGENERIC WALK-NAME
    (WALKER NAME CONTEXT ENV &KEY))
(DEFGENERIC WALK-BINDINGS
    (WALKER NAMES NAMESPACE ENV &KEY DECLARE))
(DEFGENERIC WALK-DECLARATION-SPECIFIER
    (WALKER DECL-SPEC ENV))
(DEFMETHOD MACROEXPAND-FOR-WALK ((WALKER WALKER) FORM ENV)
  (MACROEXPAND-1 FORM ENV))
(DEFMETHOD WALK-FORM
           ((WALKER WALKER) FORM
            &OPTIONAL ENV TOPLEVEL
            &AUX (ENV (ENSURE-PORTABLE-WALKING-ENVIRONMENT ENV)))
  (LET ((EXPANDED T))
    (LOOP
     (SETQ FORM
             (CATCH 'CONTINUE-WALK
               (COND
                ((ATOM FORM)
                 (TYPECASE FORM
                   (SYMBOL
                    (LET ((VAR
                           (WALK-NAME WALKER FORM (MAKE-CONTEXT 'VARIABLE-NAME)
                                      ENV)))
                      (IF (EQL (VARIABLE-INFORMATION VAR ENV) :SYMBOL-MACRO)
                          VAR
                          (RETURN VAR))))
                   (T
                    (RETURN
                     (WALK-ATOMIC-FORM WALKER FORM NIL ENV :TOPLEVEL
                                       TOPLEVEL)))))
                ((NOT (SYMBOLP (CAR FORM)))
                 (RETURN (WALK-LIST WALKER FORM ENV TOPLEVEL)))
                ((OR (NOT EXPANDED)
                     (WALK-AS-SPECIAL-FORM-P WALKER (CAR FORM) FORM ENV))
                 (RETURN
                  (WALK-COMPOUND-FORM WALKER (CAR FORM) FORM ENV :TOPLEVEL
                                      TOPLEVEL)))
                (T FORM))))
     (MULTIPLE-VALUE-SETQ (FORM EXPANDED)
       (MACROEXPAND-FOR-WALK WALKER FORM ENV)))))
(DEFMETHOD WALK-AS-SPECIAL-FORM-P (WALKER OPERATOR FORM ENV)
  (DECLARE (IGNORE WALKER OPERATOR FORM ENV))
  NIL)
(DEFUN WALK-LIST (WALKER LIST ENV &OPTIONAL TOPLEVEL)
  (DO ((FORM LIST (CDR FORM))
       (NEWFORM NIL (CONS (WALK-FORM WALKER (CAR FORM) ENV TOPLEVEL) NEWFORM)))
      ((ATOM FORM) (NRECONC NEWFORM FORM))))
(DEFMETHOD WALK-ATOMIC-FORM ((WALKER WALKER) FORM CONTEXT ENV &KEY TOPLEVEL)
  (DECLARE (IGNORE CONTEXT ENV TOPLEVEL))
  FORM)
(DEFMETHOD WALK-ATOMIC-FORM
           ((WALKER WALKER) (FORM CONS) CONTEXT ENV &KEY TOPLEVEL)
  (DECLARE (IGNORE ENV TOPLEVEL))
  (ERROR "Unexpected non-atomic form ~S (~S)" FORM CONTEXT))
(DEFMETHOD WALK-COMPOUND-FORM
           ((WALKER WALKER) (OPERATOR SYMBOL) FORM ENV &KEY TOPLEVEL)
  (DECLARE (IGNORE TOPLEVEL))
  `(,(WALK-NAME WALKER (CAR FORM) (MAKE-CONTEXT 'OPERATOR) ENV)
    ,@(WALK-LIST WALKER (CDR FORM) ENV)))
(DEFTYPE LAMBDA-EXPRESSION () '(CONS (EQL LAMBDA) (CONS LIST *)))
(DEFMETHOD WALK-COMPOUND-FORM
           ((WALKER WALKER) (OPERATOR CONS) FORM ENV &KEY TOPLEVEL)
  (DECLARE (IGNORE TOPLEVEL))
  (ETYPECASE OPERATOR
    (LAMBDA-EXPRESSION
     `(,(WALK-LAMBDA-EXPRESSION WALKER OPERATOR NIL ENV)
       ,@(WALK-LIST WALKER (CDR FORM) ENV)))))
(DEFMETHOD WALK-NAME ((WALKER WALKER) NAME CONTEXT ENV &KEY)
  (DECLARE (IGNORE CONTEXT ENV))
  NAME)
(DEFMETHOD WALK-BINDINGS
           ((WALKER WALKER) NAMES (NAMESPACE NAMESPACE) ENV &KEY DECLARE)
  (DECLARE (IGNORE DECLARE))
  (VALUES (MAPCAR (LAMBDA (NAME) (WALK-NAME WALKER NAME NAMESPACE ENV)) NAMES)
          ENV))
(DEFUN WALK-BINDING (WALKER NAME NAMESPACE ENV &KEY DECLARE)
  (MULTIPLE-VALUE-BIND (NAMES ENV)
      (WALK-BINDINGS WALKER (LIST NAME) NAMESPACE ENV :DECLARE DECLARE)
    (VALUES (FIRST NAMES) ENV)))
(MACROLET ((WALK-AS-SPECIAL-FORM (OPERATOR)
             `(DEFMETHOD WALK-AS-SPECIAL-FORM-P
                         ((WALKER WALKER) (OPERATOR (EQL ',OPERATOR)) FORM ENV)
                (DECLARE (IGNORE FORM ENV))
                T)))
  (WALK-AS-SPECIAL-FORM IF)
  (WALK-AS-SPECIAL-FORM LOAD-TIME-VALUE)
  (WALK-AS-SPECIAL-FORM MULTIPLE-VALUE-CALL)
  (WALK-AS-SPECIAL-FORM MULTIPLE-VALUE-PROG1)
  (WALK-AS-SPECIAL-FORM PROGV)
  (WALK-AS-SPECIAL-FORM SETQ)
  (WALK-AS-SPECIAL-FORM UNWIND-PROTECT))
(DEFMACRO DEFINE-SPECIAL-FORM-WALKER
          (OPERATOR (WALKER FORM ENV &REST REST) &BODY BODY)
  (LET ((OPARG `(,(MAKE-SYMBOL "OPERATOR") (EQL ',OPERATOR))))
    (FLET ((ARG-NAME (ARG)
             (IF (CONSP ARG)
                 (CAR ARG)
                 ARG)))
      `(PROGN
        (DEFMETHOD WALK-AS-SPECIAL-FORM-P (,WALKER ,OPARG ,FORM ,ENV)
          (DECLARE
           (IGNORABLE ,@(MAPCAR (FUNCTION ARG-NAME) `(,WALKER ,FORM ,ENV))))
          T)
        (DEFMETHOD WALK-COMPOUND-FORM (,WALKER ,OPARG ,FORM ,ENV ,@REST)
          (DECLARE
           (IGNORABLE ,@(MAPCAR (FUNCTION ARG-NAME) `(,WALKER ,FORM ,ENV))))
          ,@BODY)))))
(DEFINE-SPECIAL-FORM-WALKER PROGN
    ((WALKER WALKER) FORM ENV &KEY TOPLEVEL)
  `(,(CAR FORM) ,@(WALK-LIST WALKER (CDR FORM) ENV TOPLEVEL)))
(DEFINE-SPECIAL-FORM-WALKER BLOCK
    ((WALKER WALKER) FORM ENV &KEY TOPLEVEL)
  (DECLARE (IGNORE TOPLEVEL))
  `(,(CAR FORM)
    ,(WALK-BINDING WALKER (CADR FORM) (MAKE-CONTEXT 'BLOCK-NAME) ENV)
    ,@(WALK-LIST WALKER (CDDR FORM) ENV)))
(DEFINE-SPECIAL-FORM-WALKER RETURN-FROM
    ((WALKER WALKER) FORM ENV &KEY TOPLEVEL)
  (DECLARE (IGNORE TOPLEVEL))
  `(,(CAR FORM) ,(WALK-NAME WALKER (CADR FORM) (MAKE-CONTEXT 'BLOCK-NAME) ENV)
    ,(WALK-FORM WALKER (CADDR FORM) ENV)))
(DEFINE-SPECIAL-FORM-WALKER TAGBODY
    ((WALKER WALKER) FORM ENV &KEY TOPLEVEL)
  (DECLARE (IGNORE TOPLEVEL))
  `(,(CAR FORM)
    ,@(LOOP WITH TAG-CONTEXT = (MAKE-CONTEXT 'TAG-NAME)
            FOR TAG/STATEMENT IN (CDR FORM)
            COLLECT (TYPECASE TAG/STATEMENT
                      ((OR SYMBOL INTEGER)
                       (WALK-NAME WALKER TAG/STATEMENT TAG-CONTEXT ENV))
                      (T (WALK-FORM WALKER TAG/STATEMENT ENV))))))
(DEFINE-SPECIAL-FORM-WALKER GO
    ((WALKER WALKER) FORM ENV &KEY TOPLEVEL)
  (DECLARE (IGNORE TOPLEVEL))
  `(,(CAR FORM) ,(WALK-NAME WALKER (CADR FORM) (MAKE-CONTEXT 'TAG-NAME) ENV)))
(DEFMETHOD WALK-NAME ((WALKER WALKER) NAME (CONTEXT CATCH-TAG) ENV &KEY CATCH)
  (DECLARE (IGNORE CATCH))
  (WALK-FORM WALKER NAME ENV))
(DEFINE-SPECIAL-FORM-WALKER CATCH
    ((WALKER WALKER) FORM ENV &KEY TOPLEVEL)
  (DECLARE (IGNORE TOPLEVEL))
  `(,(CAR FORM)
    ,(WALK-NAME WALKER (CADR FORM) (MAKE-CONTEXT 'CATCH-TAG) ENV :CATCH T)
    ,@(WALK-LIST WALKER (CDDR FORM) ENV)))
(DEFINE-SPECIAL-FORM-WALKER THROW
    ((WALKER WALKER) FORM ENV &KEY TOPLEVEL)
  (DECLARE (IGNORE TOPLEVEL))
  `(,(CAR FORM) ,(WALK-NAME WALKER (CADR FORM) (MAKE-CONTEXT 'CATCH-TAG) ENV)
    ,(WALK-FORM WALKER (CADDR FORM) ENV)))
(DEFUN WALK-THE (WALKER FORM ENV)
  `(,(CAR FORM) ,(CADR FORM) ,(WALK-FORM WALKER (CADDR FORM) ENV)))
(MACROLET ((DEFINE-THE-WALKER (OPERATOR)
             `(DEFINE-SPECIAL-FORM-WALKER ,OPERATOR
                  ((WALKER WALKER) FORM ENV &KEY TOPLEVEL)
                (DECLARE (IGNORE TOPLEVEL))
                (WALK-THE WALKER FORM ENV))))
  (DEFINE-THE-WALKER THE)
  #+:SBCL (define-the-walker sb-ext:truly-the))
(DEFINE-SPECIAL-FORM-WALKER QUOTE
    ((WALKER WALKER) FORM ENV &KEY TOPLEVEL)
  (DECLARE (IGNORE ENV TOPLEVEL))
  FORM)
(DEFINE-SPECIAL-FORM-WALKER EVAL-WHEN
    ((WALKER WALKER) FORM ENV &KEY TOPLEVEL &AUX
     (EVAL
      (AND TOPLEVEL
           (OR (MEMBER :COMPILE-TOPLEVEL (CADR FORM))
               (MEMBER 'COMPILE (CADR FORM))))))
  `(,(CAR FORM) ,(CADR FORM)
    ,@(LOOP FOR FORM IN (CDDR FORM) AS WALKED-FORM = (WALK-FORM WALKER FORM ENV
                                                                TOPLEVEL)
            WHEN EVAL
            DO (EVAL WALKED-FORM)
            COLLECT WALKED-FORM)))
(DEFINE-SPECIAL-FORM-WALKER DEFCONSTANT
    ((WALKER WALKER) FORM ENV &KEY TOPLEVEL)
  (DECLARE (IGNORE TOPLEVEL))
  (THROW 'CONTINUE-WALK
    `(EVAL-WHEN (:COMPILE-TOPLEVEL) ,(MACROEXPAND-FOR-WALK WALKER FORM ENV))))
(DEFTYPE NAMED-LAMBDA-EXPRESSION () '(CONS (EQL NAMED-LAMBDA)))
(DEFINE-SPECIAL-FORM-WALKER FUNCTION
    ((WALKER WALKER) FORM ENV &KEY TOPLEVEL)
  (DECLARE (IGNORE TOPLEVEL))
  `(,(CAR FORM)
    ,(TYPECASE (CADR FORM)
       (LAMBDA-EXPRESSION (WALK-LAMBDA-EXPRESSION WALKER (CADR FORM) NIL ENV))
       (NAMED-LAMBDA-EXPRESSION (WALK-FORM WALKER (CADR FORM) ENV))
       (T (WALK-NAME WALKER (CADR FORM) (MAKE-CONTEXT 'FUNCTION-NAME) ENV)))))
(DEFUN PARSE-BODY (BODY &KEY DOC-STRING-ALLOWED WALKER ENV &AUX DOC)
  (FLET ((DOC-STRING-P (X REST)
           (AND (STRINGP X) DOC-STRING-ALLOWED REST (NULL DOC)))
         (DECLARATIONP (X)
           (AND (LISTP X) (EQL (CAR X) 'DECLARE))))
    (LOOP FOR FORMS = BODY THEN (CDR FORMS) AS X = (CAR FORMS)
          WHILE FORMS
          IF (DOC-STRING-P X (CDR FORMS))
          DO (SETQ DOC X) ELSE
          IF (DECLARATIONP X)
          APPEND (CDR X) INTO DECLS ELSE
          DO (LOOP-FINISH)
          FINALLY (RETURN
                   (VALUES FORMS
                           (IF WALKER
                               (WALK-DECLARATION-SPECIFIERS WALKER DECLS ENV)
                               DECLS)
                           DOC)))))
(DEFUN WALK-DECLARATION-SPECIFIERS (WALKER DECLS ENV)
  (LOOP FOR DECL IN DECLS
        WHEN (WALK-DECLARATION-SPECIFIER WALKER DECL ENV)
        COLLECT IT))
(DEFMETHOD WALK-DECLARATION-SPECIFIER ((WALKER WALKER) DECL-SPEC ENV)
  (DESTRUCTURING-BIND
      (IDENTIFIER . DATA)
      DECL-SPEC
    (CASE IDENTIFIER
      (SPECIAL
       (FLET ((WALK-VAR (VAR)
                (WALK-NAME WALKER VAR (MAKE-CONTEXT 'SPECIAL-VARIABLE-NAME)
                           ENV)))
         `(SPECIAL ,@(MAPCAR #'WALK-VAR DATA))))
      ((IGNORE IGNORABLE)
       (FLET ((WALK-VAR/FN (NAME)
                (ETYPECASE NAME
                  (SYMBOL
                   (WALK-NAME WALKER NAME (MAKE-CONTEXT 'VARIABLE-NAME) ENV))
                  ((CONS (EQL FUNCTION))
                   `#',(WALK-NAME WALKER (CADR NAME)
                                  (MAKE-CONTEXT 'FUNCTION-NAME) ENV)))))
         `(,IDENTIFIER ,@(MAPCAR #'WALK-VAR/FN DATA))))
      (OPTIMIZE `(OPTIMIZE ,@DATA)))))
(DEFMETHOD WALK-BINDINGS
           ((WALKER WALKER) NAMES (NAMESPACE VARIABLE-NAME) ENV &KEY DECLARE)
  (LET ((DECLS
         (NCONC
          (MAPCAN
           (LAMBDA (DECL)
             (AND (MEMBER (CAR DECL) '(IGNORE IGNORABLE SPECIAL))
                  (LET ((VARS (INTERSECTION (CDR DECL) NAMES)))
                    (AND VARS (LIST `(,(CAR DECL) ,@VARS))))))
           DECLARE)
          (LIST
           `(SPECIAL
             ,@(REMOVE-IF-NOT
                (LAMBDA (NAME)
                  (AND (EQ (VARIABLE-INFORMATION NAME NIL) :SPECIAL) #+:SBCL
                          (not (sb-ext:package-locked-p (symbol-package name)))
                       (NOT
                        (EQ (SYMBOL-PACKAGE NAME)
                            (FIND-PACKAGE "COMMON-LISP")))))
                NAMES))))))
    (VALUES NAMES (AUGMENT-ENVIRONMENT ENV :VARIABLE NAMES :DECLARE DECLS))))
(DEFUN WALK-LAMBDA-LIST (WALKER LAMBDA-LIST DECLS ENV)
  (LET ((NEW-LAMBDA-LIST 'NIL) (STATE :REQVARS))
    (LABELS ((WALK-VAR (VAR)
               (MULTIPLE-VALUE-SETQ (VAR ENV)
                 (WALK-BINDING WALKER VAR
                               (MAKE-CONTEXT 'VARIABLE-NAME :LOCAL T) ENV
                               :DECLARE DECLS)))
             (UPDATE-STATE (KEYWORD)
               (SETQ STATE
                       (CASE KEYWORD
                         (&OPTIONAL :OPTVARS)
                         ((&REST &BODY) :RESTVARS)
                         (&KEY :KEYVARS)
                         (&AUX :AUXVARS)
                         (&ENVIRONMENT :ENVVAR)
                         (T STATE))))
             (MAYBE-DESTRUCTURE (VAR/PATTERN)
               (IF (CONSP VAR/PATTERN)
                   (MULTIPLE-VALUE-SETQ (VAR/PATTERN ENV)
                     (WALK-LAMBDA-LIST WALKER VAR/PATTERN DECLS ENV))
                   (WALK-VAR VAR/PATTERN))))
      (AND (CONSP LAMBDA-LIST) (EQL (CAR LAMBDA-LIST) '&WHOLE)
           (PUSH (POP LAMBDA-LIST) NEW-LAMBDA-LIST)
           (CAR (PUSH (WALK-VAR (POP LAMBDA-LIST)) NEW-LAMBDA-LIST)))
      (DO ((LAMBDA-LIST LAMBDA-LIST (CDR LAMBDA-LIST)))
          ((ATOM LAMBDA-LIST) NIL)
        (WHEN (EQL (CAR LAMBDA-LIST) '&ENVIRONMENT)
          (RETURN (CADR LAMBDA-LIST))))
      (DO* ((LAMBDA-LIST LAMBDA-LIST (CDR LAMBDA-LIST))
            (ARG (CAR LAMBDA-LIST)
                 (IF (CONSP LAMBDA-LIST)
                     (CAR LAMBDA-LIST)
                     LAMBDA-LIST)))
           ((ATOM LAMBDA-LIST)
            (VALUES (NRECONC NEW-LAMBDA-LIST (AND ARG (WALK-VAR ARG))) ENV))
        (ECASE STATE
          (:ENVVAR
           (PUSH (WALK-VAR ARG) NEW-LAMBDA-LIST)
           (WHEN (CONSP LAMBDA-LIST) (UPDATE-STATE (CAR LAMBDA-LIST))))
          ((:REQVARS :RESTVARS)
           (ETYPECASE ARG
             (SYMBOL
              (COND
               ((MEMBER ARG LAMBDA-LIST-KEYWORDS) (PUSH ARG NEW-LAMBDA-LIST)
                (UPDATE-STATE ARG))
               (T (SETQ ARG (WALK-VAR ARG)) (PUSH ARG NEW-LAMBDA-LIST))))
             (CONS
              (MULTIPLE-VALUE-BIND (PATTERN NEW-ENV)
                  (WALK-LAMBDA-LIST WALKER ARG DECLS ENV)
                (SETQ ENV NEW-ENV)
                (PUSH PATTERN NEW-LAMBDA-LIST)))))
          (:OPTVARS
           (ETYPECASE ARG
             (SYMBOL
              (COND
               ((MEMBER ARG LAMBDA-LIST-KEYWORDS) (PUSH ARG NEW-LAMBDA-LIST)
                (UPDATE-STATE ARG))
               (T (SETQ ARG (WALK-VAR ARG)) (PUSH ARG NEW-LAMBDA-LIST))))
             (CONS
              (DESTRUCTURING-BIND
                  (VAR/PATTERN
                   &OPTIONAL (INIT-FORM NIL INIT-FORM-SUPPLIED)
                   (SUPPLIED-P-PARAMETER NIL SPP-SUPPLIED))
                  ARG
                (WHEN INIT-FORM-SUPPLIED
                  (SETQ INIT-FORM (WALK-FORM WALKER INIT-FORM ENV)))
                (PUSH
                 (NCONC (LIST (MAYBE-DESTRUCTURE VAR/PATTERN))
                        (AND INIT-FORM-SUPPLIED (LIST INIT-FORM))
                        (AND SPP-SUPPLIED
                             (LIST (WALK-VAR SUPPLIED-P-PARAMETER))))
                 NEW-LAMBDA-LIST)))))
          (:KEYVARS
           (ETYPECASE ARG
             (SYMBOL
              (COND
               ((MEMBER ARG LAMBDA-LIST-KEYWORDS) (PUSH ARG NEW-LAMBDA-LIST)
                (UPDATE-STATE ARG))
               (T (SETQ ARG (WALK-VAR ARG)) (PUSH ARG NEW-LAMBDA-LIST))))
             (CONS
              (DESTRUCTURING-BIND
                  (VAR/KV
                   &OPTIONAL (INIT-FORM NIL INIT-FORM-SUPPLIED)
                   (SUPPLIED-P-PARAMETER NIL SPP-SUPPLIED))
                  ARG
                (WHEN INIT-FORM-SUPPLIED
                  (SETQ INIT-FORM (WALK-FORM WALKER INIT-FORM ENV)))
                (COND
                 ((CONSP VAR/KV)
                  (DESTRUCTURING-BIND
                      (KEYWORD-NAME VAR/PATTERN)
                      VAR/KV
                    (SETQ VAR/PATTERN (MAYBE-DESTRUCTURE VAR/PATTERN))
                    (SETQ VAR/KV
                            (LIST
                             (WALK-ATOMIC-FORM WALKER KEYWORD-NAME NIL ENV)
                             VAR/PATTERN))))
                 (T (SETQ VAR/KV (WALK-VAR VAR/KV))))
                (PUSH
                 (NCONC (LIST VAR/KV) (AND INIT-FORM-SUPPLIED (LIST INIT-FORM))
                        (AND SPP-SUPPLIED
                             (LIST (WALK-VAR SUPPLIED-P-PARAMETER))))
                 NEW-LAMBDA-LIST)))))
          (:AUXVARS
           (ETYPECASE ARG
             (SYMBOL
              (COND
               ((MEMBER ARG LAMBDA-LIST-KEYWORDS) (PUSH ARG NEW-LAMBDA-LIST)
                (UPDATE-STATE ARG))
               (T (SETQ ARG (WALK-VAR ARG)) (PUSH ARG NEW-LAMBDA-LIST))))
             (CONS
              (DESTRUCTURING-BIND
                  (VAR &OPTIONAL INIT-FORM)
                  ARG
                (SETQ VAR (WALK-VAR VAR)
                      INIT-FORM
                        (AND INIT-FORM (WALK-FORM WALKER INIT-FORM ENV)))
                (PUSH (NCONC (LIST VAR) (AND INIT-FORM (LIST INIT-FORM)))
                      NEW-LAMBDA-LIST))))))))))
(DEFTYPE CLASS-SPECIALIZER () '(CONS SYMBOL (CONS SYMBOL NULL)))
(DEFTYPE COMPOUND-SPECIALIZER (&OPTIONAL (OPERATOR 'EQL))
  `(CONS SYMBOL (CONS (CONS (EQL ,OPERATOR) *) NULL)))
(DEFUN WALK-SPECIALIZED-LAMBDA-LIST (WALKER LAMBDA-LIST DECLS ENV)
  (LET ((REQ-PARAMS
         (FLET ((WALK-VAR
                    (SPEC &AUX (CONTEXT (MAKE-CONTEXT 'VARIABLE-NAME :LOCAL T)))
                  (FLET ((WALK-BINDING (X &AUX NAME)
                           (DECLARE (IGNORABLE NAME))
                           (MULTIPLE-VALUE-SETQ (NAME ENV)
                             (WALK-BINDING WALKER X CONTEXT ENV :DECLARE
                                           DECLS))))
                    (ETYPECASE SPEC
                      (SYMBOL (WALK-BINDING SPEC))
                      (CLASS-SPECIALIZER
                       (LIST (WALK-BINDING (CAR SPEC))
                             (WALK-NAME WALKER (CADR SPEC)
                                        (MAKE-CONTEXT 'CLASS-NAME%) ENV)))
                      ((COMPOUND-SPECIALIZER EQL)
                       (LIST (WALK-BINDING (CAR SPEC))
                             `(EQL ,(WALK-FORM WALKER (CADADR SPEC)))))))))
           (LOOP UNTIL (OR (NULL LAMBDA-LIST)
                           (MEMBER (CAR LAMBDA-LIST) LAMBDA-LIST-KEYWORDS))
                 COLLECT (WALK-VAR (POP LAMBDA-LIST))))))
    (MULTIPLE-VALUE-BIND (OTHER-PARAMS ENV)
        (WALK-LAMBDA-LIST WALKER LAMBDA-LIST DECLS ENV)
      (VALUES (NCONC REQ-PARAMS OTHER-PARAMS) ENV))))
(DEFUN WALK-LAMBDA-EXPRESSION (WALKER FORM CONTEXT ENV)
  (LET ((LAMBDA-LIST (CADR FORM)) (BODY (CDDR FORM)))
    (MULTIPLE-VALUE-BIND (FORMS DECLS DOC)
        (PARSE-BODY BODY :WALKER WALKER :ENV ENV :DOC-STRING-ALLOWED T)
      (MULTIPLE-VALUE-BIND (LAMBDA-LIST ENV)
          (WALK-LAMBDA-LIST WALKER LAMBDA-LIST DECLS ENV)
        `(,(LET ((NAME (CAR FORM)))
             (CASE NAME
               (LAMBDA NAME)
               (T (WALK-NAME WALKER (CAR FORM) CONTEXT ENV))))
          ,LAMBDA-LIST ,@(WHEN DOC `(,DOC)) ,@(WHEN DECLS `((DECLARE ,@DECLS)))
          ,@(WALK-LIST WALKER FORMS ENV))))))
(DEFINE-SPECIAL-FORM-WALKER LAMBDA
    ((WALKER WALKER) FORM ENV &KEY TOPLEVEL)
  (DECLARE (IGNORE TOPLEVEL))
  (WALK-LAMBDA-EXPRESSION WALKER FORM NIL ENV))
(DEFINE-SPECIAL-FORM-WALKER NAMED-LAMBDA
    ((WALKER WALKER) FORM ENV &KEY TOPLEVEL)
  (DECLARE (IGNORE TOPLEVEL))
  (WALK-LAMBDA-EXPRESSION WALKER `(LAMBDA ,(CADDR FORM) ,@(CDDDR FORM)) NIL
                          ENV))
(DEFINE-SPECIAL-FORM-WALKER LET
    ((WALKER WALKER) FORM ENV &KEY TOPLEVEL)
  (DECLARE (IGNORE TOPLEVEL))
  (MULTIPLE-VALUE-BIND (FORMS DECLS)
      (PARSE-BODY (CDDR FORM) :WALKER WALKER :ENV ENV)
    (LET* ((BINDINGS (MAPCAR #'ENSURE-LIST (CADR FORM)))
           (INIT-FORMS
            (MAPCAR (LAMBDA (FORM) (WALK-FORM WALKER FORM ENV))
                    (MAPCAR #'CADR BINDINGS))))
      (MULTIPLE-VALUE-BIND (VARS ENV)
          (WALK-BINDINGS WALKER (MAPCAR #'CAR BINDINGS)
                         (MAKE-CONTEXT 'VARIABLE-NAME :LOCAL T) ENV :DECLARE
                         DECLS)
        `(,(CAR FORM) ,(MAPCAR #'LIST VARS INIT-FORMS)
          ,@(WHEN DECLS `((DECLARE ,@DECLS)))
          ,@(WALK-LIST WALKER FORMS ENV))))))
(DEFMETHOD WALK-BINDINGS
           ((WALKER WALKER) NAMES (NAMESPACE FUNCTION-NAME) ENV &KEY DECLARE)
  (DECLARE (IGNORE DECLARE))
  (VALUES NAMES (AUGMENT-ENVIRONMENT ENV :FUNCTION NAMES)))
(DEFINE-SPECIAL-FORM-WALKER FLET
    ((WALKER WALKER) FORM ENV &KEY TOPLEVEL)
  (DECLARE (IGNORE TOPLEVEL))
  (MULTIPLE-VALUE-BIND (FORMS DECLS)
      (PARSE-BODY (CDDR FORM) :WALKER WALKER :ENV ENV)
    (LET* ((BINDINGS (CADR FORM))
           (CONTEXT (MAKE-CONTEXT 'FUNCTION-NAME :LOCAL T))
           (FNS
            (MAPCAR
             (LAMBDA (FN) (WALK-LAMBDA-EXPRESSION WALKER FN CONTEXT ENV))
             BINDINGS)))
      (MULTIPLE-VALUE-BIND (FUNCTION-NAMES ENV)
          (WALK-BINDINGS WALKER (MAPCAR #'CAR BINDINGS) CONTEXT ENV :DECLARE
                         DECLS)
        `(,(CAR FORM) ,(MAPCAR #'CONS FUNCTION-NAMES (MAPCAR #'CDR FNS))
          ,@(WHEN DECLS `((DECLARE ,@DECLS)))
          ,@(WALK-LIST WALKER FORMS
                       (IF DECLS
                           (AUGMENT-ENVIRONMENT ENV :DECLARE DECLS)
                           ENV)))))))
(DEFMETHOD WALK-BINDINGS
           ((WALKER WALKER) DEFS (NAMESPACE MACRO-DEFINITION) ENV &KEY DECLARE)
  (LET* ((FNS
          (MAPCAR (LAMBDA (EXP) (WALK-LAMBDA-EXPRESSION WALKER EXP NIL ENV))
                  DEFS))
         (DEFS
          (MAPCAR
           (LAMBDA (DEF)
             (DESTRUCTURING-BIND
                 (NAME LAMBDA-LIST &REST BODY)
                 DEF
               (LIST NAME
                     (ENCLOSE (PARSE-MACRO NAME LAMBDA-LIST BODY ENV) ENV
                              WALKER))))
           FNS)))
    (VALUES FNS (AUGMENT-ENVIRONMENT ENV :MACRO DEFS :DECLARE DECLARE))))
(DEFINE-SPECIAL-FORM-WALKER MACROLET
    ((WALKER WALKER) FORM ENV &KEY TOPLEVEL)
  (MULTIPLE-VALUE-BIND (FORMS DECLS)
      (PARSE-BODY (CDDR FORM) :WALKER WALKER :ENV ENV)
    (LET ((BINDINGS (CADR FORM)))
      (MULTIPLE-VALUE-BIND (DEFS ENV)
          (WALK-BINDINGS WALKER BINDINGS
                         (MAKE-CONTEXT 'MACRO-DEFINITION :LOCAL T) ENV :DECLARE
                         DECLS)
        `(,(CAR FORM) ,DEFS ,@(WHEN DECLS `((DECLARE ,@DECLS)))
          ,@(WALK-LIST WALKER FORMS ENV TOPLEVEL))))))
(DEFMETHOD WALK-BINDINGS
           ((WALKER WALKER) DEFS (NAMESPACE SYMBOL-MACRO-DEFINITION) ENV
            &KEY DECLARE)
  (VALUES
   (SETQ DEFS
           (MAPCAR (LAMBDA (P) `(,(CAR P) ,(WALK-FORM WALKER (CADR P) ENV)))
                   DEFS))
   (AUGMENT-ENVIRONMENT ENV :SYMBOL-MACRO DEFS :DECLARE DECLARE)))
(DEFINE-SPECIAL-FORM-WALKER SYMBOL-MACROLET
    ((WALKER WALKER) FORM ENV &KEY TOPLEVEL)
  (MULTIPLE-VALUE-BIND (FORMS DECLS)
      (PARSE-BODY (CDDR FORM) :WALKER WALKER :ENV ENV)
    (LET ((BINDINGS (CADR FORM)))
      (MULTIPLE-VALUE-BIND (DEFS ENV)
          (WALK-BINDINGS WALKER BINDINGS
                         (MAKE-CONTEXT 'SYMBOL-MACRO-DEFINITION :LOCAL T) ENV
                         :DECLARE DECLS)
        `(,(CAR FORM) ,DEFS ,@(WHEN DECLS `((DECLARE ,@DECLS)))
          ,@(WALK-LIST WALKER FORMS ENV TOPLEVEL))))))
(DEFINE-SPECIAL-FORM-WALKER LET*
    ((WALKER WALKER) FORM ENV &KEY TOPLEVEL)
  (DECLARE (IGNORE TOPLEVEL))
  (MULTIPLE-VALUE-BIND (FORMS DECLS)
      (PARSE-BODY (CDDR FORM) :WALKER WALKER :ENV ENV)
    (LET ((CONTEXT (MAKE-CONTEXT 'VARIABLE-NAME :LOCAL T)))
      `(,(CAR FORM)
        ,(MAPCAR
          (LAMBDA (P &AUX (P (ENSURE-LIST P)))
            (LET ((VAR (CAR P)) (INIT-FORM (WALK-FORM WALKER (CADR P) ENV)))
              (MULTIPLE-VALUE-SETQ (VAR ENV)
                (WALK-BINDING WALKER VAR CONTEXT ENV :DECLARE DECLS))
              (LIST VAR INIT-FORM)))
          (CADR FORM))
        ,@(WHEN DECLS `((DECLARE ,@DECLS))) ,@(WALK-LIST WALKER FORMS ENV)))))
(DEFINE-SPECIAL-FORM-WALKER LABELS
    ((WALKER WALKER) FORM ENV &KEY TOPLEVEL)
  (DECLARE (IGNORE TOPLEVEL))
  (MULTIPLE-VALUE-BIND (FORMS DECLS)
      (PARSE-BODY (CDDR FORM) :WALKER WALKER :ENV ENV)
    (LET* ((CONTEXT (MAKE-CONTEXT 'FUNCTION-NAME :LOCAL T))
           (BINDINGS (CADR FORM))
           (FUNCTION-NAMES 'NIL))
      (DOLIST
          (BINDING BINDINGS (SETF FUNCTION-NAMES (NREVERSE FUNCTION-NAMES)))
        (MULTIPLE-VALUE-BIND (FUNCTION-NAME NEW-ENV)
            (WALK-BINDING WALKER (CAR BINDING) CONTEXT ENV :DECLARE DECLS)
          (PUSH FUNCTION-NAME FUNCTION-NAMES)
          (SETQ ENV NEW-ENV)))
      `(,(CAR FORM)
        ,(MAPCAR (LAMBDA (P) (WALK-LAMBDA-EXPRESSION WALKER P CONTEXT ENV))
                 (MAPCAR #'CONS FUNCTION-NAMES (MAPCAR #'CDR BINDINGS)))
        ,@(WHEN DECLS `((DECLARE ,@DECLS)))
        ,@(WALK-LIST WALKER FORMS
                     (IF DECLS
                         (AUGMENT-ENVIRONMENT ENV :DECLARE DECLS)
                         ENV))))))
(DEFINE-SPECIAL-FORM-WALKER LOCALLY
    ((WALKER WALKER) FORM ENV &KEY TOPLEVEL)
  (MULTIPLE-VALUE-BIND (FORMS DECLS)
      (PARSE-BODY (CDR FORM) :WALKER WALKER :ENV ENV)
    `(,(CAR FORM) ,@(WHEN DECLS `((DECLARE ,@DECLS)))
      ,@(WALK-LIST WALKER FORMS (AUGMENT-ENVIRONMENT ENV :DECLARE DECLS)
                   TOPLEVEL))))
(DEFINE-SPECIAL-FORM-WALKER DECLAIM
    ((WALKER WALKER) FORM ENV &KEY TOPLEVEL)
  `(,(CAR FORM)
    ,@(LET ((DECLS (WALK-DECLARATION-SPECIFIERS WALKER (CDR FORM) ENV)))
        (WHEN TOPLEVEL (MAPCAR #'PROCLAIM DECLS))
        DECLS)))
(DEFGENERIC INTERESTING-SYMBOL-P
    (OBJECT))
(DEFMETHOD INTERESTING-SYMBOL-P (OBJECT) (DECLARE (IGNORE OBJECT)))
(DEFMETHOD INTERESTING-SYMBOL-P ((OBJECT SYMBOL))
  (MEMBER (SYMBOL-PACKAGE OBJECT) *INDEX-PACKAGES*))
(DEFUN INDEX-PACKAGE (PACKAGES &AUX (PACKAGES (ENSURE-LIST PACKAGES)))
  "Inform the weaver that it should index the symbols in PACKAGES."
  (DOLIST (PACKAGE PACKAGES) (PUSHNEW (FIND-PACKAGE PACKAGE) *INDEX-PACKAGES*)))
(DEFUN JOIN-STRINGS
       (STRINGS
        &OPTIONAL (DELIMITER #\ )
        &AUX (STRINGS (ENSURE-LIST STRINGS)) (DELIMITER (STRING DELIMITER)))
  (WITH-OUTPUT-TO-STRING (OUT)
    (LOOP FOR (STRING . MORE) ON STRINGS
          WHEN STRING
          DO (WRITE-STRING (STRING STRING) OUT)
          AND
          WHEN MORE
          DO (WRITE-STRING DELIMITER OUT))))
(DEFINE-METHOD-COMBINATION JOIN-STRINGS (&OPTIONAL (DELIMITER #\ ))
                           ((OVERRIDE (:OVERRIDE)) (PREFIX (:PREFIX))
                            (PRIMARY NIL :REQUIRED T) (SUFFIX (:SUFFIX)))
                           (FLET ((CALL-METHODS (METHODS)
                                    (MAPCAR
                                     (LAMBDA (METHOD)
                                       `(ENSURE-LIST (CALL-METHOD ,METHOD)))
                                     METHODS)))
                             (LET ((FORM
                                    `(JOIN-STRINGS
                                      (APPEND ,@(CALL-METHODS PREFIX)
                                              ,@(CALL-METHODS PRIMARY)
                                              ,@(CALL-METHODS
                                                 (REVERSE SUFFIX)))
                                      ,DELIMITER)))
                               (IF OVERRIDE
                                   `(CALL-METHOD ,(FIRST OVERRIDE)
                                                 (,@(REST OVERRIDE)
                                                  (MAKE-METHOD ,FORM)))
                                   FORM))))
(DEFGENERIC HEADING-NAME
    (HEADING)
  (:METHOD-COMBINATION JOIN-STRINGS))
(DEFCLASS HEADING NIL
          ((NAME :INITARG :NAME :INITFORM "")
           (SUB-HEADING :READER SUB-HEADING :INITARG :SUB-HEADING :INITFORM
                        NIL)))
(DEFUN MAKE-HEADING (NAME &OPTIONAL SUB-HEADING)
  (MAKE-INSTANCE 'HEADING :NAME NAME :SUB-HEADING SUB-HEADING))
(DEFMETHOD HEADING-NAME ((HEADING HEADING))
  (HEADING-NAME (SLOT-VALUE HEADING 'NAME)))
(DEFMETHOD HEADING-NAME :SUFFIX ((HEADING HEADING))
  (WHEN (SUB-HEADING HEADING) (HEADING-NAME (SUB-HEADING HEADING))))
(DEFCLASS PRETTY-HEADING (HEADING)
          ((MACRO :READER MACRO-HEADING :INITARG :MACRO)))
(DEFCLASS TT-HEADING (PRETTY-HEADING) NIL (:DEFAULT-INITARGS :MACRO "\\."))
(DEFCLASS CUSTOM-HEADING (PRETTY-HEADING) NIL (:DEFAULT-INITARGS :MACRO "\\9"))
(DEFMETHOD SUB-HEADING (HEADING) (DECLARE (IGNORE HEADING)))
(DEFMETHOD HEADING-NAME ((HEADING CHARACTER)) HEADING)
(DEFMETHOD HEADING-NAME ((HEADING STRING))
  (STRING-LEFT-TRIM '(#\  #\Tab #\Newline #\\) HEADING))
(DEFMETHOD HEADING-NAME ((HEADING SYMBOL)) HEADING)
(DEFGENERIC ENTRY-HEADING-LESSP
    (H1 H2))
(DEFMETHOD ENTRY-HEADING-LESSP (H1 H2)
  (STRING-LESSP (HEADING-NAME H1) (HEADING-NAME H2)))
(DEFGENERIC ENTRY-HEADING-EQUALP
    (H1 H2))
(DEFMETHOD ENTRY-HEADING-EQUALP (H1 H2)
  (STRING-EQUAL (HEADING-NAME H1) (HEADING-NAME H2)))
(DEFMETHOD HEADING-NAME ((NAMESPACE NAMESPACE))
  (SUBSTITUTE #\  #\- (STRING-DOWNCASE (NAMESPACE-NAME NAMESPACE))))
(DEFMETHOD HEADING-NAME :SUFFIX ((NAMESPACE LEXICAL-VARIABLE-NAME)) "variable")
(DEFMETHOD HEADING-NAME :SUFFIX ((NAMESPACE SPECIAL-VARIABLE-NAME)) "variable")
(DEFMETHOD HEADING-NAME :PREFIX ((NAMESPACE OPERATOR))
  (AND (LOCAL-BINDING-P NAMESPACE) "local"))
(DEFMETHOD HEADING-NAME :PREFIX ((NAMESPACE SYMBOL-MACRO-NAME))
  (AND (LOCAL-BINDING-P NAMESPACE) "local"))
(DEFMETHOD HEADING-NAME :PREFIX ((NAMESPACE METHOD-NAME))
  (MAPCAR #'STRING-DOWNCASE
          (OR (METHOD-QUALIFIER-NAMES NAMESPACE) '(:PRIMARY))))
(DEFCLASS LOCATOR NIL NIL)
(DEFCLASS SECTION-LOCATOR (LOCATOR)
          ((SECTION :ACCESSOR LOCATION :INITARG :SECTION)
           (DEF :ACCESSOR LOCATOR-DEFINITION-P :INITARG :DEF :INITFORM NIL)))
(DEFCLASS XREF-LOCATOR (LOCATOR)
          ((HEADING :ACCESSOR LOCATION :INITARG :HEADING)))
(DEFCLASS SEE-LOCATOR (XREF-LOCATOR) NIL)
(DEFCLASS SEE-ALSO-LOCATOR (XREF-LOCATOR) NIL)
(DEFUN MAKE-LOCATOR (&KEY SECTION DEF SEE SEE-ALSO)
  (ASSERT
   (IF (OR SEE SEE-ALSO)
       (AND (NOT SECTION) (NOT DEF))
       T)
   (SECTION DEF SEE SEE-ALSO)
   "Can't use :SECTION or :DEF with :SEE or :SEE-ALSO.")
  (ASSERT
   (IF DEF
       SECTION
       T)
   (SECTION DEF) "Can't use :DEF without :SECTION.")
  (ASSERT (NOT (AND SEE SEE-ALSO)) (SEE SEE-ALSO)
          "Can't use both :SEE and :SEE-ALSO.")
  (COND (SECTION (MAKE-INSTANCE 'SECTION-LOCATOR :SECTION SECTION :DEF DEF))
        (SEE (MAKE-INSTANCE 'SEE-LOCATOR :HEADING SEE))
        (SEE-ALSO (MAKE-INSTANCE 'SEE-LOCATOR :HEADING SEE-ALSO))))
(DEFCLASS INDEX-ENTRY (BINARY-SEARCH-TREE)
          ((KEY :ACCESSOR ENTRY-HEADING)
           (LOCATORS :ACCESSOR ENTRY-LOCATORS :INITARG :LOCATORS :INITFORM
            'NIL)))
(DEFMETHOD FIND-OR-INSERT
           (ITEM (ROOT INDEX-ENTRY)
            &KEY (PREDICATE #'ENTRY-HEADING-LESSP)
            (TEST #'ENTRY-HEADING-EQUALP) (INSERT-IF-NOT-FOUND T))
  (CALL-NEXT-METHOD ITEM ROOT :PREDICATE PREDICATE :TEST TEST
   :INSERT-IF-NOT-FOUND INSERT-IF-NOT-FOUND))
(DEFCLASS INDEX NIL ((ENTRIES :ACCESSOR INDEX-ENTRIES :INITFORM NIL)))
(DEFUN MAKE-INDEX () (MAKE-INSTANCE 'INDEX))
(DEFINE-MODIFY-MACRO ORF (&REST ARGS) OR)
(DEFUN ADD-INDEX-ENTRY (INDEX HEADING SECTION &OPTIONAL DEF)
  (FLET ((MAKE-LOCATOR ()
           (MAKE-LOCATOR :SECTION SECTION :DEF DEF)))
    (IF (NULL (INDEX-ENTRIES INDEX))
        (SETF (INDEX-ENTRIES INDEX)
                (MAKE-INSTANCE 'INDEX-ENTRY :KEY HEADING :LOCATORS
                               (LIST (MAKE-LOCATOR))))
        (LET* ((ENTRY (FIND-OR-INSERT HEADING (INDEX-ENTRIES INDEX)))
               (OLD-LOCATOR
                (FIND SECTION (ENTRY-LOCATORS ENTRY) :KEY #'LOCATION)))
          (IF OLD-LOCATOR
              (ORF (LOCATOR-DEFINITION-P OLD-LOCATOR) DEF)
              (PUSH (MAKE-LOCATOR) (ENTRY-LOCATORS ENTRY)))))))
(DEFUN FIND-INDEX-ENTRIES (INDEX HEADING)
  (LET ((ENTRIES (INDEX-ENTRIES INDEX)))
    (WHEN ENTRIES
      (MULTIPLE-VALUE-BIND (ENTRY PRESENT-P)
          (FIND-OR-INSERT HEADING ENTRIES :INSERT-IF-NOT-FOUND NIL)
        (WHEN PRESENT-P (ENTRY-LOCATORS ENTRY))))))
(DEFGENERIC INDEX
    (INDEX NAME SECTION CONTEXT &OPTIONAL DEF))
(DEFMETHOD INDEX ((INDEX INDEX) NAME SECTION CONTEXT &OPTIONAL DEF)
  (WHEN (AND NAME SECTION CONTEXT)
    (ADD-INDEX-ENTRY INDEX (MAKE-HEADING NAME CONTEXT) SECTION DEF)))
(DEFMETHOD INDEX
           ((INDEX INDEX) NAME SECTION (CONTEXT LEXICAL-VARIABLE-NAME)
            &OPTIONAL DEF)
  (DECLARE (IGNORE NAME SECTION DEF))
  (WHEN *INDEX-LEXICAL-VARIABLES* (CALL-NEXT-METHOD)))
(DEFMETHOD INDEX :AROUND
           ((INDEX INDEX) NAME SECTION (CONTEXT VARIABLE-NAME) &OPTIONAL DEF)
  (DECLARE (IGNORE NAME SECTION DEF))
  (UNLESS (EQ (CLASS-OF CONTEXT) (FIND-CLASS 'VARIABLE-NAME))
    (CALL-NEXT-METHOD)))
(DEFMACRO DONT-INDEX (NAMESPACE)
  `(DEFMETHOD INDEX :AROUND
              ((INDEX INDEX) NAME SECTION (CONTEXT ,NAMESPACE) &OPTIONAL DEF)
     (DECLARE (IGNORE NAME SECTION DEF))))
(DONT-INDEX BLOCK-NAME)
(DONT-INDEX TAG-NAME)
(DONT-INDEX SLOT-NAME)
(DEFUN SUBSTITUTE-REFERRING-SYMBOLS (FORM SECTION)
  (LET (SYMBOLS REFSYMS)
    (LABELS ((COLLECT-SYMBOLS (FORM)
               (COND ((INTERESTING-SYMBOL-P FORM) (PUSHNEW FORM SYMBOLS))
                     ((ATOM FORM) NIL)
                     (T (COLLECT-SYMBOLS (CAR FORM))
                      (COLLECT-SYMBOLS (CDR FORM)))))
             (MAKE-REFERRING-SYMBOL (SYMBOL)
               (LET ((REFSYM (COPY-SYMBOL SYMBOL)))
                 (SETF (SYMBOL-VALUE REFSYM) SYMBOL)
                 (SETF (GET REFSYM 'SECTION) SECTION)
                 (LET ((FUNCTION (MACRO-FUNCTION SYMBOL)))
                   (WHEN FUNCTION (SETF (MACRO-FUNCTION REFSYM) FUNCTION)))
                 (LET ((CLASS (FIND-CLASS SYMBOL NIL)))
                   (WHEN CLASS
                     (SETF (FIND-CLASS REFSYM) CLASS)
                     (PUSH REFSYM *REFERRING-CLASSES*)))
                 (CONS SYMBOL REFSYM)))
             (SUBSTITUTE-SYMBOLS (FORM)
               (COND
                ((COMMAP FORM)
                 (MAKE-COMMA (COMMA-MODIFIER FORM)
                             (SUBSTITUTE-REFERRING-SYMBOLS (COMMA-FORM FORM)
                                                           SECTION)))
                ((SYMBOLP FORM) (OR (CDR (ASSOC FORM REFSYMS)) FORM))
                ((ATOM FORM) FORM) (T (MAPTREE #'SUBSTITUTE-SYMBOLS FORM)))))
      (COLLECT-SYMBOLS FORM)
      (SETQ REFSYMS (MAPCAR #'MAKE-REFERRING-SYMBOL SYMBOLS))
      (MAPTREE #'SUBSTITUTE-SYMBOLS FORM))))
(DEFUN SYMBOL-PROVENANCE (SYMBOL)
  (LET (SECTION)
    (IF (AND (NOT (SYMBOL-PACKAGE SYMBOL)) (BOUNDP SYMBOL)
             (SETQ SECTION (GET SYMBOL 'SECTION)))
        (VALUES (SYMBOL-VALUE SYMBOL) SECTION)
        SYMBOL)))
(DEFUN UNSUBSTITUTE-REFERRING-SYMBOLS (X)
  (TYPECASE X
    (SYMBOL (SYMBOL-PROVENANCE X))
    (ATOM X)
    (T (MAPTREE #'UNSUBSTITUTE-REFERRING-SYMBOLS X))))
(DEFMETHOD SECTION-CODE :AROUND ((SECTION SECTION))
  (LET ((CODE (CALL-NEXT-METHOD)))
    (IF *INDEXING*
        (SUBSTITUTE-REFERRING-SYMBOLS (TANGLE CODE :EXPAND-NAMED-SECTIONS NIL)
                                      SECTION)
        CODE)))
(DEFUN TANGLE-CODE-FOR-INDEXING (SECTIONS)
  (LET ((*INDEXING* T))
    (TANGLE (UNNAMED-SECTION-CODE-PARTS SECTIONS))))
(DEFUN INDEX-SECTIONS
       (SECTIONS
        &KEY (INDEX *INDEX*)
        (WALKER (MAKE-INSTANCE 'INDEXING-WALKER :INDEX INDEX)))
  (LET ((*EVALUATING* T))
    (INDEX-PACKAGE *PACKAGE*)
    (UNWIND-PROTECT
        (DOLIST
            (FORM (TANGLE-CODE-FOR-INDEXING SECTIONS) (WALKER-INDEX WALKER))
          (HANDLER-CASE (WALK-FORM WALKER FORM NIL T)
                        (PACKAGE-ERROR NIL FORM)))
      (DOLIST (SYMBOL *REFERRING-CLASSES* (SETQ *REFERRING-CLASSES* 'NIL))
        (SETF (FIND-CLASS SYMBOL) NIL)))))
(DEFCLASS INDEXING-WALKER (WALKER)
          ((INDEX :ACCESSOR WALKER-INDEX :INITARG :INDEX :INITFORM
                  (MAKE-INDEX))))
(DEFMETHOD WALK-COMPOUND-FORM
           ((WALKER INDEXING-WALKER) (OPERATOR (EQL 'QUOTE)) FORM ENV
            &KEY TOPLEVEL)
  (DECLARE (IGNORE ENV TOPLEVEL))
  `',(UNSUBSTITUTE-REFERRING-SYMBOLS (CADR FORM)))
(DEFMETHOD MACROEXPAND-FOR-WALK ((WALKER INDEXING-WALKER) (FORM CONS) ENV)
  (HANDLER-CASE
   (MULTIPLE-VALUE-BIND (SYMBOL SECTION)
       (SYMBOL-PROVENANCE (CAR FORM))
     (IF SECTION
         (MULTIPLE-VALUE-BIND (TYPE LOCAL)
             (FUNCTION-INFORMATION SYMBOL ENV)
           (CASE TYPE
             (:MACRO
              (INDEX (WALKER-INDEX WALKER) SYMBOL SECTION
                     (MAKE-CONTEXT 'MACRO-NAME :LOCAL LOCAL))
              (CALL-NEXT-METHOD WALKER (CONS SYMBOL (CDR FORM)) ENV))
             (T (CALL-NEXT-METHOD))))
         (CALL-NEXT-METHOD)))
   (ERROR NIL FORM)))
(DEFMETHOD WALK-ATOMIC-FORM
           ((WALKER INDEXING-WALKER) (FORM SYMBOL) CONTEXT ENV &KEY TOPLEVEL)
  (DECLARE (IGNORE ENV TOPLEVEL))
  (MULTIPLE-VALUE-BIND (SYMBOL SECTION)
      (SYMBOL-PROVENANCE FORM)
    (WHEN SECTION (INDEX (WALKER-INDEX WALKER) SYMBOL SECTION CONTEXT))
    SYMBOL))
(DEFMETHOD WALK-COMPOUND-FORM :AROUND
           ((WALKER INDEXING-WALKER) (OPERATOR SYMBOL) FORM ENV &REST ARGS)
  (MULTIPLE-VALUE-BIND (SYMBOL SECTION)
      (SYMBOL-PROVENANCE OPERATOR)
    (IF SECTION
        (APPLY #'WALK-COMPOUND-FORM WALKER SYMBOL FORM ENV ARGS)
        (CALL-NEXT-METHOD))))
(DEFGENERIC DESTRUCTURE-NAME
    (NAME NAMESPACE))
(DEFGENERIC CONSTRUCT-NAME
    (SYMBOL NAME NAMESPACE))
(DEFMETHOD WALK-NAME ((WALKER INDEXING-WALKER) NAME NAMESPACE ENV &KEY DEF)
  (MULTIPLE-VALUE-BIND (SYMBOL SECTION)
      (SYMBOL-PROVENANCE (DESTRUCTURE-NAME NAME NAMESPACE))
    (LET ((NAME (CONSTRUCT-NAME SYMBOL NAME NAMESPACE)))
      (WHEN SECTION
        (INDEX (WALKER-INDEX WALKER) SYMBOL SECTION
               (IF DEF
                   NAMESPACE
                   (UPDATE-CONTEXT NAME NAMESPACE ENV))
               DEF))
      NAME)))
(DEFMETHOD WALK-BINDINGS
           ((WALKER INDEXING-WALKER) NAMES NAMESPACE ENV &KEY DECLARE)
  (LET ((SYMBOLS 'NIL) (SECTIONS 'NIL))
    (DOLIST
        (NAME NAMES
              (PROGN
               (SETF SYMBOLS (NREVERSE SYMBOLS))
               (SETF SECTIONS (NREVERSE SECTIONS))))
      (MULTIPLE-VALUE-BIND (SYMBOL SECTION)
          (SYMBOL-PROVENANCE (DESTRUCTURE-NAME NAME NAMESPACE))
        (PUSH SYMBOL SYMBOLS)
        (PUSH SECTION SECTIONS)))
    (MULTIPLE-VALUE-BIND (NAMES ENV)
        (CALL-NEXT-METHOD WALKER
         (MAPCAR (LAMBDA (SYMBOL NAME) (CONSTRUCT-NAME SYMBOL NAME NAMESPACE))
                 SYMBOLS NAMES)
         NAMESPACE ENV :DECLARE DECLARE)
      (LOOP FOR SYMBOL IN SYMBOLS
            AND SECTION IN SECTIONS
            AND NAME IN NAMES
            WHEN SECTION
            DO (INDEX (WALKER-INDEX WALKER) SYMBOL SECTION
                      (UPDATE-CONTEXT NAME NAMESPACE ENV) T))
      (VALUES NAMES ENV))))
(DEFMETHOD DESTRUCTURE-NAME (NAME NAMESPACE) (DECLARE (IGNORE NAMESPACE)) NAME)
(DEFMETHOD DESTRUCTURE-NAME (NAME (NAMESPACE FUNCTION-NAME))
  (ETYPECASE NAME (SYMBOL NAME) (SETF-FUNCTION (CADR NAME))))
(DEFMETHOD DESTRUCTURE-NAME (DEF (NAMESPACE MACRO-DEFINITION)) (CAR DEF))
(DEFMETHOD DESTRUCTURE-NAME (DEF (NAMESPACE SYMBOL-MACRO-DEFINITION)) (CAR DEF))
(DEFMETHOD CONSTRUCT-NAME (SYMBOL NAME NAMESPACE)
  (DECLARE (IGNORE NAME NAMESPACE))
  SYMBOL)
(DEFMETHOD CONSTRUCT-NAME (SYMBOL NAME (NAMESPACE FUNCTION-NAME))
  (ETYPECASE NAME (SYMBOL SYMBOL) (SETF-FUNCTION `(SETF ,SYMBOL))))
(DEFMETHOD CONSTRUCT-NAME (SYMBOL DEF (NAMESPACE MACRO-DEFINITION))
  (CONS SYMBOL (CDR DEF)))
(DEFMETHOD CONSTRUCT-NAME (SYMBOL DEF (NAMESPACE SYMBOL-MACRO-DEFINITION))
  (CONS SYMBOL (CDR DEF)))
(DEFTYPE QUOTED-SYMBOL () '(CONS (EQL QUOTE) (CONS SYMBOL NULL)))
(DEFMETHOD WALK-NAME
           ((WALKER INDEXING-WALKER) TAG (NAMESPACE CATCH-TAG) ENV &KEY CATCH)
  (TYPECASE TAG
    (QUOTED-SYMBOL
     (MULTIPLE-VALUE-BIND (SYMBOL SECTION)
         (SYMBOL-PROVENANCE (CADR TAG))
       (WHEN SECTION
         (INDEX (WALKER-INDEX WALKER) SYMBOL SECTION NAMESPACE CATCH))
       `',SYMBOL))
    (T (WALK-FORM WALKER TAG ENV))))
(DEFUN WALK-DEFUN (WALKER FORM CONTEXT ENV)
  (LET ((NAME (WALK-NAME WALKER (CADR FORM) CONTEXT ENV :DEF T)))
    `(,(CAR FORM)
      ,@(WALK-LAMBDA-EXPRESSION WALKER (CONS NAME (CDDR FORM)) CONTEXT ENV))))
(DEFINE-SPECIAL-FORM-WALKER DEFUN
    ((WALKER INDEXING-WALKER) FORM ENV &KEY TOPLEVEL)
  (DECLARE (IGNORE TOPLEVEL))
  (WALK-DEFUN WALKER FORM (MAKE-CONTEXT 'FUNCTION-NAME) ENV))
(DEFINE-SPECIAL-FORM-WALKER DEFINE-COMPILER-MACRO
    ((WALKER INDEXING-WALKER) FORM ENV &KEY TOPLEVEL)
  (DECLARE (IGNORE TOPLEVEL))
  (WALK-DEFUN WALKER FORM (MAKE-CONTEXT 'COMPILER-MACRO-NAME) ENV))
(DEFINE-SPECIAL-FORM-WALKER DEFMACRO
    ((WALKER INDEXING-WALKER) FORM ENV &KEY TOPLEVEL)
  (DECLARE (IGNORE TOPLEVEL))
  (THROW 'CONTINUE-WALK
    (WALK-DEFUN WALKER FORM (MAKE-CONTEXT 'MACRO-NAME) ENV)))
(DEFINE-SPECIAL-FORM-WALKER DEFINE-SYMBOL-MACRO
    ((WALKER INDEXING-WALKER) FORM ENV &KEY TOPLEVEL)
  (DECLARE (IGNORE TOPLEVEL))
  (LET* ((CONTEXT (MAKE-CONTEXT 'SYMBOL-MACRO-NAME))
         (NAME (WALK-NAME WALKER (CADR FORM) CONTEXT ENV :DEF T)))
    (THROW 'CONTINUE-WALK
      `(,(CAR FORM) ,NAME ,(WALK-FORM WALKER (CADDR FORM) ENV)))))
(DEFUN WALK-DEFVAR (WALKER FORM ENV)
  (THROW 'CONTINUE-WALK
    `(,(CAR FORM)
      ,(WALK-NAME WALKER (CADR FORM) (MAKE-CONTEXT 'SPECIAL-VARIABLE-NAME) ENV
                  :DEF T)
      ,@(CDDR FORM))))
(DEFINE-SPECIAL-FORM-WALKER DEFVAR
    ((WALKER INDEXING-WALKER) FORM ENV &KEY TOPLEVEL)
  (DECLARE (IGNORE TOPLEVEL))
  (WALK-DEFVAR WALKER FORM ENV))
(DEFINE-SPECIAL-FORM-WALKER DEFPARAMETER
    ((WALKER INDEXING-WALKER) FORM ENV &KEY TOPLEVEL)
  (DECLARE (IGNORE TOPLEVEL))
  (WALK-DEFVAR WALKER FORM ENV))
(DEFINE-SPECIAL-FORM-WALKER DEFCONSTANT
    ((WALKER INDEXING-WALKER) FORM ENV &REST ARGS)
  (APPLY #'CALL-NEXT-METHOD WALKER 'DEFCONSTANT
         `(DEFCONSTANT
              ,(WALK-NAME WALKER (CADR FORM) (MAKE-CONTEXT 'CONSTANT-NAME) ENV
                          :DEF T)
            ,@(WALK-LIST WALKER (CDDR FORM) ENV))
         ENV ARGS))
(DEFUN SYMBOLICATE (&REST STRINGS) (VALUES (INTERN (JOIN-STRINGS STRINGS ""))))
(DEFSTRUCT
    (STRUCTURE-DESCRIPTION (:CONC-NAME "STRUCT-")
     (:CONSTRUCTOR MAKE-STRUCTURE-DESCRIPTION
      (NAME &AUX (CONC-NAME (SYMBOLICATE NAME "-"))
       (COPIER-NAME (SYMBOLICATE "COPY-" NAME))
       (PREDICATE-NAME (SYMBOLICATE NAME "-P")))))
  (NAME NIL :TYPE SYMBOL :READ-ONLY T)
  (CONC-NAME NIL :TYPE (OR SYMBOL NULL))
  (CONSTRUCTORS NIL :TYPE LIST)
  (COPIER-NAME NIL :TYPE (OR SYMBOL NULL))
  (PREDICATE-NAME NIL :TYPE (OR SYMBOL NULL))
  (INCLUDE NIL :TYPE LIST))
(DEFUN WALK-DEFSTRUCT-NAME-AND-OPTIONS (WALKER NAME-AND-OPTIONS ENV)
  (DESTRUCTURING-BIND
      (NAME &REST OPTIONS)
      (ENSURE-LIST NAME-AND-OPTIONS)
    (LET* ((STRUCT-NAME
            (WALK-NAME WALKER NAME (MAKE-CONTEXT 'STRUCT-NAME) ENV :DEF T))
           (STRUCT-DESCRIPTION (MAKE-STRUCTURE-DESCRIPTION STRUCT-NAME)))
      (VALUES
       `(,STRUCT-NAME
         ,@(LOOP FOR OPTION IN OPTIONS
                 COLLECT (WALK-DEFSTRUCT-OPTION WALKER OPTION
                                                STRUCT-DESCRIPTION ENV)
                 FINALLY (LET ((SECTION (NTH-VALUE 1 (SYMBOL-PROVENANCE NAME))))
                           (FLET ((INDEX (NAME CONTEXT-TYPE)
                                    (WHEN NAME
                                      (INDEX (WALKER-INDEX WALKER) NAME SECTION
                                             (MAKE-CONTEXT CONTEXT-TYPE) T))))
                             (LOOP FOR (NAME . ARGLIST) IN (OR
                                                            (STRUCT-CONSTRUCTORS
                                                             STRUCT-DESCRIPTION)
                                                            `((,(SYMBOLICATE
                                                                 "MAKE-"
                                                                 STRUCT-NAME))))
                                   DO (INDEX NAME
                                             (IF ARGLIST
                                                 'STRUCT-BOA-CONSTRUCTOR
                                                 'STRUCT-CONSTRUCTOR-NAME)))
                             (INDEX (STRUCT-COPIER-NAME STRUCT-DESCRIPTION)
                                    'STRUCT-COPIER-NAME)
                             (INDEX (STRUCT-PREDICATE-NAME STRUCT-DESCRIPTION)
                                    'STRUCT-PREDICATE-NAME)))))
       STRUCT-DESCRIPTION))))
(DEFUN WALK-DEFSTRUCT-OPTION (WALKER OPTION DESCRIPTION ENV)
  (COND
   ((MEMBER OPTION '(:CONC-NAME :CONSTRUCTOR :COPIER :PREDICATE))
    (WALK-DEFSTRUCT-OPTION WALKER (LIST OPTION) DESCRIPTION ENV))
   ((ATOM OPTION) OPTION)
   (T
    `(,(FIRST OPTION)
      ,@(ENSURE-LIST
         (LET ((ARGS (REST OPTION)) (STRUCT-NAME (STRUCT-NAME DESCRIPTION)))
           (CASE (FIRST OPTION)
             (:CONC-NAME
              (DESTRUCTURING-BIND
                  (&OPTIONAL CONC-NAME)
                  ARGS
                (SETF (STRUCT-CONC-NAME DESCRIPTION)
                        (IF (SYMBOLP CONC-NAME)
                            (WALK-ATOMIC-FORM WALKER CONC-NAME NIL ENV)
                            (MAKE-SYMBOL (STRING CONC-NAME))))))
             (:CONSTRUCTOR
              (DESTRUCTURING-BIND
                  (
                   &OPTIONAL (NAME (SYMBOLICATE "MAKE-" STRUCT-NAME))
                   &REST ARGLIST)
                  ARGS
                (LET* ((CONTEXT
                        (MAKE-CONTEXT
                         (IF ARGLIST
                             'STRUCT-BOA-CONSTRUCTOR
                             'STRUCT-CONSTRUCTOR-NAME)))
                       (NAME (WALK-NAME WALKER NAME CONTEXT ENV :DEF T)))
                  (CAR
                   (PUSH (CONS NAME ARGLIST)
                         (STRUCT-CONSTRUCTORS DESCRIPTION))))))
             (:COPIER
              (DESTRUCTURING-BIND
                  (&OPTIONAL (NAME (SYMBOLICATE "COPY-" STRUCT-NAME)))
                  ARGS
                (SETF (STRUCT-COPIER-NAME DESCRIPTION)
                        (WALK-NAME WALKER NAME
                                   (MAKE-CONTEXT 'STRUCT-COPIER-NAME) ENV :DEF
                                   T))))
             (:PREDICATE
              (DESTRUCTURING-BIND
                  (&OPTIONAL (NAME (SYMBOLICATE STRUCT-NAME "-P")))
                  ARGS
                (SETF (STRUCT-PREDICATE-NAME DESCRIPTION)
                        (WALK-NAME WALKER NAME
                                   (MAKE-CONTEXT 'STRUCT-PREDICATE-NAME) ENV
                                   :DEF T))))
             (:INCLUDE
              (DESTRUCTURING-BIND
                  (NAME &REST SLOT-DESCRIPTIONS)
                  ARGS
                (SETF (STRUCT-INCLUDE DESCRIPTION)
                        `(,(WALK-NAME WALKER NAME (MAKE-CONTEXT 'STRUCT-NAME)
                                      ENV)
                          ,@(MAPCAR
                             (LAMBDA (SLOT-DESCRIPTION)
                               (WALK-DEFSTRUCT-SLOT-DESCRIPTION WALKER
                                                                SLOT-DESCRIPTION
                                                                DESCRIPTION
                                                                ENV))
                             SLOT-DESCRIPTIONS)))))
             (T (WALK-LIST WALKER ARGS ENV)))))))))
(DEFUN WALK-DEFSTRUCT-SLOT-DESCRIPTION
       (WALKER SLOT-DESCRIPTION STRUCT-DESCRIPTION ENV)
  (TYPECASE SLOT-DESCRIPTION
    (SYMBOL
     (WALK-DEFSTRUCT-SLOT-NAME WALKER SLOT-DESCRIPTION NIL STRUCT-DESCRIPTION
                               ENV))
    (CONS
     (DESTRUCTURING-BIND
         (SLOT-NAME
          &OPTIONAL (SLOT-INITFORM NIL INITFORM-SUPPLIED)
          &REST SLOT-OPTIONS)
         SLOT-DESCRIPTION
       `(,(WALK-DEFSTRUCT-SLOT-NAME WALKER SLOT-NAME SLOT-OPTIONS
                                    STRUCT-DESCRIPTION ENV)
         ,@(WHEN INITFORM-SUPPLIED `(,(WALK-FORM WALKER SLOT-INITFORM ENV)))
         ,@(LET ((SLOT-OPTIONS (COPY-LIST SLOT-OPTIONS)))
             (REMF SLOT-OPTIONS :TYPE)
             SLOT-OPTIONS))))
    (T SLOT-DESCRIPTION)))
(DEFUN WALK-DEFSTRUCT-SLOT-NAME
       (WALKER SLOT-NAME SLOT-OPTIONS STRUCT-DESCRIPTION ENV)
  (DECLARE (IGNORE ENV))
  (MULTIPLE-VALUE-BIND (SYMBOL SECTION)
      (SYMBOL-PROVENANCE SLOT-NAME)
    (LET ((NAME (SYMBOLICATE (STRUCT-CONC-NAME STRUCT-DESCRIPTION) SYMBOL))
          (READER (MAKE-CONTEXT 'STRUCT-SLOT-READER))
          (ACCESSOR (MAKE-CONTEXT 'STRUCT-SLOT-ACCESSOR))
          (INDEX (WALKER-INDEX WALKER)))
      (UNLESS
          (AND (STRUCT-INCLUDE STRUCT-DESCRIPTION)
               (SOME #'LOCATOR-DEFINITION-P
                     (OR
                      (FIND-INDEX-ENTRIES INDEX (MAKE-HEADING NAME ACCESSOR))
                      (FIND-INDEX-ENTRIES INDEX (MAKE-HEADING NAME READER)))))
        (INDEX INDEX NAME SECTION
               (IF (GETF SLOT-OPTIONS :READ-ONLY)
                   READER
                   ACCESSOR)
               T)))
    SYMBOL))
(DEFINE-SPECIAL-FORM-WALKER DEFSTRUCT
    ((WALKER INDEXING-WALKER) FORM ENV &KEY TOPLEVEL)
  (DECLARE (IGNORE TOPLEVEL))
  (LET ((STRUCTURE-DESCRIPTION) (NAME-AND-OPTIONS))
    (DECLARE (IGNORABLE NAME-AND-OPTIONS))
    (THROW 'CONTINUE-WALK
      `(,(POP FORM)
        ,(MULTIPLE-VALUE-SETQ (NAME-AND-OPTIONS STRUCTURE-DESCRIPTION)
           (WALK-DEFSTRUCT-NAME-AND-OPTIONS WALKER (POP FORM) ENV))
        ,@(AND (STRINGP (CAR FORM)) (LIST (POP FORM)))
        ,@(MAPCAR
           (LAMBDA (SLOT-DESCRIPTION)
             (WALK-DEFSTRUCT-SLOT-DESCRIPTION WALKER SLOT-DESCRIPTION
                                              STRUCTURE-DESCRIPTION ENV))
           FORM)))))
(DEFMETHOD HEADING-NAME :OVERRIDE ((HEADING STRUCT-BOA-CONSTRUCTOR))
  "{\\sc boa} constructor")
(DEFMACRO POP-QUALIFIERS (PLACE)
  `(LOOP UNTIL (LISTP (CAR ,PLACE))
         COLLECT (POP ,PLACE)))
(DEFINE-SPECIAL-FORM-WALKER DEFGENERIC
    ((WALKER INDEXING-WALKER) FORM ENV &KEY TOPLEVEL)
  (DECLARE (IGNORE TOPLEVEL))
  (DESTRUCTURING-BIND
      (OPERATOR FUNCTION-NAME LAMBDA-LIST &REST OPTIONS)
      FORM
    `(,OPERATOR
      ,(NOTE-GENERIC-FUNCTION
        (WALK-NAME WALKER FUNCTION-NAME
                   (MAKE-CONTEXT
                    (ETYPECASE FUNCTION-NAME
                      (SYMBOL 'GENERIC-FUNCTION-NAME)
                      (SETF-FUNCTION 'GENERIC-SETF-FUNCTION-NAME)))
                   ENV :DEF T))
      ,(WALK-LAMBDA-LIST WALKER LAMBDA-LIST NIL ENV)
      ,@(LOOP FOR FORM IN OPTIONS
              COLLECT (CASE (CAR FORM)
                        (:METHOD-COMBINATION
                         `(,(CAR FORM)
                           ,(WALK-ATOMIC-FORM WALKER (CADR FORM)
                                              (MAKE-CONTEXT
                                               'METHOD-COMBINATION-NAME)
                                              ENV)
                           ,@(WALK-LIST WALKER (CDDR FORM) ENV)))
                        (:METHOD
                         (LET* ((OPERATOR (POP FORM))
                                (QUALIFIERS
                                 (MAPCAR
                                  (LAMBDA (Q)
                                    (WALK-ATOMIC-FORM WALKER Q NIL ENV))
                                  (POP-QUALIFIERS FORM)))
                                (LAMBDA-LIST (POP FORM))
                                (BODY FORM))
                           (WALK-NAME WALKER FUNCTION-NAME
                                      (MAKE-CONTEXT 'METHOD-NAME :QUALIFIERS
                                                    QUALIFIERS)
                                      ENV :DEF T)
                           (WALK-METHOD-DEFINITION WALKER OPERATOR NIL
                                                   QUALIFIERS LAMBDA-LIST BODY
                                                   ENV)))
                        (T (WALK-LIST WALKER FORM ENV)))))))
(DEFUN NOTE-GENERIC-FUNCTION (FUNCTION-NAME)
  (TYPECASE FUNCTION-NAME
    (SYMBOL (SETF (GET FUNCTION-NAME 'GENERIC-FUNCTION) T))
    (SETF-FUNCTION (SETF (GET (CADR FUNCTION-NAME) 'GENERIC-SETF-FUNCTION) T)))
  FUNCTION-NAME)
(DEFUN GENERIC-FUNCTION-P (FUNCTION-NAME)
  (IF (FBOUNDP FUNCTION-NAME)
      (TYPEP (FDEFINITION FUNCTION-NAME) 'GENERIC-FUNCTION)
      (TYPECASE FUNCTION-NAME
        (SYMBOL (GET FUNCTION-NAME 'GENERIC-FUNCTION))
        (SETF-FUNCTION (GET (CADR FUNCTION-NAME) 'GENERIC-SETF-FUNCTION)))))
(DEFUN WALK-METHOD-DEFINITION
       (WALKER OPERATOR FUNCTION-NAME QUALIFIERS LAMBDA-LIST BODY ENV)
  (MULTIPLE-VALUE-BIND (BODY-FORMS DECLS DOC)
      (PARSE-BODY BODY :WALKER WALKER :ENV ENV)
    (MULTIPLE-VALUE-BIND (LAMBDA-LIST ENV)
        (WALK-SPECIALIZED-LAMBDA-LIST WALKER LAMBDA-LIST DECLS ENV)
      `(,OPERATOR ,@(WHEN FUNCTION-NAME `(,FUNCTION-NAME)) ,@QUALIFIERS
        ,LAMBDA-LIST ,@(WHEN DOC `(,DOC)) ,@(WHEN DECLS `((DECLARE ,@DECLS)))
        ,@(WALK-LIST WALKER BODY-FORMS ENV)))))
(DEFINE-SPECIAL-FORM-WALKER DEFMETHOD
    ((WALKER INDEXING-WALKER) FORM ENV &KEY TOPLEVEL &AUX (OPERATOR (POP FORM))
     (FUNCTION-NAME (POP FORM))
     (QUALIFIERS
      (MAPCAR (LAMBDA (Q) (WALK-ATOMIC-FORM WALKER Q NIL ENV))
              (POP-QUALIFIERS FORM)))
     (LAMBDA-LIST (POP FORM)) (BODY FORM))
  (DECLARE (IGNORE TOPLEVEL))
  (WALK-METHOD-DEFINITION WALKER OPERATOR
                          (NOTE-GENERIC-FUNCTION
                           (WALK-NAME WALKER FUNCTION-NAME
                                      (MAKE-CONTEXT
                                       (ETYPECASE FUNCTION-NAME
                                         (SYMBOL 'METHOD-NAME)
                                         (SETF-FUNCTION 'SETF-METHOD-NAME))
                                       :QUALIFIERS QUALIFIERS)
                                      ENV :DEF T))
                          QUALIFIERS LAMBDA-LIST BODY ENV))
(DEFUN WALK-DEFCLASS (WALKER FORM CONTEXT ENV)
  (DESTRUCTURING-BIND
      (OPERATOR NAME SUPERS SLOT-SPECS &REST OPTIONS)
      FORM
    (THROW 'CONTINUE-WALK
      `(,OPERATOR ,(WALK-NAME WALKER NAME CONTEXT ENV :DEF T)
        ,(MAPCAR (LAMBDA (SUPER) (WALK-NAME WALKER SUPER CONTEXT ENV)) SUPERS)
        ,(MAPCAR (LAMBDA (SPEC) (WALK-SLOT-SPECIFIER WALKER SPEC ENV))
                 SLOT-SPECS)
        ,@(WALK-LIST WALKER OPTIONS ENV)))))
(DEFINE-SPECIAL-FORM-WALKER DEFCLASS
    ((WALKER INDEXING-WALKER) FORM ENV &KEY TOPLEVEL)
  (DECLARE (IGNORE TOPLEVEL))
  (WALK-DEFCLASS WALKER FORM (MAKE-CONTEXT 'CLASS-NAME%) ENV))
(DEFINE-SPECIAL-FORM-WALKER DEFINE-CONDITION
    ((WALKER INDEXING-WALKER) FORM ENV &KEY TOPLEVEL)
  (DECLARE (IGNORE TOPLEVEL))
  (WALK-DEFCLASS WALKER FORM (MAKE-CONTEXT 'CONDITION-CLASS-NAME) ENV))
(DEFUN WALK-SLOT-SPECIFIER (WALKER SPEC ENV)
  (ETYPECASE SPEC
    (SYMBOL (WALK-NAME WALKER SPEC (MAKE-CONTEXT 'SLOT-NAME) ENV))
    (CONS
     (DESTRUCTURING-BIND
         (NAME &REST OPTIONS)
         SPEC
       `(,(WALK-NAME WALKER NAME (MAKE-CONTEXT 'SLOT-NAME) ENV :DEF T)
         ,@(LOOP FOR (OPT-NAME OPT-VALUE) ON OPTIONS BY #'CDDR
                 IF (MEMBER OPT-NAME '(:READER :WRITER :ACCESSOR))
                 APPEND `(,OPT-NAME
                          ,(WALK-NAME WALKER OPT-VALUE
                                      (MAKE-CONTEXT 'METHOD-NAME :QUALIFIERS
                                                    (LIST OPT-NAME))
                                      ENV :DEF T)) ELSE
                 APPEND `(,OPT-NAME ,OPT-VALUE)))))))
(DEFINE-SPECIAL-FORM-WALKER DEFINE-METHOD-COMBINATION
    ((WALKER INDEXING-WALKER) FORM ENV &KEY TOPLEVEL)
  (DECLARE (IGNORE TOPLEVEL))
  `(,(CAR FORM)
    ,(WALK-NAME WALKER (CADR FORM) (MAKE-CONTEXT 'METHOD-COMBINATION-NAME) ENV
                :DEF T)
    ,@(WALK-LIST WALKER (CDDR FORM) ENV)))
(DEFCLASS SECTION-RANGE NIL
          ((START :READER START-SECTION :INITARG :START)
           (END :READER END-SECTION :INITARG :END)))
(DEFUN COALESCE-LOCATORS (LOCATORS)
  (FLET ((MAYBE-MAKE-SECTION-RANGE (START END)
           (COND ((EQL START END) START)
                 ((AND START END)
                  (MAKE-INSTANCE 'SECTION-RANGE :START (LOCATION START) :END
                                 (LOCATION END))))))
    (DO* ((LOCATORS LOCATORS (CDR LOCATORS))
          (LOC (CAR LOCATORS) (CAR LOCATORS))
          (COALESCED-LOCATORS 'NIL)
          START
          END)
         ((ENDP LOCATORS)
          (NRECONC COALESCED-LOCATORS
                   (ENSURE-LIST (MAYBE-MAKE-SECTION-RANGE START END))))
      (FLET ((MAYBE-PUSH-RANGE (START END)
               (LET ((RANGE (MAYBE-MAKE-SECTION-RANGE START END)))
                 (WHEN RANGE (PUSH RANGE COALESCED-LOCATORS)))))
        (COND
         ((LOCATOR-DEFINITION-P LOC) (MAYBE-PUSH-RANGE START END)
          (PUSH LOC COALESCED-LOCATORS)
          (SETQ START NIL
                END NIL))
         ((AND END
               (= (SECTION-NUMBER (LOCATION LOC))
                  (1+ (SECTION-NUMBER (LOCATION END)))))
          (SETQ END LOC))
         (T (MAYBE-PUSH-RANGE START END)
          (SETQ START LOC
                END START)))))))
(SET-WEAVE-DISPATCH 'INDEX
                    (LAMBDA (STREAM INDEX)
                      (MAP-BST (LAMBDA (ENTRY) (WRITE ENTRY :STREAM STREAM))
                               (INDEX-ENTRIES INDEX))))
(SET-WEAVE-DISPATCH 'INDEX-ENTRY
                    (LAMBDA (STREAM ENTRY)
                      (FORMAT STREAM
                              "\\I~/clweb::print-entry-heading/~{, ~W~}.~%"
                              (ENTRY-HEADING ENTRY)
                              (COALESCE-LOCATORS
                               (SORT (COPY-LIST (ENTRY-LOCATORS ENTRY)) #'<
                                     :KEY
                                     (LAMBDA (LOC)
                                       (SECTION-NUMBER (LOCATION LOC))))))))
(SET-WEAVE-DISPATCH 'SECTION-RANGE
                    (LAMBDA (STREAM RANGE)
                      (FORMAT STREAM "~D--~D"
                              (SECTION-NUMBER (START-SECTION RANGE))
                              (SECTION-NUMBER (END-SECTION RANGE)))))
(SET-WEAVE-DISPATCH 'SECTION-LOCATOR
                    (LAMBDA (STREAM LOC)
                      (FORMAT STREAM "~:[~D~;\\[~D]~]"
                              (LOCATOR-DEFINITION-P LOC)
                              (SECTION-NUMBER (LOCATION LOC)))))
(DEFGENERIC PRINT-ENTRY-HEADING
    (STREAM HEADING &REST ARGS &KEY &ALLOW-OTHER-KEYS))
(DEFMETHOD PRINT-ENTRY-HEADING (STREAM (HEADING HEADING) &KEY)
  (PRINT-ENTRY-HEADING STREAM (SLOT-VALUE HEADING 'NAME))
  (WHEN (SUB-HEADING HEADING)
    (WRITE-CHAR #\  STREAM)
    (PRINT-ENTRY-HEADING STREAM (SUB-HEADING HEADING))))
(DEFMETHOD PRINT-ENTRY-HEADING (STREAM (HEADING NAMESPACE) &KEY)
  (WRITE-STRING (HEADING-NAME HEADING) STREAM))
(DEFMETHOD PRINT-ENTRY-HEADING (STREAM (HEADING CHARACTER) &KEY)
  (PRINT-CHAR STREAM HEADING))
(DEFMETHOD PRINT-ENTRY-HEADING (STREAM (HEADING STRING) &KEY)
  (WRITE-CHAR #\{ STREAM)
  (PRINT-TEX STREAM (READ-TEX-FROM-STRING HEADING))
  (WRITE-CHAR #\} STREAM))
(DEFMETHOD PRINT-ENTRY-HEADING (STREAM (HEADING SYMBOL) &KEY)
  (FORMAT STREAM "\\(~W\\)" HEADING))
(DEFMETHOD PRINT-ENTRY-HEADING :BEFORE (STREAM (HEADING PRETTY-HEADING) &KEY)
  (WRITE-STRING (MACRO-HEADING HEADING) STREAM))
(DEFCLASS MACRO-CHAR-HEADING (HEADING)
          ((NAME :READER MACRO-CHAR :INITARG :CHAR)))
(DEFCLASS DISPATCH-MACRO-CHAR-HEADING (MACRO-CHAR-HEADING)
          ((SUB-CHAR :READER MACRO-SUB-CHAR :INITARG :SUB-CHAR)))
(DEFMETHOD SUB-HEADING ((HEADING DISPATCH-MACRO-CHAR-HEADING))
  (MACRO-SUB-CHAR HEADING))
(DEFUN MAKE-MACRO-CHAR-HEADING
       (CHAR &OPTIONAL (SUB-CHAR NIL SUB-CHAR-SUPPLIED-P))
  (IF SUB-CHAR-SUPPLIED-P
      (MAKE-INSTANCE 'DISPATCH-MACRO-CHAR-HEADING :CHAR CHAR :SUB-CHAR
                     (AND (CHARACTERP SUB-CHAR) SUB-CHAR))
      (MAKE-INSTANCE 'MACRO-CHAR-HEADING :CHAR CHAR)))
(DEFMETHOD PRINT-ENTRY-HEADING :AFTER
           (STREAM (HEADING MACRO-CHAR-HEADING) &KEY)
  (FORMAT STREAM " ~:[~;dispatch ~]macro character"
          (TYPEP HEADING 'DISPATCH-MACRO-CHAR-HEADING)))
(DEFMETHOD ENTRY-HEADING-LESSP ((H1 MACRO-CHAR-HEADING) H2)
  (DECLARE (IGNORE H2))
  T)
(DEFMETHOD ENTRY-HEADING-LESSP (H1 (H2 MACRO-CHAR-HEADING))
  (DECLARE (IGNORE H1))
  NIL)
(DEFMETHOD ENTRY-HEADING-LESSP
           ((H1 MACRO-CHAR-HEADING) (H2 DISPATCH-MACRO-CHAR-HEADING))
  T)
(DEFMETHOD ENTRY-HEADING-LESSP
           ((H1 DISPATCH-MACRO-CHAR-HEADING) (H2 MACRO-CHAR-HEADING))
  NIL)
(DEFMETHOD ENTRY-HEADING-LESSP
           ((H1 MACRO-CHAR-HEADING) (H2 MACRO-CHAR-HEADING))
  (CHAR-LESSP (MACRO-CHAR H1) (MACRO-CHAR H2)))
(DEFMETHOD ENTRY-HEADING-LESSP
           ((H1 DISPATCH-MACRO-CHAR-HEADING) (H2 DISPATCH-MACRO-CHAR-HEADING))
  (AND (NOT (CHAR-LESSP (MACRO-CHAR H2) (MACRO-CHAR H1)))
       (OR (AND (NOT (MACRO-SUB-CHAR H1)) (MACRO-SUB-CHAR H2))
           (AND (MACRO-SUB-CHAR H1) (MACRO-SUB-CHAR H2)
                (CHAR-LESSP (MACRO-SUB-CHAR H1) (MACRO-SUB-CHAR H2))))))
(DEFMETHOD ENTRY-HEADING-EQUALP ((H1 MACRO-CHAR-HEADING) H2)
  (DECLARE (IGNORE H2))
  NIL)
(DEFMETHOD ENTRY-HEADING-EQUALP (H1 (H2 MACRO-CHAR-HEADING))
  (DECLARE (IGNORE H1))
  NIL)
(DEFMETHOD ENTRY-HEADING-EQUALP
           ((H1 MACRO-CHAR-HEADING) (H2 MACRO-CHAR-HEADING))
  (AND (CHAR-EQUAL (MACRO-CHAR H1) (MACRO-CHAR H2))
       (EQUALP (SUB-HEADING H1) (SUB-HEADING H2))))
(DEFMETHOD INTERESTING-SYMBOL-P ((OBJECT (EQL 'SET-MACRO-CHARACTER))) T)
(DEFMETHOD INTERESTING-SYMBOL-P ((OBJECT (EQL 'SET-DISPATCH-MACRO-CHARACTER)))
  T)
(DEFMETHOD WALK-COMPOUND-FORM
           ((WALKER INDEXING-WALKER) (OPERATOR (EQL 'SET-MACRO-CHARACTER)) FORM
            ENV
            &KEY TOPLEVEL)
  (DECLARE (IGNORE TOPLEVEL))
  (MULTIPLE-VALUE-BIND (SYMBOL SECTION)
      (SYMBOL-PROVENANCE (CAR FORM))
    (WHEN (AND SECTION (CHARACTERP (SECOND FORM)))
      (ADD-INDEX-ENTRY (WALKER-INDEX WALKER)
                       (MAKE-MACRO-CHAR-HEADING (SECOND FORM)) SECTION T))
    `(,SYMBOL ,@(WALK-LIST WALKER (CDR FORM) ENV))))
(DEFMETHOD WALK-COMPOUND-FORM
           ((WALKER INDEXING-WALKER)
            (OPERATOR (EQL 'SET-DISPATCH-MACRO-CHARACTER)) FORM ENV
            &KEY TOPLEVEL)
  (DECLARE (IGNORE TOPLEVEL))
  (MULTIPLE-VALUE-BIND (SYMBOL SECTION)
      (SYMBOL-PROVENANCE (CAR FORM))
    (WHEN (AND SECTION (CHARACTERP (SECOND FORM)))
      (ADD-INDEX-ENTRY (WALKER-INDEX WALKER)
                       (MAKE-MACRO-CHAR-HEADING (SECOND FORM) (THIRD FORM))
                       SECTION T))
    `(,SYMBOL ,@(WALK-LIST WALKER (CDR FORM) ENV))))