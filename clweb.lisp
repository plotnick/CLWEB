;;;; TANGLED WEB FROM "clweb.clw". DO NOT EDIT.
#+ALLEGRO
(EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL)
  (SETQ EXCL:*SOURCE-PATHNAME* #P"clweb.clw"))

(PROVIDE "CLWEB")
(EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)
  #+:SBCL (require "SB-CLTL2"))
(DEFPACKAGE "CLWEB"
  (:USE "COMMON-LISP" #+:SBCL "SB-CLTL2" #+:ALLEGRO "SYS" #+:CCL "CCL")
  (:EXPORT "TANGLE-FILE"
           "LOAD-WEB"
           "WEAVE"
           "LOAD-SECTIONS-FROM-TEMP-FILE"
           "*TANGLE-FILE-PATHNAME*"
           "*TANGLE-FILE-TRUENAME*"
           "*WEAVE-PRINT*"
           "*WEAVE-VERBOSE*"
           "*INDEX-LEXICAL-VARIABLES*"
           "AMBIGUOUS-PREFIX-ERROR"
           "SECTION-NAME-CONTEXT-ERROR"
           "SECTION-NAME-USE-ERROR"
           "SECTION-NAME-DEFINITION-ERROR"
           "UNUSED-NAMED-SECTION-WARNING")
  (:SHADOW "ENCLOSE"
           #+:ALLEGRO "FUNCTION-INFORMATION"
           #+:ALLEGRO "VARIABLE-INFORMATION"))
(IN-PACKAGE "CLWEB")
(DEFVAR *SECTIONS* (MAKE-ARRAY 128 :ADJUSTABLE T :FILL-POINTER 0))
(DEFVAR *CURRENT-SECTION* NIL)
(DEFVAR *TEST-SECTIONS* (MAKE-ARRAY 128 :ADJUSTABLE T :FILL-POINTER 0))
(DEFVAR *NAMED-SECTIONS* NIL)
(DEFPARAMETER *WHITESPACE*
  #.(COERCE '(#\  #\Tab #\Newline #\Newline #\Page #\Return) 'STRING))
(EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)
  (DEFPARAMETER *MODES* '(:LIMBO :TEX :LISP :INNER-LISP :RESTRICTED)))
(DEFTYPE MODE () `(MEMBER ,@*MODES*))
(DEFVAR *READTABLES*
  (LOOP FOR MODE IN (CONS NIL *MODES*)
        COLLECT (CONS MODE (COPY-READTABLE NIL))))
(DEFVAR *EOF* (MAKE-SYMBOL "EOF"))
(DEFVAR *TAB-WIDTH* 8)
(DEFVAR *CHARPOS-STREAMS* (MAKE-HASH-TABLE :TEST #'EQ))
(DEFVAR *EVALUATING* NIL)
(DEFPARAMETER *TANGLE-PPRINT-DISPATCH* (COPY-PPRINT-DISPATCH NIL))
(DEFVAR *TANGLE-FILE-PATHNAME* NIL)
(DEFVAR *TANGLE-FILE-TRUENAME* NIL)
(DEFVAR *WEAVE-VERBOSE* T "The default for the :VERBOSE argument to WEAVE.")
(DEFVAR *WEAVE-PRINT* T "The default for the :PRINT argument to WEAVE.")
(DEFPARAMETER *WEAVE-PPRINT-DISPATCH* (COPY-PPRINT-DISPATCH NIL))
(DEFVAR *PRINT-SYMBOL-SUFFIXES*
  '(("/=" . "$\\neq$") ("<=" . "$\\leq$") (">=" . "$\\geq$") ("<" . "$<$")
    (">" . "$>$") ("-" . "$-$") ("+" . "$+$") ("=" . "$=$")))
(DEFVAR *INDEX-PACKAGES*
  NIL
  "The list of packages whose symbols should be indexed.")
(DEFVAR *INDEX* NIL)
(DEFVAR *INDEX-LEXICAL-VARIABLES*
  NIL
  "If this flag is non-nil, the indexer will index lexical variables.")
(DEFVAR *INDEXING* NIL)
(DEFINE-CONDITION AMBIGUOUS-PREFIX-ERROR
    (ERROR)
    ((PREFIX :READER AMBIGUOUS-PREFIX :INITARG :PREFIX)
     (FIRST-MATCH :READER AMBIGUOUS-PREFIX-FIRST-MATCH :INITARG :FIRST-MATCH)
     (ALT-MATCH :READER AMBIGUOUS-PREFIX-ALT-MATCH :INITARG :ALT-MATCH))
  (:REPORT
   (LAMBDA (CONDITION STREAM)
     (FORMAT STREAM "~@<Ambiguous prefix: <~A> matches both <~A> and <~A>~:@>"
             (AMBIGUOUS-PREFIX CONDITION)
             (AMBIGUOUS-PREFIX-FIRST-MATCH CONDITION)
             (AMBIGUOUS-PREFIX-ALT-MATCH CONDITION)))))
(DEFINE-CONDITION SIMPLE-READER-ERROR
    (READER-ERROR SIMPLE-CONDITION)
    NIL
  (:REPORT
   (LAMBDA (CONDITION STREAM)
     (FORMAT STREAM "~S on ~S:~%~?" CONDITION (STREAM-ERROR-STREAM CONDITION)
             (SIMPLE-CONDITION-FORMAT-CONTROL CONDITION)
             (SIMPLE-CONDITION-FORMAT-ARGUMENTS CONDITION)))))
(DEFUN SIMPLE-READER-ERROR (STREAM CONTROL &REST ARGS)
  (ERROR 'SIMPLE-READER-ERROR :STREAM STREAM :FORMAT-CONTROL CONTROL
         :FORMAT-ARGUMENTS ARGS))
(DEFINE-CONDITION SECTION-NAME-CONTEXT-ERROR
    (ERROR)
    ((NAME :READER SECTION-NAME :INITARG :NAME)))
(DEFINE-CONDITION SECTION-NAME-DEFINITION-ERROR
    (SECTION-NAME-CONTEXT-ERROR)
    NIL
  (:REPORT
   (LAMBDA (CONDITION STREAM)
     (FORMAT STREAM "Can't define a named section in Lisp mode: ~A"
             (SECTION-NAME CONDITION)))))
(DEFINE-CONDITION SECTION-NAME-USE-ERROR
    (SECTION-NAME-CONTEXT-ERROR)
    NIL
  (:REPORT
   (LAMBDA (CONDITION STREAM)
     (FORMAT STREAM "Can't use a section name in TeX mode: ~A"
             (SECTION-NAME CONDITION)))))
(DEFINE-CONDITION SECTION-LACKS-COMMENTARY
    (PARSE-ERROR)
    ((STREAM :INITARG :STREAM :READER SECTION-LACKS-COMMENTARY-STREAM))
  (:REPORT
   (LAMBDA (ERROR STREAM)
     (LET* ((INPUT-STREAM
             (DO ((STREAM (SECTION-LACKS-COMMENTARY-STREAM ERROR)))
                 (NIL)
               (TYPECASE STREAM
                 (ECHO-STREAM (SETQ STREAM (ECHO-STREAM-INPUT-STREAM STREAM)))
                 (T (RETURN STREAM)))))
            (POSITION (FILE-POSITION INPUT-STREAM))
            (PATHNAME
             (WHEN (TYPEP INPUT-STREAM 'FILE-STREAM) (PATHNAME INPUT-STREAM))))
       (FORMAT STREAM "~@<Can't start a section with a code part ~
~:[~;~:*at position ~D in file ~A.~]~:@>"
               POSITION (OR PATHNAME INPUT-STREAM))))))
(DEFINE-CONDITION UNUSED-NAMED-SECTION-WARNING
    (SIMPLE-WARNING)
    NIL)
(DEFINE-CONDITION INVALID-FUNCTION-NAME
    (PARSE-ERROR)
    ((NAME :INITARG :NAME :READER INVALID-FUNCTION-NAME))
  (:REPORT
   (LAMBDA (ERROR STREAM)
     (FORMAT STREAM "~@<Invalid function name ~A.~:@>"
             (INVALID-FUNCTION-NAME ERROR)))))
(DEFUN ENSURE-LIST (OBJECT)
  (IF (LISTP OBJECT)
      OBJECT
      (LIST OBJECT)))
(DEFUN MAPAPPEND (FUNCTION &REST ARGS)
  (IF (SOME #'NULL ARGS)
      NIL
      (APPEND (APPLY FUNCTION (MAPCAR #'CAR ARGS))
              (APPLY #'MAPAPPEND FUNCTION (MAPCAR #'CDR ARGS)))))
(DEFCLASS SECTION NIL
          ((NAME :ACCESSOR SECTION-NAME :INITARG :NAME)
           (NUMBER :ACCESSOR SECTION-NUMBER)
           (COMMENTARY :ACCESSOR SECTION-COMMENTARY :INITARG :COMMENTARY)
           (CODE :ACCESSOR SECTION-CODE :INITARG :CODE))
          (:DEFAULT-INITARGS :NAME NIL :COMMENTARY NIL :CODE NIL))
(DEFCLASS STARRED-SECTION (SECTION) NIL)
(DEFCLASS TEST-SECTION (SECTION)
          ((TEST-FOR :ACCESSOR TEST-FOR-SECTION :INITFORM NIL)))
(DEFCLASS STARRED-TEST-SECTION (TEST-SECTION STARRED-SECTION) NIL)
(DEFUN TEST-SECTION-P (X) (TYPEP X 'TEST-SECTION))
(DEFMETHOD INITIALIZE-INSTANCE :AFTER ((SECTION TEST-SECTION) &KEY)
  (WHEN (> (FILL-POINTER *SECTIONS*) 0)
    (SETF (TEST-FOR-SECTION SECTION)
            (ELT *SECTIONS* (1- (FILL-POINTER *SECTIONS*))))))
(DEFCLASS LIMBO-SECTION (SECTION) NIL)
(DEFGENERIC PUSH-SECTION
    (SECTION))
(DEFMETHOD PUSH-SECTION ((SECTION SECTION))
  (SETF (SECTION-NUMBER SECTION) (VECTOR-PUSH-EXTEND SECTION *SECTIONS*))
  SECTION)
(DEFMETHOD INITIALIZE-INSTANCE :AFTER ((SECTION SECTION) &KEY)
  (SETQ *CURRENT-SECTION* (PUSH-SECTION SECTION)))
(DEFMETHOD PUSH-SECTION ((SECTION TEST-SECTION))
  (LET ((*SECTIONS* *TEST-SECTIONS*))
    (CALL-NEXT-METHOD)))
(DEFMETHOD PUSH-SECTION :AFTER ((SECTION LIMBO-SECTION))
  (VECTOR-PUSH-EXTEND SECTION *TEST-SECTIONS*))
(DEFCLASS BINARY-SEARCH-TREE NIL
          ((KEY :ACCESSOR NODE-KEY :INITARG :KEY)
           (LEFT-CHILD :ACCESSOR LEFT-CHILD :INITARG :LEFT)
           (RIGHT-CHILD :ACCESSOR RIGHT-CHILD :INITARG :RIGHT))
          (:DEFAULT-INITARGS :LEFT NIL :RIGHT NIL))
(DEFGENERIC FIND-OR-INSERT
    (ITEM ROOT &KEY PREDICATE TEST INSERT-IF-NOT-FOUND))
(DEFMETHOD FIND-OR-INSERT
           (ITEM (ROOT BINARY-SEARCH-TREE)
            &KEY (PREDICATE #'<) (TEST #'EQL) (INSERT-IF-NOT-FOUND T))
  (FLET ((LESSP (ITEM NODE)
           (FUNCALL PREDICATE ITEM (NODE-KEY NODE)))
         (SAMEP (ITEM NODE)
           (FUNCALL TEST ITEM (NODE-KEY NODE))))
    (DO ((PARENT NIL NODE)
         (NODE ROOT
               (IF (LESSP ITEM NODE)
                   (LEFT-CHILD NODE)
                   (RIGHT-CHILD NODE))))
        ((OR (NULL NODE) (SAMEP ITEM NODE))
         (IF NODE
             (VALUES NODE T)
             (IF INSERT-IF-NOT-FOUND
                 (LET ((NODE (MAKE-INSTANCE (CLASS-OF ROOT) :KEY ITEM)))
                   (WHEN PARENT
                     (IF (LESSP ITEM PARENT)
                         (SETF (LEFT-CHILD PARENT) NODE)
                         (SETF (RIGHT-CHILD PARENT) NODE)))
                   (VALUES NODE NIL))
                 (VALUES NIL NIL)))))))
(DEFGENERIC MAP-BST
    #'TREE)
(DEFMETHOD MAP-BST (FUNCTION (TREE NULL)) (DECLARE (IGNORE FUNCTION)))
(DEFMETHOD MAP-BST (FUNCTION (TREE BINARY-SEARCH-TREE))
  (MAP-BST FUNCTION (LEFT-CHILD TREE))
  (FUNCALL FUNCTION TREE)
  (MAP-BST FUNCTION (RIGHT-CHILD TREE)))
(DEFCLASS NAMED-SECTION (BINARY-SEARCH-TREE)
          ((KEY :ACCESSOR SECTION-NAME :INITARG :NAME)
           (SECTIONS :ACCESSOR NAMED-SECTION-SECTIONS :INITFORM 'NIL)
           (USED-BY :ACCESSOR USED-BY :INITFORM 'NIL)
           (CITED-BY :ACCESSOR CITED-BY :INITFORM 'NIL)))
(DEFMETHOD NAMED-SECTION-SECTIONS :AROUND ((SECTION NAMED-SECTION))
  (SORT (COPY-LIST (CALL-NEXT-METHOD)) #'< :KEY #'SECTION-NUMBER))
(DEFMETHOD SECTION-CODE ((SECTION NAMED-SECTION))
  (MAPAPPEND #'SECTION-CODE (NAMED-SECTION-SECTIONS SECTION)))
(DEFMETHOD SECTION-NUMBER ((SECTION NAMED-SECTION))
  (SECTION-NUMBER (FIRST (NAMED-SECTION-SECTIONS SECTION))))
(DEFUN SECTION-NAME-PREFIX-P (NAME)
  (LET ((LEN (LENGTH NAME)))
    (IF (STRING= NAME "..." :START1 (MAX (- LEN 3) 0) :END1 LEN)
        (VALUES T (- LEN 3))
        (VALUES NIL LEN))))
(DEFUN SECTION-NAME-LESSP (NAME1 NAME2)
  (LET ((LEN1 (NTH-VALUE 1 (SECTION-NAME-PREFIX-P NAME1)))
        (LEN2 (NTH-VALUE 1 (SECTION-NAME-PREFIX-P NAME2))))
    (STRING-LESSP NAME1 NAME2 :END1 LEN1 :END2 LEN2)))
(DEFUN SECTION-NAME-EQUAL (NAME1 NAME2)
  (MULTIPLE-VALUE-BIND (PREFIX-1-P LEN1)
      (SECTION-NAME-PREFIX-P NAME1)
    (MULTIPLE-VALUE-BIND (PREFIX-2-P LEN2)
        (SECTION-NAME-PREFIX-P NAME2)
      (LET ((END (MIN LEN1 LEN2)))
        (IF (OR PREFIX-1-P PREFIX-2-P)
            (STRING-EQUAL NAME1 NAME2 :END1 END :END2 END)
            (STRING-EQUAL NAME1 NAME2))))))
(DEFMETHOD FIND-OR-INSERT
           (ITEM (ROOT NAMED-SECTION)
            &KEY (PREDICATE #'SECTION-NAME-LESSP) (TEST #'SECTION-NAME-EQUAL)
            (INSERT-IF-NOT-FOUND T))
  (MULTIPLE-VALUE-BIND (NODE PRESENT-P)
      (CALL-NEXT-METHOD ITEM ROOT :PREDICATE PREDICATE :TEST TEST
       :INSERT-IF-NOT-FOUND INSERT-IF-NOT-FOUND)
    (IF PRESENT-P
        (OR
         (DOLIST (CHILD (LIST (LEFT-CHILD NODE) (RIGHT-CHILD NODE)))
           (WHEN CHILD
             (MULTIPLE-VALUE-BIND (ALT PRESENT-P)
                 (CALL-NEXT-METHOD ITEM CHILD :PREDICATE PREDICATE :TEST TEST
                  :INSERT-IF-NOT-FOUND NIL)
               (WHEN PRESENT-P
                 (RESTART-CASE (ERROR 'AMBIGUOUS-PREFIX-ERROR :PREFIX ITEM
                                      :FIRST-MATCH (NODE-KEY NODE) :ALT-MATCH
                                      (NODE-KEY ALT))
                   (USE-FIRST-MATCH NIL :REPORT "Use the first match."
                    (RETURN (VALUES NODE T)))
                   (USE-ALT-MATCH NIL :REPORT "Use alternate match."
                    (RETURN (VALUES ALT T))))))))
         (VALUES NODE T))
        (VALUES NODE NIL))))
(UNLESS (FBOUNDP 'WHITESPACEP)
  (DEFUN WHITESPACEP (CHAR) (FIND CHAR *WHITESPACE* :TEST #'CHAR=)))
(DEFUN SQUEEZE (STRING)
  (LOOP WITH SQUEEZING = NIL
        FOR CHAR ACROSS (STRING-TRIM *WHITESPACE* STRING)
        IF (NOT SQUEEZING)
        IF (WHITESPACEP CHAR)
        DO (SETQ SQUEEZING T)
        AND
        COLLECT #\  INTO CHARS ELSE
        COLLECT CHAR INTO CHARS ELSE
        UNLESS (WHITESPACEP CHAR)
        DO (SETQ SQUEEZING NIL)
        AND
        COLLECT CHAR INTO CHARS
        FINALLY (RETURN (COERCE CHARS 'STRING))))
(DEFUN FIND-SECTION (NAME &AUX (NAME (SQUEEZE NAME)))
  (IF (NULL *NAMED-SECTIONS*)
      (VALUES (SETQ *NAMED-SECTIONS* (MAKE-INSTANCE 'NAMED-SECTION :NAME NAME))
              NIL)
      (MULTIPLE-VALUE-BIND (SECTION PRESENT-P)
          (FIND-OR-INSERT NAME *NAMED-SECTIONS*)
        (WHEN PRESENT-P
          (MULTIPLE-VALUE-BIND (NEW-PREFIX-P NEW-LEN)
              (SECTION-NAME-PREFIX-P NAME)
            (MULTIPLE-VALUE-BIND (OLD-PREFIX-P OLD-LEN)
                (SECTION-NAME-PREFIX-P (SECTION-NAME SECTION))
              (WHEN
                  (OR (AND OLD-PREFIX-P (NOT NEW-PREFIX-P))
                      (AND OLD-PREFIX-P NEW-PREFIX-P (< NEW-LEN OLD-LEN)))
                (SETF (SECTION-NAME SECTION) NAME)))))
        (VALUES SECTION PRESENT-P))))
(DEFUN READTABLE-FOR-MODE (MODE)
  (DECLARE (TYPE (OR MODE NULL) MODE))
  (CDR (ASSOC MODE *READTABLES*)))
(DEFMACRO WITH-MODE (MODE &BODY BODY)
  `(LET ((*READTABLE* (READTABLE-FOR-MODE ,MODE)))
     ,@BODY))
(DEFUN EOF-P (X) (EQ X *EOF*))
(DEFTYPE EOF () '(SATISFIES EOF-P))
(DEFUN TOKEN-DELIMITER-P (CHAR)
  (DECLARE (TYPE CHARACTER CHAR))
  (OR (WHITESPACEP CHAR)
      (MULTIPLE-VALUE-BIND #'NON-TERMINATING-P
          (GET-MACRO-CHARACTER CHAR)
        (AND FUNCTION (NOT NON-TERMINATING-P)))))
(DEFUN READ-MAYBE-NOTHING-INTERNAL
       (READ STREAM EOF-ERROR-P EOF-VALUE RECURSIVE-P)
  (MULTIPLE-VALUE-LIST
   (LET* ((NEXT-CHAR (PEEK-CHAR NIL STREAM NIL NIL RECURSIVE-P))
          (MACRO-FUN (AND NEXT-CHAR (GET-MACRO-CHARACTER NEXT-CHAR))))
     (COND
      (MACRO-FUN (READ-CHAR STREAM)
       (CALL-READER-MACRO-FUNCTION MACRO-FUN STREAM NEXT-CHAR))
      (T (FUNCALL READ STREAM EOF-ERROR-P EOF-VALUE RECURSIVE-P))))))
(DEFUN READ-MAYBE-NOTHING
       (STREAM &OPTIONAL (EOF-ERROR-P T) EOF-VALUE RECURSIVE-P)
  (READ-MAYBE-NOTHING-INTERNAL #'READ STREAM EOF-ERROR-P EOF-VALUE RECURSIVE-P))
(DEFUN READ-MAYBE-NOTHING-PRESERVING-WHITESPACE
       (STREAM &OPTIONAL (EOF-ERROR-P T) EOF-VALUE RECURSIVE-P)
  (READ-MAYBE-NOTHING-INTERNAL #'READ-PRESERVING-WHITESPACE STREAM EOF-ERROR-P
                               EOF-VALUE RECURSIVE-P))
(DEFMACRO WITH-READ-BUFFER ((&REST ARGS) &BODY BODY)
  (DECLARE (IGNORABLE ARGS))
  #+:SBCL `(sb-impl::with-read-buffer ,args ,@body)
  #-:SBCL `(progn ,@body))
(DEFUN CALL-READER-MACRO-FUNCTION (FN STREAM CHAR)
  (WITH-READ-BUFFER NIL
    (FUNCALL FN STREAM CHAR)))
(DEFCLASS CHARPOS-STREAM NIL
          ((CHARPOS :INITARG :CHARPOS :INITFORM 0)
           (PROXY-STREAM :ACCESSOR CHARPOS-PROXY-STREAM :INITARG :PROXY)))
(DEFGENERIC GET-CHARPOS-STREAM-BUFFER
    (STREAM))
(DEFGENERIC CHARPOS
    (STREAM))
(DEFMETHOD CHARPOS ((STREAM CHARPOS-STREAM))
  (WITH-SLOTS (CHARPOS)
      STREAM
    (LOOP FOR CHAR ACROSS (GET-CHARPOS-STREAM-BUFFER STREAM)
          DO (CASE CHAR
               (#\Tab (INCF CHARPOS (- *TAB-WIDTH* (REM CHARPOS *TAB-WIDTH*))))
               (#\Newline (SETF CHARPOS 0))
               (T (INCF CHARPOS)))
          FINALLY (RETURN CHARPOS))))
(DEFCLASS CHARPOS-INPUT-STREAM (CHARPOS-STREAM) NIL)
(DEFMETHOD SHARED-INITIALIZE :AROUND
           ((INSTANCE CHARPOS-INPUT-STREAM) SLOT-NAMES
            &REST INITARGS
            &KEY STREAM)
  (APPLY #'CALL-NEXT-METHOD INSTANCE SLOT-NAMES
         (LIST* :PROXY
                (MAKE-ECHO-STREAM STREAM
                                  (MAKE-STRING-OUTPUT-STREAM :ELEMENT-TYPE
                                                             (STREAM-ELEMENT-TYPE
                                                              STREAM)))
                INITARGS)))
(DEFMETHOD GET-CHARPOS-STREAM-BUFFER ((STREAM CHARPOS-INPUT-STREAM))
  (GET-OUTPUT-STREAM-STRING
   (ECHO-STREAM-OUTPUT-STREAM (CHARPOS-PROXY-STREAM STREAM))))
(DEFCLASS CHARPOS-OUTPUT-STREAM (CHARPOS-STREAM) NIL)
(DEFMETHOD SHARED-INITIALIZE :AROUND
           ((INSTANCE CHARPOS-OUTPUT-STREAM) SLOT-NAMES
            &REST INITARGS
            &KEY STREAM)
  (APPLY #'CALL-NEXT-METHOD INSTANCE SLOT-NAMES
         (LIST* :PROXY
                (MAKE-BROADCAST-STREAM
                 (MAKE-STRING-OUTPUT-STREAM :ELEMENT-TYPE
                                            (STREAM-ELEMENT-TYPE STREAM))
                 STREAM)
                INITARGS)))
(DEFMETHOD GET-CHARPOS-STREAM-BUFFER ((STREAM CHARPOS-OUTPUT-STREAM))
  (GET-OUTPUT-STREAM-STRING
   (FIRST (BROADCAST-STREAM-STREAMS (CHARPOS-PROXY-STREAM STREAM)))))
(DEFMETHOD INITIALIZE-INSTANCE :AFTER ((INSTANCE CHARPOS-STREAM) &KEY)
  (SETF (GETHASH (CHARPOS-PROXY-STREAM INSTANCE) *CHARPOS-STREAMS*) INSTANCE))
(DEFUN STREAM-CHARPOS (STREAM)
  (CHARPOS
   (OR (GETHASH STREAM *CHARPOS-STREAMS*)
       (ERROR "Not tracking charpos for ~S" STREAM))))
(DEFUN RELEASE-CHARPOS-STREAM (STREAM)
  (MULTIPLE-VALUE-BIND (CHARPOS-STREAM PRESENT-P)
      (GETHASH STREAM *CHARPOS-STREAMS*)
    (COND
     (PRESENT-P (SETF (CHARPOS-PROXY-STREAM CHARPOS-STREAM) NIL)
      (REMHASH STREAM *CHARPOS-STREAMS*))
     (T (WARN "Not tracking charpos for ~S" STREAM)))))
(DEFUN MAKE-CHARPOS-INPUT-STREAM (INPUT-STREAM &KEY (CHARPOS 0))
  (MAKE-INSTANCE 'CHARPOS-INPUT-STREAM :STREAM
                 (CASE INPUT-STREAM
                   ((T) *TERMINAL-IO*)
                   ((NIL) *STANDARD-INPUT*)
                   (OTHERWISE INPUT-STREAM))
                 :CHARPOS CHARPOS))
(DEFUN MAKE-CHARPOS-OUTPUT-STREAM (OUTPUT-STREAM &KEY (CHARPOS 0))
  (MAKE-INSTANCE 'CHARPOS-OUTPUT-STREAM :STREAM
                 (CASE OUTPUT-STREAM
                   ((T) *TERMINAL-IO*)
                   ((NIL) *STANDARD-OUTPUT*)
                   (OTHERWISE OUTPUT-STREAM))
                 :CHARPOS CHARPOS))
(DEFMACRO WITH-CHARPOS-INPUT-STREAM ((VAR STREAM &KEY (CHARPOS 0)) &BODY BODY)
  `(LET ((,VAR
          (CHARPOS-PROXY-STREAM
           (MAKE-CHARPOS-INPUT-STREAM ,STREAM :CHARPOS ,CHARPOS))))
     (UNWIND-PROTECT (PROGN ,@BODY) (RELEASE-CHARPOS-STREAM ,VAR))))
(DEFMACRO WITH-CHARPOS-OUTPUT-STREAM ((VAR STREAM &KEY (CHARPOS 0)) &BODY BODY)
  `(LET ((,VAR
          (CHARPOS-PROXY-STREAM
           (MAKE-CHARPOS-OUTPUT-STREAM ,STREAM :CHARPOS ,CHARPOS))))
     (UNWIND-PROTECT (PROGN ,@BODY) (RELEASE-CHARPOS-STREAM ,VAR))))
(DEFMACRO WITH-REWIND-STREAM
          ((VAR STREAM &OPTIONAL (REWIND 'REWIND))
           &BODY BODY
           &AUX (IN (GENSYM)) (OUT (GENSYM)) (CLOSING (GENSYM)))
  `(LET* ((,OUT (MAKE-STRING-OUTPUT-STREAM))
          (,VAR (MAKE-ECHO-STREAM ,STREAM ,OUT))
          (,CLOSING (LIST ,OUT ,VAR)))
     (FLET ((,REWIND ()
              (LET ((,IN
                     (MAKE-STRING-INPUT-STREAM
                      (GET-OUTPUT-STREAM-STRING ,OUT))))
                (PROG1 (SETQ ,VAR (MAKE-CONCATENATED-STREAM ,IN ,VAR))
                  (PUSH ,VAR ,CLOSING)
                  (PUSH ,IN ,CLOSING)))))
       (UNWIND-PROTECT (PROGN ,@BODY) (MAP NIL #'CLOSE ,CLOSING)))))
(DEFMACRO READ-WITH-ECHO
          ((STREAM OBJECT ECHOED)
           &BODY BODY
           &AUX (OUT (GENSYM)) (ECHO (GENSYM)) (RAW-OUTPUT (GENSYM))
           (LENGTH (GENSYM)))
  `(WITH-OPEN-STREAM (,OUT (MAKE-STRING-OUTPUT-STREAM))
     (WITH-OPEN-STREAM (,ECHO (MAKE-ECHO-STREAM ,STREAM ,OUT))
       (LET* ((,OBJECT (READ-PRESERVING-WHITESPACE ,ECHO))
              (,RAW-OUTPUT (GET-OUTPUT-STREAM-STRING ,OUT))
              (,LENGTH (LENGTH ,RAW-OUTPUT))
              (,ECHOED
               (SUBSEQ ,RAW-OUTPUT 0
                       (IF (OR (EOF-P (PEEK-CHAR NIL ,ECHO NIL *EOF*))
                               (TOKEN-DELIMITER-P
                                (ELT ,RAW-OUTPUT (1- ,LENGTH))))
                           ,LENGTH
                           (1- ,LENGTH)))))
         (DECLARE (IGNORABLE ,OBJECT ,ECHOED))
         ,@BODY))))
(DEFUN SET-TANGLE-DISPATCH (TYPE-SPECIFIER FUNCTION &OPTIONAL (PRIORITY 0))
  (SET-PPRINT-DISPATCH TYPE-SPECIFIER FUNCTION PRIORITY
                       *TANGLE-PPRINT-DISPATCH*))
(DEFCLASS MARKER NIL ((VALUE :READER MARKER-VALUE :INITARG :VALUE)))
(DEFUN MARKERP (X) (TYPEP X 'MARKER))
(DEFGENERIC MARKER-BOUNDP
    (MARKER))
(DEFMETHOD MARKER-BOUNDP ((MARKER MARKER)) (SLOT-BOUNDP MARKER 'VALUE))
(SET-TANGLE-DISPATCH 'MARKER
                     (LAMBDA (STREAM MARKER)
                       (WHEN (MARKER-BOUNDP MARKER)
                         (WRITE (MARKER-VALUE MARKER) :STREAM STREAM))))
(DEFCLASS NEWLINE-MARKER (MARKER)
          ((INDENTATION :ACCESSOR INDENTATION :INITFORM NIL)))
(DEFCLASS PAR-MARKER (NEWLINE-MARKER) NIL)
(DEFUN NEWLINEP (OBJ) (TYPEP OBJ 'NEWLINE-MARKER))
(SET-MACRO-CHARACTER #\Newline
                     (LAMBDA (STREAM CHAR)
                       (DECLARE (IGNORE CHAR))
                       (CASE (PEEK-CHAR NIL STREAM NIL *EOF* T)
                         (#\Newline
                          (READ-CHAR STREAM T NIL T)
                          (MAKE-INSTANCE 'PAR-MARKER))
                         (OTHERWISE (MAKE-INSTANCE 'NEWLINE-MARKER))))
                     NIL (READTABLE-FOR-MODE :LISP))
(DEFCLASS EMPTY-LIST-MARKER (MARKER) NIL (:DEFAULT-INITARGS :VALUE 'NIL))
(DEFVAR *EMPTY-LIST* (MAKE-INSTANCE 'EMPTY-LIST-MARKER))
(DEFCLASS LIST-MARKER (MARKER)
          ((LENGTH :ACCESSOR LIST-MARKER-LENGTH :INITARG :LENGTH)
           (LIST :ACCESSOR LIST-MARKER-LIST :INITARG :LIST)
           (CHARPOS :ACCESSOR LIST-MARKER-CHARPOS :INITARG :CHARPOS)))
(DEFUN LIST-MARKER-P (OBJ) (TYPEP OBJ 'LIST-MARKER))
(DEFCLASS CONSING-DOT-MARKER (MARKER) NIL)
(DEFVAR *CONSING-DOT* (MAKE-INSTANCE 'CONSING-DOT-MARKER))
(DEFMETHOD MARKER-BOUNDP ((MARKER LIST-MARKER)) T)
(DEFMETHOD MARKER-VALUE ((MARKER LIST-MARKER))
  (DO* ((LIST (LIST NIL))
        (TAIL LIST)
        (MARKER-LIST (LIST-MARKER-LIST MARKER) (CDR MARKER-LIST))
        (X (CAR MARKER-LIST) (CAR MARKER-LIST)))
       ((ENDP MARKER-LIST) (CDR LIST))
    (COND
     ((EQ X *CONSING-DOT*)
      (RPLACD TAIL
              (DOLIST (X MARKER-LIST (ERROR "Nothing after . in list"))
                (WHEN
                    (OR (NOT (MARKERP X)) (AND (MARKERP X) (MARKER-BOUNDP X)))
                  (RETURN X))))
      (RETURN (CDR LIST)))
     ((MARKERP X)
      (WHEN (MARKER-BOUNDP X)
        (LET ((OBJ (LIST X)))
          (RPLACD TAIL OBJ)
          (SETQ TAIL OBJ))))
     (T
      (LET ((OBJ (LIST X)))
        (RPLACD TAIL OBJ)
        (SETQ TAIL OBJ))))))
(DEFUN MAKE-LIST-READER (NEXT)
  (LAMBDA (STREAM CHAR)
    (IF (CHAR= (PEEK-CHAR T STREAM T NIL T) #\))
        (PROGN (READ-CHAR STREAM T NIL T) *EMPTY-LIST*)
        (FUNCALL NEXT STREAM CHAR))))
(SET-MACRO-CHARACTER #\( (MAKE-LIST-READER (GET-MACRO-CHARACTER #\( NIL)) NIL
                     (READTABLE-FOR-MODE :INNER-LISP))
(DEFUN LIST-READER (STREAM CHAR)
  (DECLARE (IGNORE CHAR))
  (LOOP WITH LIST = 'NIL
        WITH CHARPOS-LIST = 'NIL
        FOR N UPFROM 0
        AND NEXT-CHAR = (PEEK-CHAR T STREAM T NIL
                                   T) AS CHARPOS = (STREAM-CHARPOS STREAM)
        UNTIL (CHAR= #\) NEXT-CHAR)
        IF (CHAR= #\. NEXT-CHAR)
        DO (WITH-REWIND-STREAM (STREAM STREAM)
             (READ-CHAR STREAM T NIL T)
             (LET ((FOLLOWING-CHAR (READ-CHAR STREAM T NIL T)))
               (COND
                ((TOKEN-DELIMITER-P FOLLOWING-CHAR)
                 (UNLESS (OR LIST *READ-SUPPRESS*)
                   (SIMPLE-READER-ERROR STREAM
                                        "Nothing appears before . in list."))
                 (PUSH *CONSING-DOT* LIST) (PUSH CHARPOS CHARPOS-LIST))
                (T (REWIND)
                 (LET ((VALUES (READ-MAYBE-NOTHING STREAM T NIL T)))
                   (WHEN VALUES
                     (PUSH (CAR VALUES) LIST)
                     (PUSH CHARPOS CHARPOS-LIST))))))) ELSE
        DO (LET ((VALUES (READ-MAYBE-NOTHING STREAM T NIL T)))
             (WHEN VALUES
               (PUSH (CAR VALUES) LIST)
               (PUSH CHARPOS CHARPOS-LIST)))
        FINALLY (READ-CHAR STREAM T NIL T) (RETURN
                                            (MAKE-INSTANCE 'LIST-MARKER :LENGTH
                                                           N :LIST
                                                           (NREVERSE LIST)
                                                           :CHARPOS
                                                           (NREVERSE
                                                            CHARPOS-LIST)))))
(SET-MACRO-CHARACTER #\( (MAKE-LIST-READER #'LIST-READER) NIL
                     (READTABLE-FOR-MODE :LISP))
(DEFCLASS QUOTE-MARKER (MARKER)
          ((QUOTE :READER QUOTE-MARKER-QUOTE :INITARG :QUOTE)
           (FORM :READER QUOTED-FORM :INITARG :FORM)))
(DEFMETHOD MARKER-BOUNDP ((MARKER QUOTE-MARKER)) T)
(DEFMETHOD MARKER-VALUE ((MARKER QUOTE-MARKER))
  (LIST (QUOTE-MARKER-QUOTE MARKER) (QUOTED-FORM MARKER)))
(DEFUN SINGLE-QUOTE-READER (STREAM CHAR)
  (DECLARE (IGNORE CHAR))
  (MAKE-INSTANCE 'QUOTE-MARKER :QUOTE 'QUOTE :FORM (READ STREAM T NIL T)))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-MACRO-CHARACTER #\' #'SINGLE-QUOTE-READER NIL (READTABLE-FOR-MODE MODE)))
(DEFCLASS COMMENT-MARKER (MARKER) ((TEXT :READER COMMENT-TEXT :INITARG :TEXT)))
(DEFUN COMMENT-READER (STREAM CHAR)
  (IF (CHAR= (PEEK-CHAR NIL STREAM NIL #\Newline T) #\Newline)
      (PROGN (READ-CHAR STREAM T NIL T) (VALUES))
      (MAKE-INSTANCE 'COMMENT-MARKER :TEXT
                     (WITH-OUTPUT-TO-STRING (S)
                       (WRITE-CHAR CHAR S)
                       (DO ()
                           ((CHAR= (PEEK-CHAR NIL STREAM NIL #\Newline T)
                                   #\Newline))
                         (WRITE-CHAR (READ-CHAR STREAM T NIL T) S))))))
(SET-MACRO-CHARACTER #\; #'COMMENT-READER NIL (READTABLE-FOR-MODE :LISP))
(DEFVAR *BACKQUOTE* (MAKE-SYMBOL "BACKQUOTE"))
(DEFUN BACKQUOTEP (X) (EQ X *BACKQUOTE*))
(DEFTYPE BACKQUOTE () '(CONS (SATISFIES BACKQUOTEP)))
(DEFCLASS COMMA NIL ((FORM :READER COMMA-FORM :INITARG :FORM)))
(DEFCLASS SPLICING-COMMA (COMMA)
          ((MODIFIER :READER COMMA-MODIFIER :INITARG :MODIFIER)))
(DEFMETHOD COMMA-FORM :AROUND ((COMMA COMMA)) (TANGLE (CALL-NEXT-METHOD)))
(DEFUN COMMAP (OBJ) (TYPEP OBJ 'COMMA))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-MACRO-CHARACTER #\`
                       (LAMBDA (STREAM CHAR)
                         (DECLARE (IGNORE CHAR))
                         (LIST *BACKQUOTE* (READ STREAM T NIL T)))
                       NIL (READTABLE-FOR-MODE MODE))
  (SET-MACRO-CHARACTER #\,
                       (LAMBDA (STREAM CHAR)
                         (DECLARE (IGNORE CHAR))
                         (CASE (PEEK-CHAR NIL STREAM T NIL T)
                           ((#\@ #\.)
                            (MAKE-INSTANCE 'SPLICING-COMMA :MODIFIER
                                           (READ-CHAR STREAM T NIL T) :FORM
                                           (READ STREAM T NIL T)))
                           (OTHERWISE
                            (MAKE-INSTANCE 'COMMA :FORM
                                           (READ STREAM T NIL T)))))
                       NIL (READTABLE-FOR-MODE MODE)))
(DEFMACRO BACKQUOTE (X) (BQ-PROCESS X))
(SETF (MACRO-FUNCTION *BACKQUOTE*) (MACRO-FUNCTION 'BACKQUOTE))
(DEFUN BQ-PROCESS (X &AUX (X (TANGLE X)))
  (TYPECASE X
    (VECTOR `(APPLY #'VECTOR ,(BQ-PROCESS (COERCE X 'LIST))))
    (SPLICING-COMMA (ERROR ",~C~S after `" (COMMA-MODIFIER X) (COMMA-FORM X)))
    (COMMA (COMMA-FORM X))
    (ATOM `',X)
    (BACKQUOTE (BQ-PROCESS (BQ-PROCESS (CADR X))))
    (T
     (DO ((P X (CDR P))
          (Q 'NIL (CONS (BRACKET (CAR P)) Q)))
         ((AND (ATOM P) (NOT (COMMAP P)))
          (CONS 'APPEND (NRECONC Q (AND P (LIST (LIST 'QUOTE P))))))
       (TYPECASE P
         (SPLICING-COMMA
          (ERROR "Dotted ,~C~S" (COMMA-MODIFIER P) (COMMA-FORM P)))
         (COMMA (RETURN (CONS 'APPEND (NRECONC Q (LIST (COMMA-FORM P)))))))))))
(DEFUN BRACKET (X)
  (TYPECASE X
    (SPLICING-COMMA (COMMA-FORM X))
    (COMMA `(LIST ,(COMMA-FORM X)))
    (T `(LIST ,(BQ-PROCESS X)))))
(SET-TANGLE-DISPATCH 'BACKQUOTE
                     (LAMBDA (STREAM OBJ) (FORMAT STREAM "`~W" (CADR OBJ))))
(SET-TANGLE-DISPATCH 'SPLICING-COMMA
                     (LAMBDA (STREAM OBJ)
                       (FORMAT STREAM ",~C~W" (COMMA-MODIFIER OBJ)
                               (COMMA-FORM OBJ)))
                     1)
(SET-TANGLE-DISPATCH 'COMMA
                     (LAMBDA (STREAM OBJ)
                       (FORMAT STREAM ",~W" (COMMA-FORM OBJ))))
(DEFCLASS FUNCTION-MARKER (QUOTE-MARKER) NIL)
(DEFUN SHARPSIGN-QUOTE-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR ARG))
  (MAKE-INSTANCE 'FUNCTION-MARKER :QUOTE 'FUNCTION :FORM (READ STREAM T NIL T)))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\' #'SHARPSIGN-QUOTE-READER
                                (READTABLE-FOR-MODE MODE)))
(DEFCLASS SIMPLE-VECTOR-MARKER (MARKER)
          ((LENGTH :INITARG :LENGTH) (ELEMENTS :INITARG :ELEMENTS)
           (ELEMENT-TYPE :INITARG :ELEMENT-TYPE))
          (:DEFAULT-INITARGS :ELEMENT-TYPE T))
(DEFMETHOD MARKER-BOUNDP ((MARKER SIMPLE-VECTOR-MARKER)) T)
(DEFMETHOD MARKER-VALUE ((MARKER SIMPLE-VECTOR-MARKER))
  (WITH-SLOTS (ELEMENTS ELEMENT-TYPE)
      MARKER
    (IF (SLOT-BOUNDP MARKER 'LENGTH)
        (WITH-SLOTS (LENGTH)
            MARKER
          (LET ((SUPPLIED-LENGTH (LENGTH ELEMENTS)))
            (FILL
             (REPLACE (MAKE-ARRAY LENGTH :ELEMENT-TYPE ELEMENT-TYPE) ELEMENTS)
             (ELT ELEMENTS (1- SUPPLIED-LENGTH)) :START SUPPLIED-LENGTH)))
        (COERCE ELEMENTS `(VECTOR ,ELEMENT-TYPE)))))
(DEFUN SIMPLE-VECTOR-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR))
  (LET* ((LIST (READ-DELIMITED-LIST #\) STREAM T))
         (LENGTH
          (HANDLER-CASE (LENGTH LIST)
                        (TYPE-ERROR (ERROR) (DECLARE (IGNORE ERROR))
                         (SIMPLE-READER-ERROR STREAM "improper list in #(): ~S"
                                              LIST)))))
    (UNLESS *READ-SUPPRESS*
      (IF ARG
          (IF (> LENGTH ARG)
              (SIMPLE-READER-ERROR STREAM
                                   "vector longer than specified length: #~S~S"
                                   ARG LIST)
              (MAKE-INSTANCE 'SIMPLE-VECTOR-MARKER :LENGTH ARG :ELEMENTS LIST))
          (MAKE-INSTANCE 'SIMPLE-VECTOR-MARKER :ELEMENTS LIST)))))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\( #'SIMPLE-VECTOR-READER
                                (READTABLE-FOR-MODE MODE)))
(DEFCLASS BIT-VECTOR-MARKER (SIMPLE-VECTOR-MARKER) NIL
          (:DEFAULT-INITARGS :ELEMENT-TYPE 'BIT))
(DEFUN SIMPLE-BIT-VECTOR-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR))
  (APPLY #'MAKE-INSTANCE 'BIT-VECTOR-MARKER :ELEMENTS
         (COERCE
          (LOOP FOR CHAR = (READ-CHAR STREAM NIL #\  T)
                WHILE (OR (CHAR= CHAR #\0) (CHAR= CHAR #\1))
                COLLECT (ECASE CHAR (#\0 0) (#\1 1))
                FINALLY (UNREAD-CHAR CHAR STREAM))
          'BIT-VECTOR)
         (WHEN ARG `(:LENGTH ,ARG))))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\* #'SIMPLE-BIT-VECTOR-READER
                                (READTABLE-FOR-MODE MODE)))
(DEFCLASS READ-TIME-EVAL NIL
          ((FORM :READER READ-TIME-EVAL-FORM :INITARG :FORM)))
(SET-TANGLE-DISPATCH 'READ-TIME-EVAL
                     (LAMBDA (STREAM OBJ)
                       (FORMAT STREAM "#.~W" (READ-TIME-EVAL-FORM OBJ))))
(DEFCLASS READ-TIME-EVAL-MARKER (READ-TIME-EVAL MARKER) NIL)
(DEFMETHOD MARKER-BOUNDP ((MARKER READ-TIME-EVAL-MARKER)) T)
(DEFMETHOD MARKER-VALUE ((MARKER READ-TIME-EVAL-MARKER))
  (IF *EVALUATING*
      (CALL-NEXT-METHOD)
      (MAKE-INSTANCE 'READ-TIME-EVAL :FORM (READ-TIME-EVAL-FORM MARKER))))
(DEFUN SHARPSIGN-DOT-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR ARG))
  (LET* ((*READTABLE*
          (IF *EVALUATING*
              (READTABLE-FOR-MODE NIL)
              *READTABLE*))
         (FORM (READ STREAM T NIL T)))
    (UNLESS *READ-SUPPRESS*
      (UNLESS *READ-EVAL*
        (SIMPLE-READER-ERROR STREAM "can't read #. while *READ-EVAL* is NIL"))
      (MAKE-INSTANCE 'READ-TIME-EVAL-MARKER :FORM FORM :VALUE (EVAL FORM)))))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\. #'SHARPSIGN-DOT-READER
                                (READTABLE-FOR-MODE MODE)))
(DEFCLASS RADIX-MARKER (MARKER)
          ((BASE :READER RADIX-MARKER-BASE :INITARG :BASE)))
(DEFPARAMETER *RADIX-PREFIX-ALIST* '((#\B . 2) (#\O . 8) (#\X . 16) (#\R)))
(DEFUN RADIX-READER (STREAM SUB-CHAR ARG)
  (MAKE-INSTANCE 'RADIX-MARKER :BASE
                 (OR (CDR (ASSOC (CHAR-UPCASE SUB-CHAR) *RADIX-PREFIX-ALIST*))
                     ARG)
                 :VALUE
                 (FUNCALL
                  (GET-DISPATCH-MACRO-CHARACTER #\# SUB-CHAR
                                                (READTABLE-FOR-MODE NIL))
                  STREAM SUB-CHAR ARG)))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (DOLIST (SUB-CHAR '(#\B #\b #\O #\o #\X #\x #\R #\r))
    (SET-DISPATCH-MACRO-CHARACTER #\# SUB-CHAR #'RADIX-READER
                                  (READTABLE-FOR-MODE MODE))))
(DEFCLASS COMPLEX-MARKER (MARKER)
          ((COMPONENTS :READER COMPLEX-COMPONENTS :INITARG :COMPONENTS)))
(DEFMETHOD MARKER-BOUNDP ((MARKER COMPLEX-MARKER)) T)
(DEFMETHOD MARKER-VALUE ((MARKER COMPLEX-MARKER))
  (APPLY #'COMPLEX (TANGLE (COMPLEX-COMPONENTS MARKER))))
(DEFUN COMPLEX-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR ARG))
  (MAKE-INSTANCE 'COMPLEX-MARKER :COMPONENTS (READ STREAM T NIL T)))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\C #'COMPLEX-READER
                                (READTABLE-FOR-MODE MODE)))
(DEFCLASS ARRAY-MARKER (MARKER)
          ((RANK :READER ARRAY-MARKER-RANK :INITARG :RANK)
           (INITIAL-CONTENTS :READER ARRAY-MARKER-INITIAL-CONTENTS :INITARG
            :INITIAL-CONTENTS)))
(DEFMETHOD MARKER-BOUNDP ((MARKER ARRAY-MARKER)) T)
(DEFMETHOD MARKER-VALUE ((MARKER ARRAY-MARKER))
  (LOOP WITH CONTENTS = (TANGLE (ARRAY-MARKER-INITIAL-CONTENTS MARKER))
        REPEAT (ARRAY-MARKER-RANK MARKER)
        FOR SEQ = CONTENTS THEN (ELT SEQ 0)
        COLLECT (LENGTH SEQ) INTO DIMENSIONS
        FINALLY (RETURN (MAKE-ARRAY DIMENSIONS :INITIAL-CONTENTS CONTENTS))))
(DEFUN ARRAY-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR))
  (UNLESS ARG (SIMPLE-READER-ERROR STREAM "no rank supplied with #A"))
  (MAKE-INSTANCE 'ARRAY-MARKER :RANK ARG :INITIAL-CONTENTS
                 (READ STREAM T NIL T)))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\A #'ARRAY-READER
                                (READTABLE-FOR-MODE MODE)))
(DEFCLASS STRUCTURE-MARKER (MARKER)
          ((FORM :READER STRUCTURE-MARKER-FORM :INITARG :FORM)))
(DEFMETHOD MARKER-BOUNDP ((MARKER STRUCTURE-MARKER)) T)
(DEFMETHOD MARKER-VALUE ((MARKER STRUCTURE-MARKER))
  (LET ((*READTABLE* (READTABLE-FOR-MODE NIL)))
    (VALUES
     (READ-FROM-STRING
      (WRITE-TO-STRING MARKER :PPRINT-DISPATCH *TANGLE-PPRINT-DISPATCH* :PRETTY
                       T :READABLY T)))))
(SET-TANGLE-DISPATCH 'STRUCTURE-MARKER
                     (LAMBDA (STREAM OBJ)
                       (FORMAT STREAM "#S~W" (STRUCTURE-MARKER-FORM OBJ)))
                     1)
(DEFUN STRUCTURE-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR ARG))
  (MAKE-INSTANCE 'STRUCTURE-MARKER :FORM (READ STREAM T NIL T)))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\S #'STRUCTURE-READER
                                (READTABLE-FOR-MODE MODE)))
(DEFUN FEATUREP (X)
  (ETYPECASE X
    (CONS
     (CASE (CAR X)
       ((:NOT NOT)
        (COND
         ((CDDR X)
          (ERROR "too many subexpressions in feature expression: ~S" X))
         ((NULL (CDR X))
          (ERROR "too few subexpressions in feature expression: ~S" X))
         (T (NOT (FEATUREP (CADR X))))))
       ((:AND AND) (EVERY #'FEATUREP (CDR X)))
       ((:OR OR) (SOME #'FEATUREP (CDR X)))
       (T (ERROR "unknown operator in feature expression: ~S." X))))
    (SYMBOL (NOT (NULL (MEMBER X *FEATURES* :TEST #'EQ))))))
(DEFCLASS READ-TIME-CONDITIONAL NIL
          ((PLUSP :READER READ-TIME-CONDITIONAL-PLUSP :INITARG :PLUSP)
           (TEST :READER READ-TIME-CONDITIONAL-TEST :INITARG :TEST)
           (FORM :READER READ-TIME-CONDITIONAL-FORM :INITARG :FORM)))
(SET-TANGLE-DISPATCH 'READ-TIME-CONDITIONAL
                     (LAMBDA (STREAM OBJ)
                       (FORMAT STREAM "#~:[-~;+~]~S ~A"
                               (READ-TIME-CONDITIONAL-PLUSP OBJ)
                               (READ-TIME-CONDITIONAL-TEST OBJ)
                               (READ-TIME-CONDITIONAL-FORM OBJ))))
(DEFCLASS READ-TIME-CONDITIONAL-MARKER (READ-TIME-CONDITIONAL MARKER) NIL)
(DEFMETHOD MARKER-BOUNDP ((MARKER READ-TIME-CONDITIONAL-MARKER))
  (IF *EVALUATING*
      (CALL-NEXT-METHOD)
      T))
(DEFMETHOD MARKER-VALUE ((MARKER READ-TIME-CONDITIONAL-MARKER))
  (IF *EVALUATING*
      (CALL-NEXT-METHOD)
      (MAKE-INSTANCE 'READ-TIME-CONDITIONAL :PLUSP
                     (READ-TIME-CONDITIONAL-PLUSP MARKER) :TEST
                     (READ-TIME-CONDITIONAL-TEST MARKER) :FORM
                     (READ-TIME-CONDITIONAL-FORM MARKER))))
(DEFUN READ-TIME-CONDITIONAL-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE ARG))
  (LET* ((PLUSP (ECASE SUB-CHAR (#\+ T) (#\- NIL)))
         (*READTABLE* (READTABLE-FOR-MODE NIL))
         (TEST
          (LET ((*PACKAGE* (FIND-PACKAGE "KEYWORD")) (*READ-SUPPRESS* NIL))
            (READ STREAM T NIL T)))
         (*READ-SUPPRESS*
          (IF PLUSP
              (NOT (FEATUREP TEST))
              (FEATUREP TEST))))
    (PEEK-CHAR T STREAM T NIL T)
    (READ-WITH-ECHO (STREAM VALUE FORM)
      (APPLY #'MAKE-INSTANCE 'READ-TIME-CONDITIONAL-MARKER :PLUSP PLUSP :TEST
             TEST :FORM FORM (AND (NOT *READ-SUPPRESS*) (LIST :VALUE VALUE))))))
(DOLIST (MODE '(:LISP :INNER-LISP))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\+ #'READ-TIME-CONDITIONAL-READER
                                (READTABLE-FOR-MODE MODE))
  (SET-DISPATCH-MACRO-CHARACTER #\# #\- #'READ-TIME-CONDITIONAL-READER
                                (READTABLE-FOR-MODE MODE)))
(DEFUN SNARF-UNTIL-CONTROL-CHAR
       (STREAM CONTROL-CHARS &AUX (CONTROL-CHARS (ENSURE-LIST CONTROL-CHARS)))
  (WITH-OUTPUT-TO-STRING (STRING)
    (LOOP FOR CHAR = (PEEK-CHAR NIL STREAM NIL *EOF* NIL)
          UNTIL (OR (EOF-P CHAR) (MEMBER CHAR CONTROL-CHARS))
          DO (WRITE-CHAR (READ-CHAR STREAM) STRING))))
(DEFUN READ-INNER-LISP (STREAM CHAR)
  (WITH-MODE :INNER-LISP
    (READ-DELIMITED-LIST CHAR STREAM)))
(DOLIST (MODE '(:TEX :RESTRICTED))
  (SET-MACRO-CHARACTER #\| #'READ-INNER-LISP NIL (READTABLE-FOR-MODE MODE)))
(SET-MACRO-CHARACTER #\| (GET-MACRO-CHARACTER #\) NIL) NIL
                     (READTABLE-FOR-MODE :INNER-LISP))
(DOLIST (MODE *MODES*)
  (IGNORE-ERRORS
   (MAKE-DISPATCH-MACRO-CHARACTER #\@ T (READTABLE-FOR-MODE MODE))))
(DEFUN GET-CONTROL-CODE (SUB-CHAR MODE)
  (GET-DISPATCH-MACRO-CHARACTER #\@ SUB-CHAR (READTABLE-FOR-MODE MODE)))
(DEFUN SET-CONTROL-CODE (SUB-CHAR FUNCTION &OPTIONAL (MODES *MODES*))
  (DOLIST (MODE (ENSURE-LIST MODES))
    (SET-DISPATCH-MACRO-CHARACTER #\@ SUB-CHAR FUNCTION
                                  (READTABLE-FOR-MODE MODE))))
(SET-CONTROL-CODE #\@
                  (LAMBDA (STREAM SUB-CHAR ARG)
                    (DECLARE (IGNORE SUB-CHAR STREAM ARG))
                    (STRING "@")))
(DEFUN START-SECTION-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE STREAM ARG))
  (MAKE-INSTANCE (ECASE SUB-CHAR (#\  'SECTION) (#\* 'STARRED-SECTION))))
(DOLIST (SUB-CHAR '(#\  #\*))
  (SET-CONTROL-CODE SUB-CHAR #'START-SECTION-READER '(:LIMBO :TEX :LISP)))
(DEFUN START-TEST-SECTION-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR ARG))
  (PROG1
      (IF (AND (CHAR= (PEEK-CHAR T STREAM T NIL T) #\*)
               (READ-CHAR STREAM T NIL T))
          (MAKE-INSTANCE 'STARRED-TEST-SECTION)
          (MAKE-INSTANCE 'TEST-SECTION))
    (LOOP UNTIL (CHAR/= (PEEK-CHAR T STREAM T NIL T) #\Newline)
          DO (READ-CHAR STREAM T NIL T))))
(SET-CONTROL-CODE #\t #'START-TEST-SECTION-READER '(:LIMBO :TEX :LISP))
(DEFCLASS START-CODE-MARKER (MARKER)
          ((NAME :READER SECTION-NAME :INITARG :NAME))
          (:DEFAULT-INITARGS :NAME NIL))
(DEFUN START-CODE-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE STREAM SUB-CHAR ARG))
  (MAKE-INSTANCE 'START-CODE-MARKER))
(DOLIST (SUB-CHAR '(#\l #\p))
  (SET-CONTROL-CODE SUB-CHAR #'START-CODE-READER '(:TEX :LISP)))
(DEFCLASS EVALUATED-FORM-MARKER (MARKER) NIL)
(DEFUN READ-EVALUATED-FORM (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR ARG))
  (LOOP FOR FORM = (READ STREAM T NIL T)
        UNTIL (NOT (NEWLINEP FORM))
        FINALLY (RETURN (MAKE-INSTANCE 'EVALUATED-FORM-MARKER :VALUE FORM))))
(SET-CONTROL-CODE #\e #'READ-EVALUATED-FORM :LISP)
(DEFVAR *END-CONTROL-TEXT* (MAKE-SYMBOL "@>"))
(SET-CONTROL-CODE #\> (CONSTANTLY *END-CONTROL-TEXT*) :RESTRICTED)
(DEFUN READ-CONTROL-TEXT
       (STREAM &OPTIONAL (EOF-ERROR-P T) EOF-VALUE RECURSIVE-P)
  (WITH-OUTPUT-TO-STRING (STRING)
    (WITH-MODE :RESTRICTED
      (LOOP FOR TEXT = (SNARF-UNTIL-CONTROL-CHAR STREAM #\@)
            FOR NEXT = (READ-PRESERVING-WHITESPACE STREAM EOF-ERROR-P EOF-VALUE
                                                   RECURSIVE-P)
            DO (WRITE-STRING TEXT STRING)
            IF (EQ NEXT *END-CONTROL-TEXT*)
            DO (LOOP-FINISH) ELSE
            DO (WRITE-STRING NEXT STRING)))))
(DEFUN MAKE-SECTION-NAME-READER (DEFINITION-ALLOWED-P USE)
  (LAMBDA (STREAM SUB-CHAR ARG)
    (DECLARE (IGNORE SUB-CHAR ARG))
    (LET* ((NAME (READ-CONTROL-TEXT STREAM T NIL T))
           (DEFINITIONP (EQL (PEEK-CHAR NIL STREAM NIL NIL T) #\=)))
      (IF DEFINITIONP
          (IF DEFINITION-ALLOWED-P
              (PROGN
               (READ-CHAR STREAM)
               (MAKE-INSTANCE 'START-CODE-MARKER :NAME NAME))
              (RESTART-CASE (ERROR 'SECTION-NAME-DEFINITION-ERROR :NAME NAME)
                (USE-SECTION NIL :REPORT
                 "Don't define the section, just use it."
                 (FIND-SECTION NAME))))
          (IF DEFINITION-ALLOWED-P
              (RESTART-CASE (ERROR 'SECTION-NAME-USE-ERROR :NAME NAME)
                (NAME-SECTION NIL :REPORT
                 "Name the current section and start the code part."
                 (MAKE-INSTANCE 'START-CODE-MARKER :NAME NAME))
                (CITE-SECTION NIL :REPORT
                 "Assume the section is just being cited."
                 (FIND-SECTION NAME)))
              (LET ((NAMED-SECTION (FIND-SECTION NAME)))
                (IF USE
                    (PUSHNEW *CURRENT-SECTION* (USED-BY NAMED-SECTION))
                    (PUSHNEW *CURRENT-SECTION* (CITED-BY NAMED-SECTION)))
                NAMED-SECTION))))))
(SET-CONTROL-CODE #\< (MAKE-SECTION-NAME-READER T NIL) :TEX)
(SET-CONTROL-CODE #\< (MAKE-SECTION-NAME-READER NIL T) :LISP)
(SET-CONTROL-CODE #\< (MAKE-SECTION-NAME-READER NIL NIL) :INNER-LISP)
(DEFUN INDEX-PACKAGE-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE SUB-CHAR ARG))
  (LET ((FORM (READ STREAM)))
    (INDEX-PACKAGE FORM)
    FORM))
(SET-CONTROL-CODE #\x #'INDEX-PACKAGE-READER :LISP)
(DEFUN INDEX-ENTRY-READER (STREAM SUB-CHAR ARG)
  (DECLARE (IGNORE ARG))
  (ADD-INDEX-ENTRY *INDEX*
                   (MAKE-INSTANCE
                    (ECASE SUB-CHAR
                      (#\^ 'HEADING)
                      (#\. 'TT-HEADING)
                      (#\: 'CUSTOM-HEADING))
                    :NAME (READ-CONTROL-TEXT STREAM))
                   *CURRENT-SECTION*)
  (VALUES))
(DOLIST (SUB-CHAR '(#\^ #\. #\:))
  (SET-CONTROL-CODE SUB-CHAR #'INDEX-ENTRY-READER '(:TEX :LISP)))
(DEFMACRO MAYBE-PUSH (OBJ PLACE &AUX (G (GENSYM)))
  `(LET ((,G ,OBJ))
     (WHEN
         (IF (STRINGP ,G)
             (PLUSP (LENGTH ,G))
             ,G)
       (PUSH ,G ,PLACE))))
(DEFUN READ-SECTIONS (INPUT-STREAM &KEY (APPEND T))
  (WITH-CHARPOS-INPUT-STREAM (STREAM INPUT-STREAM)
    (FLET ((FINISH-SECTION (SECTION COMMENTARY CODE)
             (WHEN (STRINGP (CAR COMMENTARY))
               (RPLACA COMMENTARY
                       (STRING-RIGHT-TRIM *WHITESPACE* (CAR COMMENTARY))))
             (SETQ COMMENTARY (NREVERSE COMMENTARY))
             (WHEN (STRINGP (CAR COMMENTARY))
               (RPLACA COMMENTARY
                       (STRING-LEFT-TRIM *WHITESPACE* (CAR COMMENTARY))))
             (SETQ CODE (NREVERSE (MEMBER-IF-NOT #'NEWLINEP CODE)))
             (SETF (SECTION-COMMENTARY SECTION) COMMENTARY)
             (SETF (SECTION-CODE SECTION) CODE)
             (WHEN (SECTION-NAME SECTION)
               (LET ((NAMED-SECTION (FIND-SECTION (SECTION-NAME SECTION))))
                 (IF APPEND
                     (PUSH SECTION (NAMED-SECTION-SECTIONS NAMED-SECTION))
                     (SETF (NAMED-SECTION-SECTIONS NAMED-SECTION)
                             (LIST SECTION)))))
             SECTION))
      (PROG (FORM COMMENTARY CODE SECTION SECTIONS)
        (SETQ SECTION (MAKE-INSTANCE 'LIMBO-SECTION))
        (WITH-MODE :LIMBO
          (LOOP (MAYBE-PUSH (SNARF-UNTIL-CONTROL-CHAR STREAM #\@) COMMENTARY)
                (LET ((NEXT-INPUT
                       (READ-MAYBE-NOTHING-PRESERVING-WHITESPACE STREAM NIL
                                                                 *EOF* NIL)))
                  (WHEN NEXT-INPUT
                    (TYPECASE (SETQ FORM (CAR NEXT-INPUT))
                      (EOF (GO EOF))
                      (SECTION (GO COMMENTARY))
                      (T (PUSH FORM COMMENTARY)))))))
       COMMENTARY
        (PUSH (FINISH-SECTION SECTION COMMENTARY CODE) SECTIONS)
        (CHECK-TYPE FORM SECTION)
        (SETQ SECTION FORM
              COMMENTARY 'NIL
              CODE 'NIL)
        (WITH-MODE :TEX
          (LOOP
           (MAYBE-PUSH (SNARF-UNTIL-CONTROL-CHAR STREAM '(#\@ #\|)) COMMENTARY)
           (LET ((NEXT-INPUT
                  (READ-MAYBE-NOTHING-PRESERVING-WHITESPACE STREAM NIL *EOF*
                                                            NIL)))
             (WHEN NEXT-INPUT
               (TYPECASE (SETQ FORM (CAR NEXT-INPUT))
                 (EOF (GO EOF))
                 (SECTION (GO COMMENTARY))
                 (START-CODE-MARKER
                  (SETF (SECTION-NAME SECTION) (SECTION-NAME FORM))
                  (GO LISP))
                 (T (PUSH FORM COMMENTARY)))))))
       LISP
        (CHECK-TYPE FORM START-CODE-MARKER)
        (WITH-MODE :LISP
          (LOOP
           (LET ((NEXT-INPUT
                  (READ-MAYBE-NOTHING-PRESERVING-WHITESPACE STREAM NIL *EOF*
                                                            NIL)))
             (WHEN NEXT-INPUT
               (TYPECASE (SETQ FORM (CAR NEXT-INPUT))
                 (EOF (GO EOF))
                 (SECTION (GO COMMENTARY))
                 (START-CODE-MARKER
                  (CERROR "Start a new unnamed section with no commentary."
                          'SECTION-LACKS-COMMENTARY :STREAM STREAM)
                  (SETQ FORM (MAKE-INSTANCE 'SECTION))
                  (PUSH (FINISH-SECTION SECTION COMMENTARY CODE) SECTIONS)
                  (CHECK-TYPE FORM SECTION)
                  (SETQ SECTION FORM
                        COMMENTARY 'NIL
                        CODE 'NIL))
                 (NEWLINE-MARKER (WHEN CODE (PUSH FORM CODE)))
                 (EVALUATED-FORM-MARKER
                  (LET ((FORM (MARKER-VALUE FORM)))
                    (LET ((*EVALUATING* T)
                          (*READTABLE* (READTABLE-FOR-MODE NIL)))
                      (EVAL (TANGLE FORM)))
                    (PUSH FORM CODE)))
                 (T (PUSH FORM CODE)))))))
       EOF
        (PUSH (FINISH-SECTION SECTION COMMENTARY CODE) SECTIONS)
        (RETURN (NREVERSE SECTIONS))))))
(DEFUN TANGLE-1 (FORM &KEY (EXPAND-NAMED-SECTIONS T))
  (FLET ((TANGLE-1 (FORM)
           (TANGLE-1 FORM :EXPAND-NAMED-SECTIONS EXPAND-NAMED-SECTIONS)))
    (TYPECASE FORM
      (MARKER (VALUES (MARKER-VALUE FORM) T))
      (ATOM (VALUES FORM NIL))
      ((CONS NAMED-SECTION *)
       (MULTIPLE-VALUE-BIND (D CDR-EXPANDED-P)
           (TANGLE-1 (CDR FORM))
         (IF EXPAND-NAMED-SECTIONS
             (VALUES (APPEND (SECTION-CODE (CAR FORM)) D) T)
             (VALUES (CONS (CAR FORM) D) CDR-EXPANDED-P))))
      ((CONS MARKER *)
       (VALUES
        (IF (MARKER-BOUNDP (CAR FORM))
            (CONS (MARKER-VALUE (CAR FORM)) (TANGLE-1 (CDR FORM)))
            (TANGLE-1 (CDR FORM)))
        T))
      (T
       (MULTIPLE-VALUE-BIND (A CAR-EXPANDED-P)
           (TANGLE-1 (CAR FORM))
         (MULTIPLE-VALUE-BIND (D CDR-EXPANDED-P)
             (TANGLE-1 (CDR FORM))
           (VALUES
            (IF (AND (EQL A (CAR FORM)) (EQL D (CDR FORM)))
                FORM
                (CONS A D))
            (OR CAR-EXPANDED-P CDR-EXPANDED-P))))))))
(DEFUN TANGLE (FORM &KEY (EXPAND-NAMED-SECTIONS T))
  (LABELS ((EXPAND (FORM EXPANDED)
             (MULTIPLE-VALUE-BIND (NEW-FORM NEWLY-EXPANDED-P)
                 (TANGLE-1 FORM :EXPAND-NAMED-SECTIONS EXPAND-NAMED-SECTIONS)
               (IF NEWLY-EXPANDED-P
                   (EXPAND NEW-FORM T)
                   (VALUES NEW-FORM EXPANDED)))))
    (EXPAND FORM NIL)))
(DEFUN UNNAMED-SECTION-CODE-PARTS (SECTIONS)
  (MAPAPPEND #'SECTION-CODE (COERCE (REMOVE-IF #'SECTION-NAME SECTIONS) 'LIST)))
(DEFUN LOAD-WEB-FROM-STREAM
       (STREAM PRINT
        &KEY (APPEND T)
        &AUX (*READTABLE* *READTABLE*) (*PACKAGE* *PACKAGE*) (*EVALUATING* T))
  (DOLIST
      (FORM
       (TANGLE
        (UNNAMED-SECTION-CODE-PARTS (READ-SECTIONS STREAM :APPEND APPEND)))
       T)
    (IF PRINT
        (LET ((RESULTS (MULTIPLE-VALUE-LIST (EVAL FORM))))
          (FORMAT T "~&; ~{~S~^, ~}~%" RESULTS))
        (EVAL FORM))))
(DEFUN LOAD-WEB
       (FILESPEC
        &KEY (VERBOSE *LOAD-VERBOSE*) (PRINT *LOAD-PRINT*)
        (IF-DOES-NOT-EXIST T) (EXTERNAL-FORMAT :DEFAULT))
  "Load the web given by FILESPEC into the Lisp environment."
  (SETF (FILL-POINTER *SECTIONS*) 0)
  (SETF *CURRENT-SECTION* NIL)
  (SETF (FILL-POINTER *TEST-SECTIONS*) 0)
  (SETQ *NAMED-SECTIONS* NIL)
  (SETQ *INDEX-PACKAGES* NIL)
  (SETQ *INDEX* (MAKE-INDEX))
  (WHEN VERBOSE (FORMAT T "~&; loading WEB from ~S~%" FILESPEC))
  (IF (STREAMP FILESPEC)
      (LOAD-WEB-FROM-STREAM FILESPEC PRINT)
      (WITH-OPEN-FILE
          (STREAM
           (MERGE-PATHNAMES FILESPEC (MAKE-PATHNAME :TYPE "CLW" :CASE :COMMON))
           :DIRECTION :INPUT :EXTERNAL-FORMAT EXTERNAL-FORMAT
           :IF-DOES-NOT-EXIST
           (IF IF-DOES-NOT-EXIST
               :ERROR
               NIL))
        (LOAD-WEB-FROM-STREAM STREAM PRINT))))
(DEFUN LOAD-SECTIONS-FROM-TEMP-FILE
       (FILE APPEND &AUX (TRUENAME (PROBE-FILE FILE)))
  "Load web sections from FILE, then delete it."
  (WHEN TRUENAME
    (UNWIND-PROTECT
        (WITH-OPEN-FILE (STREAM TRUENAME :DIRECTION :INPUT)
          (LOAD-WEB-FROM-STREAM STREAM T :APPEND APPEND))
      (DELETE-FILE TRUENAME))))
(DEFUN TESTS-FILE-PATHNAME
       (OUTPUT-FILE TYPE
        &KEY (TESTS-FILE NIL TESTS-FILE-SUPPLIED-P) &ALLOW-OTHER-KEYS)
  (IF TESTS-FILE
      (MERGE-PATHNAMES TESTS-FILE (MAKE-PATHNAME :TYPE TYPE :CASE :COMMON))
      (UNLESS TESTS-FILE-SUPPLIED-P
        (MERGE-PATHNAMES
         (MAKE-PATHNAME :NAME
                        (CONCATENATE 'STRING
                                     (PATHNAME-NAME OUTPUT-FILE :CASE :COMMON)
                                     "-TESTS")
                        :TYPE TYPE :CASE :COMMON)
         OUTPUT-FILE))))
(DEFUN TANGLE-FILE
       (INPUT-FILE
        &REST ARGS
        &KEY OUTPUT-FILE TESTS-FILE (VERBOSE *COMPILE-VERBOSE*)
        (PRINT *COMPILE-PRINT*) (EXTERNAL-FORMAT :DEFAULT) &ALLOW-OTHER-KEYS
        &AUX
        (INPUT-FILE
         (MERGE-PATHNAMES INPUT-FILE
                          (MAKE-PATHNAME :TYPE "CLW" :CASE :COMMON)))
        (OUTPUT-FILE
         (APPLY #'COMPILE-FILE-PATHNAME INPUT-FILE :ALLOW-OTHER-KEYS T ARGS))
        (LISP-FILE
         (MERGE-PATHNAMES (MAKE-PATHNAME :TYPE "LISP" :CASE :COMMON)
                          OUTPUT-FILE))
        (TESTS-FILE (APPLY #'TESTS-FILE-PATHNAME OUTPUT-FILE "LISP" ARGS))
        (*TANGLE-FILE-PATHNAME* INPUT-FILE)
        (*TANGLE-FILE-TRUENAME* (TRUENAME *TANGLE-FILE-PATHNAME*))
        (*READTABLE* *READTABLE*) (*PACKAGE* *PACKAGE*))
  "Tangle and compile the web in INPUT-FILE, producing OUTPUT-FILE."
  (DECLARE (IGNORABLE OUTPUT-FILE TESTS-FILE))
  (WHEN VERBOSE (FORMAT T "~&; tangling web from ~A:~%" INPUT-FILE))
  (SETF (FILL-POINTER *SECTIONS*) 0)
  (SETF *CURRENT-SECTION* NIL)
  (SETF (FILL-POINTER *TEST-SECTIONS*) 0)
  (SETQ *NAMED-SECTIONS* NIL)
  (SETQ *INDEX-PACKAGES* NIL)
  (SETQ *INDEX* (MAKE-INDEX))
  (WITH-OPEN-FILE
      (INPUT INPUT-FILE :DIRECTION :INPUT :EXTERNAL-FORMAT EXTERNAL-FORMAT)
    (READ-SECTIONS INPUT))
  (LET ((UNUSED-SECTIONS 'NIL))
    (FLET ((NOTE-UNUSED-SECTION (SECTION)
             (WHEN (NULL (USED-BY SECTION)) (PUSH SECTION UNUSED-SECTIONS))))
      (MAP-BST #'NOTE-UNUSED-SECTION *NAMED-SECTIONS*)
      (MAP NIL
           (LAMBDA (SECTION)
             (WARN 'UNUSED-NAMED-SECTION-WARNING :FORMAT-CONTROL
                   "Unused named section <~A>." :FORMAT-ARGUMENTS
                   (LIST (SECTION-NAME SECTION))))
           (SORT UNUSED-SECTIONS #'< :KEY #'SECTION-NUMBER))))
  (FLET ((WRITE-FORMS (SECTIONS OUTPUT-FILE)
           (WITH-OPEN-FILE
               (OUTPUT OUTPUT-FILE :DIRECTION :OUTPUT :IF-EXISTS :SUPERSEDE
                :EXTERNAL-FORMAT EXTERNAL-FORMAT)
             (FORMAT OUTPUT ";;;; TANGLED WEB FROM \"~A\". DO NOT EDIT.~%"
                     INPUT-FILE)
             (LET ((*EVALUATING* NIL)
                   (*PRINT-PPRINT-DISPATCH* *TANGLE-PPRINT-DISPATCH*)
                   (*PRINT-LEVEL* NIL))
               (FORMAT OUTPUT "#+ALLEGRO~
         ~&(EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL)~
         ~&  (SETQ EXCL:*SOURCE-PATHNAME* ~S))~%"
                       *TANGLE-FILE-PATHNAME*)
               (DOLIST (FORM (TANGLE (UNNAMED-SECTION-CODE-PARTS SECTIONS)))
                 (PPRINT FORM OUTPUT))))))
    (WHEN (AND TESTS-FILE (> (LENGTH *TEST-SECTIONS*) 1))
      (WHEN VERBOSE (FORMAT T "~&; writing tests to ~A~%" TESTS-FILE))
      (WRITE-FORMS *TEST-SECTIONS* TESTS-FILE))
    (WHEN VERBOSE (FORMAT T "~&; writing tangled code to ~A~%" LISP-FILE))
    (WRITE-FORMS *SECTIONS* LISP-FILE)
    (MULTIPLE-VALUE-PROG1
        (APPLY #'COMPILE-FILE LISP-FILE :ALLOW-OTHER-KEYS T ARGS)
      (WHEN TESTS-FILE
        (COMPILE-FILE TESTS-FILE :VERBOSE VERBOSE :PRINT PRINT :EXTERNAL-FORMAT
                      EXTERNAL-FORMAT)))))
(DEFUN WEAVE
       (INPUT-FILE
        &REST ARGS
        &KEY OUTPUT-FILE TESTS-FILE (INDEX-FILE NIL INDEX-FILE-SUPPLIED-P)
        (VERBOSE *WEAVE-VERBOSE*) (PRINT *WEAVE-PRINT*) (IF-DOES-NOT-EXIST T)
        (EXTERNAL-FORMAT :DEFAULT)
        &AUX
        (INPUT-FILE
         (MERGE-PATHNAMES INPUT-FILE
                          (MAKE-PATHNAME :TYPE "CLW" :CASE :COMMON)))
        (OUTPUT-FILE
         (IF OUTPUT-FILE
             (MERGE-PATHNAMES OUTPUT-FILE
                              (MAKE-PATHNAME :TYPE "TEX" :CASE :COMMON))
             (MERGE-PATHNAMES (MAKE-PATHNAME :TYPE "TEX" :CASE :COMMON)
                              INPUT-FILE)))
        (TESTS-FILE (APPLY #'TESTS-FILE-PATHNAME OUTPUT-FILE "TEX" ARGS))
        (INDEX-FILE
         (IF INDEX-FILE
             (MERGE-PATHNAMES INDEX-FILE
                              (MAKE-PATHNAME :TYPE "IDX" :CASE :COMMON))
             (WHEN (NOT INDEX-FILE-SUPPLIED-P)
               (MERGE-PATHNAMES (MAKE-PATHNAME :TYPE "IDX" :CASE :COMMON)
                                OUTPUT-FILE))))
        (SECTIONS-FILE
         (WHEN INDEX-FILE
           (MERGE-PATHNAMES (MAKE-PATHNAME :TYPE "SCN" :CASE :COMMON)
                            INDEX-FILE)))
        (*READTABLE* *READTABLE*) (*PACKAGE* *PACKAGE*))
  "Weave the web contained in INPUT-FILE, producing the TeX file OUTPUT-FILE."
  (DECLARE (IGNORABLE TESTS-FILE))
  (WHEN VERBOSE (FORMAT T "~&; weaving web from ~A:~%" INPUT-FILE))
  (SETF (FILL-POINTER *SECTIONS*) 0)
  (SETF *CURRENT-SECTION* NIL)
  (SETF (FILL-POINTER *TEST-SECTIONS*) 0)
  (SETQ *NAMED-SECTIONS* NIL)
  (SETQ *INDEX-PACKAGES* NIL)
  (SETQ *INDEX* (MAKE-INDEX))
  (WITH-OPEN-FILE
      (INPUT INPUT-FILE :DIRECTION :INPUT :EXTERNAL-FORMAT EXTERNAL-FORMAT
       :IF-DOES-NOT-EXIST
       (IF IF-DOES-NOT-EXIST
           :ERROR
           NIL))
    (READ-SECTIONS INPUT))
  (WHEN (AND TESTS-FILE (> (LENGTH *TEST-SECTIONS*) 1))
    (WHEN VERBOSE (FORMAT T "~&; weaving tests to ~A~%" TESTS-FILE))
    (WEAVE-SECTIONS *TEST-SECTIONS* :INPUT-FILE INPUT-FILE :OUTPUT-FILE
                    TESTS-FILE :PRINT PRINT :VERBOSE VERBOSE :EXTERNAL-FORMAT
                    EXTERNAL-FORMAT :TESTS T))
  (WHEN VERBOSE (FORMAT T "~&; weaving sections to ~A~%" OUTPUT-FILE))
  (WEAVE-SECTIONS *SECTIONS* :INPUT-FILE INPUT-FILE :OUTPUT-FILE OUTPUT-FILE
                  :INDEX-FILE INDEX-FILE :SECTIONS-FILE SECTIONS-FILE :VERBOSE
                  VERBOSE :PRINT PRINT :EXTERNAL-FORMAT EXTERNAL-FORMAT))
(DEFUN WEAVE-SECTIONS
       (SECTIONS
        &KEY INPUT-FILE OUTPUT-FILE INDEX-FILE SECTIONS-FILE TESTS
        (VERBOSE *WEAVE-VERBOSE*) (PRINT *WEAVE-PRINT*)
        (EXTERNAL-FORMAT :DEFAULT))
  (FLET ((WEAVE (OBJECT STREAM)
           (WRITE OBJECT :STREAM STREAM :CASE :DOWNCASE :ESCAPE NIL :LEVEL NIL
                  :PRETTY T :PPRINT-DISPATCH *WEAVE-PPRINT-DISPATCH*
                  :RIGHT-MARGIN 1000)))
    (MACROLET ((WITH-OUTPUT-FILE ((STREAM FILESPEC) &BODY BODY)
                 `(WITH-OPEN-FILE
                      (,STREAM ,FILESPEC :DIRECTION :OUTPUT :EXTERNAL-FORMAT
                       EXTERNAL-FORMAT :IF-EXISTS :SUPERSEDE)
                    ,@BODY)))
      (WITH-OUTPUT-FILE (OUT OUTPUT-FILE) (FORMAT OUT "\\input clwebmac~%")
       (WHEN TESTS
         (FORMAT OUT "\\def\\progname{~/clweb::print-escaped/}~%"
                 (IF INPUT-FILE
                     (STRING-CAPITALIZE (PATHNAME-NAME INPUT-FILE))
                     "program")))
       (IF PRINT
           (FLET ((WEAVE (SECTION)
                    (FORMAT T "~:[~;*~]~D" (TYPEP SECTION 'STARRED-SECTION)
                            (SECTION-NUMBER SECTION))
                    (WEAVE SECTION OUT)))
             (PPRINT-LOGICAL-BLOCK
                 (NIL (COERCE SECTIONS 'LIST) :PER-LINE-PREFIX ";  ")
               (WEAVE (PPRINT-POP))
               (LOOP (PPRINT-EXIT-IF-LIST-EXHAUSTED)
                     (WRITE-CHAR #\ )
                     (PPRINT-NEWLINE :FILL)
                     (WEAVE (PPRINT-POP)))))
           (MAP NIL (LAMBDA (SECTION) (WEAVE SECTION OUT)) SECTIONS))
       (WHEN INDEX-FILE
         (WHEN VERBOSE (FORMAT T "~&; writing the index to ~A~%" INDEX-FILE))
         (WITH-OUTPUT-FILE (IDX INDEX-FILE)
          (WEAVE (INDEX-SECTIONS SECTIONS) IDX))
         (WITH-OUTPUT-FILE (SCN SECTIONS-FILE)
          (MAP-BST
           (LAMBDA (SECTION)
             (UNLESS (EVERY #'TEST-SECTION-P (NAMED-SECTION-SECTIONS SECTION))
               (WEAVE
                (MAKE-INSTANCE 'SECTION-NAME-INDEX-ENTRY :NAMED-SECTION
                               SECTION)
                SCN)))
           *NAMED-SECTIONS*))
         (FORMAT OUT "~&\\inx~%\\fin~%\\con~%"))
       (FORMAT OUT "~&\\end~%") (TRUENAME OUT)))))
(DEFUN SET-WEAVE-DISPATCH (TYPE-SPECIFIER FUNCTION &OPTIONAL (PRIORITY 0))
  (SET-PPRINT-DISPATCH TYPE-SPECIFIER FUNCTION PRIORITY
                       *WEAVE-PPRINT-DISPATCH*))
(DEFUN PRINT-TEX (STREAM TEX-MODE-MATERIAL &REST ARGS)
  (DECLARE (IGNORE ARGS))
  (DOLIST (X TEX-MODE-MATERIAL)
    (ETYPECASE X
      (STRING (WRITE-STRING X STREAM))
      (LIST (DOLIST (FORM X) (FORMAT STREAM "\\(~W\\)" FORM))))))
(DEFUN READ-TEX-FROM-STRING (INPUT-STRING)
  (WITH-MODE :RESTRICTED
    (WITH-INPUT-FROM-STRING (STREAM INPUT-STRING)
      (LOOP FOR TEXT = (SNARF-UNTIL-CONTROL-CHAR STREAM #\|)
            FOR FORMS = (READ-PRESERVING-WHITESPACE STREAM NIL *EOF* NIL)
            IF (PLUSP (LENGTH TEXT))
            COLLECT TEXT
            IF (EOF-P FORMS)
            DO (LOOP-FINISH) ELSE
            COLLECT FORMS))))
(DEFUN PRINT-LIMBO (STREAM SECTION)
  (LET ((COMMENTARY (SECTION-COMMENTARY SECTION)))
    (WHEN COMMENTARY (PRINT-TEX STREAM COMMENTARY) (TERPRI STREAM))))
(SET-WEAVE-DISPATCH 'LIMBO-SECTION #'PRINT-LIMBO 1)
(DEFUN PRINT-SECTION (STREAM SECTION)
  (FORMAT STREAM "~&\\~:[M~;N{1}~]{~D}" (TYPEP SECTION 'STARRED-SECTION)
          (SECTION-NUMBER SECTION))
  (LET* ((COMMENTARY (SECTION-COMMENTARY SECTION))
         (NAME (SECTION-NAME SECTION))
         (NAMED-SECTION (AND NAME (FIND-SECTION NAME)))
         (CODE (SECTION-CODE SECTION)))
    (PRINT-TEX STREAM COMMENTARY)
    (COND ((AND COMMENTARY CODE) (FORMAT STREAM "~&\\Y\\B~%"))
          (CODE (FORMAT STREAM "~&\\B~%")))
    (WHEN NAMED-SECTION
      (PRINT-SECTION-NAME STREAM NAMED-SECTION)
      (FORMAT STREAM "${}~:[\\mathrel+~;~]\\E{}$~%"
              (= (SECTION-NUMBER SECTION) (SECTION-NUMBER NAMED-SECTION))))
    (WHEN CODE
      (DOLIST (FORM CODE)
        (IF (OR (LIST-MARKER-P FORM) (LISTP FORM))
            (FORMAT STREAM "~@<\\+~@;~W~;\\cr~:>" FORM)
            (FORMAT STREAM "~W~:[\\par~;~]" FORM (NEWLINEP FORM))))
      (FORMAT STREAM "~&\\egroup~%"))
    (WHEN
        (AND (NOT NAMED-SECTION) (TYPEP SECTION 'TEST-SECTION)
             (SECTION-CODE SECTION))
      (FORMAT STREAM "\\T~P~D.~%" (LENGTH (SECTION-CODE SECTION))
              (SECTION-NUMBER (TEST-FOR-SECTION SECTION))))
    (WHEN
        (AND NAMED-SECTION
             (= (SECTION-NUMBER SECTION) (SECTION-NUMBER NAMED-SECTION)))
      (PRINT-XREFS STREAM #\A
                   (REMOVE SECTION (NAMED-SECTION-SECTIONS NAMED-SECTION)))
      (PRINT-XREFS STREAM #\U (REMOVE SECTION (USED-BY NAMED-SECTION)))
      (PRINT-XREFS STREAM #\Q (REMOVE SECTION (CITED-BY NAMED-SECTION)))))
  (FORMAT STREAM "\\fi~%"))
(SET-WEAVE-DISPATCH 'SECTION #'PRINT-SECTION)
(DEFUN PRINT-XREFS (STREAM KIND XREFS)
  (WHEN XREFS
    (FORMAT STREAM
            "\\~C~{~#[~;~D~;s ~D\\ET~D~:;s~@{~#[~;\\ETs~D~;~D~:;~D, ~]~}~]~}.~%"
            KIND (SORT (MAPCAR #'SECTION-NUMBER XREFS) #'<))))
(DEFUN PRINT-SECTION-NAME (STREAM SECTION &KEY (INDEXING NIL))
  (FORMAT STREAM "~:[~;\\I~]\\X~{~D~^, ~}:~/clweb::print-TeX/\\X" INDEXING
          (IF INDEXING
              (SORT (MAPCAR #'SECTION-NUMBER (NAMED-SECTION-SECTIONS SECTION))
                    #'<)
              (LIST (SECTION-NUMBER SECTION)))
          (READ-TEX-FROM-STRING (SECTION-NAME SECTION))))
(SET-WEAVE-DISPATCH 'NAMED-SECTION #'PRINT-SECTION-NAME)
(DEFCLASS SECTION-NAME-INDEX-ENTRY NIL
          ((NAMED-SECTION :ACCESSOR NAMED-SECTION :INITARG :NAMED-SECTION)))
(SET-WEAVE-DISPATCH 'SECTION-NAME-INDEX-ENTRY
                    (LAMBDA
                        (STREAM SECTION-NAME
                         &AUX (SECTION (NAMED-SECTION SECTION-NAME)))
                      (PRINT-SECTION-NAME STREAM SECTION :INDEXING T)
                      (TERPRI STREAM)
                      (PRINT-XREFS STREAM #\U
                                   (REMOVE SECTION (USED-BY SECTION)))
                      (PRINT-XREFS STREAM #\Q
                                   (REMOVE SECTION (CITED-BY SECTION)))))
(DEFPARAMETER *PRINT-ESCAPE-LIST*
  '((" \\%&#$^_~" . #\\) ("{" . "$\\{$") ("}" . "$\\}$")))
(DEFUN PRINT-ESCAPED
       (STREAM STRING
        &REST ARGS
        &AUX
        (STREAM
         (CASE STREAM
           ((T) *TERMINAL-IO*)
           ((NIL) *STANDARD-OUTPUT*)
           (OTHERWISE STREAM))))
  (DECLARE (IGNORE ARGS))
  (LOOP FOR CHAR ACROSS STRING AS ESCAPE = (CDR
                                            (ASSOC CHAR *PRINT-ESCAPE-LIST*
                                                   :TEST #'FIND))
        IF ESCAPE
        DO (ETYPECASE ESCAPE
             (CHARACTER (WRITE-CHAR ESCAPE STREAM) (WRITE-CHAR CHAR STREAM))
             (STRING (WRITE-STRING ESCAPE STREAM))) ELSE
        DO (WRITE-CHAR CHAR STREAM)))
(DEFUN PRINT-STRING (STREAM STRING)
  (LOOP WITH *PRINT-ESCAPE-LIST* = `(("{*}" . #\\) ("\\" . "\\\\\\\\")
                                     ("\"" . "\\\\\"") ,@*PRINT-ESCAPE-LIST*)
        FOR LAST = 0 THEN (IF (CHAR= (ELT STRING (1- NEWLINE)) #\~)
                              (POSITION-IF-NOT #'WHITESPACEP STRING :START
                                               NEWLINE)
                              (1+ NEWLINE))
        FOR NEWLINE = (POSITION #\Newline STRING :START LAST) AS LINE = (SUBSEQ
                                                                         STRING
                                                                         LAST
                                                                         NEWLINE)
        DO (FORMAT STREAM "\\.{~:[~;\"~]~/clweb::print-escaped/~:[~;\"~]}"
                   (ZEROP LAST) LINE (NULL NEWLINE))
        WHILE NEWLINE
        DO (FORMAT STREAM "\\cr~:@_")))
(SET-WEAVE-DISPATCH 'STRING #'PRINT-STRING)
(DEFUN PRINT-CHAR (STREAM CHAR)
  (LET ((GRAPHICP (AND (GRAPHIC-CHAR-P CHAR) (STANDARD-CHAR-P CHAR)))
        (NAME (CHAR-NAME CHAR))
        (*PRINT-ESCAPE-LIST* `(("{}" . #\\) ,@*PRINT-ESCAPE-LIST*)))
    (FORMAT STREAM "\\#\\CH{~/clweb::print-escaped/}"
            (IF (AND NAME (NOT GRAPHICP))
                NAME
                (MAKE-STRING 1 :INITIAL-ELEMENT CHAR)))
    CHAR))
(SET-WEAVE-DISPATCH 'CHARACTER #'PRINT-CHAR)
(DEFUN PRINT-SYMBOL (STREAM SYMBOL)
  (LET* ((GROUP-P
          (COND
           ((MEMBER SYMBOL LAMBDA-LIST-KEYWORDS) (WRITE-STRING "\\K{" STREAM))
           ((KEYWORDP SYMBOL) (WRITE-STRING "\\:{" STREAM))))
         (STRING (WRITE-TO-STRING SYMBOL :ESCAPE NIL :PRETTY NIL)))
    (MULTIPLE-VALUE-BIND (PREFIX SUFFIX)
        (LOOP WITH STRING-LENGTH = (LENGTH STRING)
              FOR (SUFFIX
                   . REPLACEMENT) IN *PRINT-SYMBOL-SUFFIXES* AS PREFIX-END = (MAX
                                                                              0
                                                                              (-
                                                                               STRING-LENGTH
                                                                               (LENGTH
                                                                                SUFFIX)))
              WHEN (STRING= STRING SUFFIX :START1 PREFIX-END)
              DO (RETURN (VALUES (SUBSEQ STRING 0 PREFIX-END) REPLACEMENT))
              FINALLY (RETURN STRING))
      (PRINT-ESCAPED STREAM PREFIX)
      (WHEN SUFFIX (WRITE-STRING SUFFIX STREAM)))
    (WHEN GROUP-P (WRITE-STRING "}" STREAM))))
(SET-WEAVE-DISPATCH 'SYMBOL #'PRINT-SYMBOL)
(MACROLET ((WEAVE-SYMBOL (SYMBOL REPLACEMENT)
             `(SET-WEAVE-DISPATCH '(EQL ,SYMBOL)
                                  (LAMBDA (STREAM OBJ)
                                    (DECLARE (IGNORE OBJ))
                                    (WRITE-STRING ,REPLACEMENT STREAM))
                                  1)))
  (WEAVE-SYMBOL LAMBDA "\\L")
  (WEAVE-SYMBOL PI "$\\pi$"))
(DEFSTRUCT (LOGICAL-BLOCK (:CONSTRUCTOR MAKE-LOGICAL-BLOCK (LIST))) LIST)
(DEFUN ANALYZE-INDENTATION (LIST-MARKER)
  (DECLARE (TYPE LIST-MARKER LIST-MARKER))
  (LABELS ((FIND-NEXT-NEWLINE (LIST)
             (MEMBER-IF #'NEWLINEP LIST :KEY #'CAR))
           (NEXT-LOGICAL-BLOCK (LIST)
             (DO* ((BLOCK 'NIL)
                   (BLOCK-INDENT (CDAR LIST))
                   (INDENT BLOCK-INDENT)
                   (NEWLINE (FIND-NEXT-NEWLINE LIST))
                   (NEXT-INDENT (CDADR NEWLINE)))
                  ((OR (ENDP LIST)
                       (AND (EQ LIST NEWLINE) NEXT-INDENT
                            (< 0 NEXT-INDENT BLOCK-INDENT)))
                   (VALUES
                    (IF (NOTANY #'NEWLINEP BLOCK)
                        (NREVERSE BLOCK)
                        (MAKE-LOGICAL-BLOCK (NREVERSE BLOCK)))
                    LIST))
               (IF (AND INDENT NEXT-INDENT (> NEXT-INDENT INDENT)
                        (= NEXT-INDENT (CDAR LIST)))
                   (MULTIPLE-VALUE-BIND (SUB-BLOCK TAIL)
                       (NEXT-LOGICAL-BLOCK LIST)
                     (CHECK-TYPE (CAAR TAIL) (OR NEWLINE-MARKER NULL))
                     (PUSH SUB-BLOCK BLOCK)
                     (SETQ LIST TAIL))
                   (LET ((NEXT (CAR (POP LIST))))
                     (PUSH NEXT BLOCK)
                     (WHEN (AND LIST (NEWLINEP NEXT))
                       (SETF INDENT (CDAR LIST)
                             (INDENTATION NEXT) (- INDENT BLOCK-INDENT)
                             NEWLINE (FIND-NEXT-NEWLINE LIST)
                             NEXT-INDENT (CDADR NEWLINE))))))))
    (ASSERT
     (= (LENGTH (LIST-MARKER-LIST LIST-MARKER))
        (LENGTH (LIST-MARKER-CHARPOS LIST-MARKER)))
     ((LIST-MARKER-LIST LIST-MARKER) (LIST-MARKER-CHARPOS LIST-MARKER))
     "List marker's list and charpos-list aren't the same length.")
    (NEXT-LOGICAL-BLOCK
     (MAPCAR #'CONS (LIST-MARKER-LIST LIST-MARKER)
             (LIST-MARKER-CHARPOS LIST-MARKER)))))
(DEFUN PRINT-LIST (STREAM LIST-MARKER)
  (LET ((BLOCK (ANALYZE-INDENTATION LIST-MARKER)))
    (ETYPECASE BLOCK
      (LIST (FORMAT STREAM "~<(~;~@{~W~^ ~}~;)~:>" BLOCK))
      (LOGICAL-BLOCK (FORMAT STREAM "(~W)" BLOCK)))))
(SET-WEAVE-DISPATCH 'LIST-MARKER #'PRINT-LIST)
(DEFUN PRINT-LOGICAL-BLOCK (STREAM BLOCK)
  (WRITE-STRING "\\!" STREAM)
  (PPRINT-LOGICAL-BLOCK
      (STREAM (LOGICAL-BLOCK-LIST BLOCK) :PER-LINE-PREFIX "&")
    (DO (INDENT
         NEXT
         (OBJ (PPRINT-POP) NEXT))
        (NIL)
      (COND
       ((NEWLINEP OBJ)
        (FORMAT STREAM "\\cr~:[~;\\Y~]~:@_" (TYPEP OBJ 'PAR-MARKER))
        (SETQ INDENT (INDENTATION OBJ)) (PPRINT-EXIT-IF-LIST-EXHAUSTED)
        (SETQ NEXT (PPRINT-POP)))
       (T (FORMAT STREAM "~@[~[~;\\1~;\\1~:;\\2~]~]~W" INDENT OBJ)
        (SETQ INDENT NIL) (PPRINT-EXIT-IF-LIST-EXHAUSTED)
        (SETQ NEXT (PPRINT-POP))
        (UNLESS (NEWLINEP NEXT) (WRITE-CHAR #\  STREAM)))))))
(SET-WEAVE-DISPATCH 'LOGICAL-BLOCK #'PRINT-LOGICAL-BLOCK)
(SET-WEAVE-DISPATCH 'NEWLINE-MARKER
                    (LAMBDA (STREAM OBJ)
                      (DECLARE (IGNORE OBJ))
                      (TERPRI STREAM)))
(SET-WEAVE-DISPATCH 'PAR-MARKER
                    (LAMBDA (STREAM OBJ)
                      (DECLARE (IGNORE OBJ))
                      (FORMAT STREAM "~&\\Y~%"))
                    1)
(SET-WEAVE-DISPATCH 'EMPTY-LIST-MARKER
                    (LAMBDA (STREAM OBJ)
                      (DECLARE (IGNORE OBJ))
                      (WRITE-STRING "()" STREAM)))
(SET-WEAVE-DISPATCH 'CONSING-DOT-MARKER
                    (LAMBDA (STREAM OBJ)
                      (DECLARE (IGNORE OBJ))
                      (WRITE-CHAR #\. STREAM)))
(SET-WEAVE-DISPATCH 'QUOTE-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\'~W" (QUOTED-FORM OBJ))))
(SET-WEAVE-DISPATCH 'COMMENT-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\C{~/clweb::print-TeX/}"
                              (READ-TEX-FROM-STRING (COMMENT-TEXT OBJ)))))
(SET-WEAVE-DISPATCH 'BACKQUOTE
                    (LAMBDA (STREAM OBJ) (FORMAT STREAM "\\`~W" (CADR OBJ))))
(SET-WEAVE-DISPATCH 'SPLICING-COMMA
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\CO{~C}~W" (COMMA-MODIFIER OBJ)
                              (SLOT-VALUE OBJ 'FORM)))
                    1)
(SET-WEAVE-DISPATCH 'COMMA
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\CO{}~W" (SLOT-VALUE OBJ 'FORM))))
(SET-WEAVE-DISPATCH 'FUNCTION-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\#\\'~S" (QUOTED-FORM OBJ)))
                    1)
(SET-WEAVE-DISPATCH 'SIMPLE-VECTOR-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\#~@[~D~]~S"
                              (AND (SLOT-BOUNDP OBJ 'LENGTH)
                                   (SLOT-VALUE OBJ 'LENGTH))
                              (SLOT-VALUE OBJ 'ELEMENTS))))
(SET-WEAVE-DISPATCH 'BIT-VECTOR-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\#~@[~D~]*~{~[0~;1~]~}"
                              (AND (SLOT-BOUNDP OBJ 'LENGTH)
                                   (SLOT-VALUE OBJ 'LENGTH))
                              (MAP 'LIST #'IDENTITY
                                   (SLOT-VALUE OBJ 'ELEMENTS))))
                    1)
(SET-WEAVE-DISPATCH 'READ-TIME-EVAL-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\#.~W" (READ-TIME-EVAL-FORM OBJ))))
(SET-WEAVE-DISPATCH 'RADIX-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "$~VR_{~2:*~D}$" (RADIX-MARKER-BASE OBJ)
                              (MARKER-VALUE OBJ))))
(SET-WEAVE-DISPATCH 'COMPLEX-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\#C~W" (COMPLEX-COMPONENTS OBJ))))
(SET-WEAVE-DISPATCH 'ARRAY-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\#~DA~W" (ARRAY-MARKER-RANK OBJ)
                              (ARRAY-MARKER-INITIAL-CONTENTS OBJ))))
(SET-WEAVE-DISPATCH 'STRUCTURE-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM "\\#S~W" (STRUCTURE-MARKER-FORM OBJ))))
(SET-WEAVE-DISPATCH 'READ-TIME-CONDITIONAL-MARKER
                    (LAMBDA (STREAM OBJ)
                      (FORMAT STREAM
                              "\\#~:[--~;+~]\\RC{~S ~/clweb::print-escaped/}"
                              (READ-TIME-CONDITIONAL-PLUSP OBJ)
                              (READ-TIME-CONDITIONAL-TEST OBJ)
                              (READ-TIME-CONDITIONAL-FORM OBJ))))
(DEFCLASS WALKER NIL NIL)
(DEFGENERIC WALK-FORM
    (WALKER FORM &OPTIONAL ENV))
(DEFGENERIC WALK-AS-SPECIAL-FORM-P
    (WALKER OPERATOR FORM ENV))
(DEFGENERIC MACROEXPAND-FOR-WALK
    (WALKER FORM ENV))
(DEFGENERIC AUGMENT-WALKER-ENVIRONMENT
    (WALKER ENV &REST ARGS))
(DEFGENERIC WALK-ATOMIC-FORM
    (WALKER CONTEXT FORM ENV &KEY))
(DEFGENERIC WALK-COMPOUND-FORM
    (WALKER OPERATOR FORM ENV))
(DEFGENERIC WALK-FUNCTION-NAME
    (WALKER FUNCTION-NAME ENV &KEY &ALLOW-OTHER-KEYS))
(DEFGENERIC WALK-DECLARATION-SPECIFIERS
    (WALKER DECLS ENV))
(UNLESS (FBOUNDP 'ENSURE-PORTABLE-WALKING-ENVIRONMENT)
  (DEFUN ENSURE-PORTABLE-WALKING-ENVIRONMENT (ENV) ENV))
(DEFUN ENCLOSE
       (LAMBDA-EXPRESSION &OPTIONAL ENV (WALKER (MAKE-INSTANCE 'WALKER)))
  (COERCE (WALK-FORM WALKER LAMBDA-EXPRESSION ENV) 'FUNCTION))
(EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)
  (UNLESS (FBOUNDP 'PARSE-MACRO)
    (DEFUN PARSE-MACRO (NAME LAMBDA-LIST BODY &OPTIONAL ENV)
      (DECLARE (IGNORABLE NAME LAMBDA-LIST BODY ENV))
      #+:ALLEGRO (excl::defmacro-expander `(,name ,lambda-list ,@body) env)
      #-:ALLEGRO (error "PARSE-MACRO not implemented"))))
(DEFMACRO REORDER-ENV-INFORMATION (FN ORIG)
  `(DEFUN ,FN (&REST ARGS)
     (MULTIPLE-VALUE-BIND (TYPE LOCATIVE DECLARATIONS LOCAL)
         (APPLY ,ORIG ARGS)
       (DECLARE (IGNORE LOCATIVE))
       (VALUES TYPE LOCAL DECLARATIONS))))
#+:ALLEGRO (reorder-env-information variable-information #'sys:variable-information)
#+:ALLEGRO (reorder-env-information function-information #'sys:function-information)
(DEFMETHOD WALK-FORM
           ((WALKER WALKER) FORM
            &OPTIONAL ENV
            &AUX (ENV (ENSURE-PORTABLE-WALKING-ENVIRONMENT ENV)) (EXPANDED T))
  (FLET ((SYMBOL-MACRO-P (FORM ENV)
           (AND (SYMBOLP FORM)
                (EQL (VARIABLE-INFORMATION FORM ENV) :SYMBOL-MACRO))))
    (LOOP
     (CATCH FORM
       (COND ((SYMBOL-MACRO-P FORM ENV))
             ((ATOM FORM)
              (RETURN (WALK-ATOMIC-FORM WALKER :EVALUATED FORM ENV)))
             ((NOT (SYMBOLP (CAR FORM))) (RETURN (WALK-LIST WALKER FORM ENV)))
             ((OR (NOT EXPANDED)
                  (WALK-AS-SPECIAL-FORM-P WALKER (CAR FORM) FORM ENV))
              (RETURN (WALK-COMPOUND-FORM WALKER (CAR FORM) FORM ENV)))))
     (MULTIPLE-VALUE-SETQ (FORM EXPANDED)
       (MACROEXPAND-FOR-WALK WALKER FORM ENV)))))
(DEFMETHOD WALK-AS-SPECIAL-FORM-P (WALKER OPERATOR FORM ENV)
  (DECLARE (IGNORE WALKER OPERATOR FORM ENV))
  NIL)
(DEFMETHOD MACROEXPAND-FOR-WALK ((WALKER WALKER) FORM ENV)
  (MACROEXPAND-1 FORM ENV))
(DEFMETHOD AUGMENT-WALKER-ENVIRONMENT ((WALKER WALKER) ENV &REST ARGS)
  (APPLY #'AUGMENT-ENVIRONMENT ENV ARGS))
(DEFUN WALK-LIST (WALKER LIST ENV)
  (DO ((FORM LIST (CDR FORM))
       (NEWFORM NIL (CONS (WALK-FORM WALKER (CAR FORM) ENV) NEWFORM)))
      ((ATOM FORM) (NRECONC NEWFORM FORM))))
(DEFMETHOD WALK-ATOMIC-FORM ((WALKER WALKER) CONTEXT FORM ENV &KEY)
  (DECLARE (IGNORE CONTEXT ENV))
  FORM)
(DEFMETHOD WALK-COMPOUND-FORM ((WALKER WALKER) OPERATOR FORM ENV)
  (DECLARE (IGNORE OPERATOR))
  `(,(WALK-ATOMIC-FORM WALKER :UNEVALUATED (CAR FORM) ENV)
    ,@(WALK-LIST WALKER (CDR FORM) ENV)))
(DEFTYPE SETF-FUNCTION-NAME () '(CONS (EQL SETF) (CONS SYMBOL NULL)))
(DEFUN SETF-FUNCTION-NAME-P (FUNCTION-NAME)
  (TYPEP FUNCTION-NAME 'SETF-FUNCTION-NAME))
(DEFMETHOD WALK-FUNCTION-NAME ((WALKER WALKER) FUNCTION-NAME ENV &KEY)
  (TYPECASE FUNCTION-NAME
    (SYMBOL (WALK-ATOMIC-FORM WALKER :UNEVALUATED FUNCTION-NAME ENV))
    (SETF-FUNCTION-NAME
     `(SETF ,(WALK-ATOMIC-FORM WALKER :UNEVALUATED (CADR FUNCTION-NAME) ENV)))
    (T
     (CERROR "Use the function name anyway." 'INVALID-FUNCTION-NAME :NAME
             FUNCTION-NAME)
     FUNCTION-NAME)))
(MACROLET ((WALK-AS-SPECIAL-FORM (OPERATOR)
             `(DEFMETHOD WALK-AS-SPECIAL-FORM-P
                         ((WALKER WALKER) (OPERATOR (EQL (QUOTE ,OPERATOR)))
                          FORM ENV)
                (DECLARE (IGNORE FORM ENV))
                T)))
  (WALK-AS-SPECIAL-FORM CATCH)
  (WALK-AS-SPECIAL-FORM IF)
  (WALK-AS-SPECIAL-FORM LOAD-TIME-VALUE)
  (WALK-AS-SPECIAL-FORM MULTIPLE-VALUE-CALL)
  (WALK-AS-SPECIAL-FORM MULTIPLE-VALUE-PROG1)
  (WALK-AS-SPECIAL-FORM PROGN)
  (WALK-AS-SPECIAL-FORM PROGV)
  (WALK-AS-SPECIAL-FORM SETQ)
  (WALK-AS-SPECIAL-FORM TAGBODY)
  (WALK-AS-SPECIAL-FORM THROW)
  (WALK-AS-SPECIAL-FORM UNWIND-PROTECT))
(DEFMACRO DEFINE-SPECIAL-FORM-WALKER
          (OPERATOR (WALKER FORM ENV &REST REST)
           &BODY BODY
           &AUX (OPARG `(,(GENSYM) (EQL ',OPERATOR))))
  (FLET ((ARG-NAME (ARG)
           (IF (CONSP ARG)
               (CAR ARG)
               ARG)))
    `(PROGN
      (DEFMETHOD WALK-AS-SPECIAL-FORM-P (,WALKER ,OPARG ,FORM ,ENV)
        (DECLARE
         (IGNORABLE ,@(MAPCAR (FUNCTION ARG-NAME) `(,WALKER ,FORM ,ENV))))
        T)
      (DEFMETHOD WALK-COMPOUND-FORM (,WALKER ,OPARG ,FORM ,ENV ,@REST)
        (DECLARE
         (IGNORABLE ,@(MAPCAR (FUNCTION ARG-NAME) `(,WALKER ,FORM ,ENV))))
        ,@BODY))))
(MACROLET ((DEFINE-BLOCK-LIKE-WALKER (OPERATOR)
             `(DEFINE-SPECIAL-FORM-WALKER ,OPERATOR
                  ((WALKER WALKER) FORM ENV)
                `(,(CAR FORM)
                  ,(WALK-ATOMIC-FORM WALKER :UNEVALUATED (CADR FORM) ENV)
                  ,@(WALK-LIST WALKER (CDDR FORM) ENV)))))
  (DEFINE-BLOCK-LIKE-WALKER BLOCK)
  (DEFINE-BLOCK-LIKE-WALKER EVAL-WHEN)
  (DEFINE-BLOCK-LIKE-WALKER RETURN-FROM)
  (DEFINE-BLOCK-LIKE-WALKER THE))
(MACROLET ((DEFINE-QUOTE-LIKE-WALKER (OPERATOR)
             `(DEFINE-SPECIAL-FORM-WALKER ,OPERATOR
                  ((WALKER WALKER) FORM ENV)
                (DECLARE (IGNORE WALKER ENV))
                FORM)))
  (DEFINE-QUOTE-LIKE-WALKER QUOTE)
  (DEFINE-QUOTE-LIKE-WALKER GO))
(DEFINE-SPECIAL-FORM-WALKER FUNCTION
    ((WALKER WALKER) FORM ENV)
  `(,(CAR FORM)
    ,(IF (AND (CONSP (CADR FORM)) (EQL (CAADR FORM) 'LAMBDA))
         (WALK-LAMBDA-EXPRESSION WALKER (CADR FORM) ENV)
         (WALK-FUNCTION-NAME WALKER (CADR FORM) ENV))))
(DEFUN PARSE-BODY (BODY &KEY DOC-STRING-ALLOWED WALKER ENV &AUX DOC)
  (FLET ((DOC-STRING-P (X REMAINING-FORMS)
           (AND (STRINGP X) DOC-STRING-ALLOWED REMAINING-FORMS (NULL DOC)))
         (DECLARATION-P (X)
           (AND (LISTP X) (EQL (CAR X) 'DECLARE))))
    (LOOP FOR FORMS = BODY THEN (CDR FORMS) AS X = (CAR FORMS)
          WHILE FORMS
          IF (DOC-STRING-P X (CDR FORMS))
          DO (SETQ DOC X) ELSE
          IF (DECLARATION-P X)
          APPEND (CDR X) INTO DECLS ELSE
          DO (LOOP-FINISH)
          FINALLY (RETURN
                   (VALUES FORMS
                           (IF WALKER
                               (WALK-DECLARATION-SPECIFIERS WALKER DECLS ENV)
                               DECLS)
                           DOC)))))
(DEFMETHOD WALK-DECLARATION-SPECIFIERS ((WALKER WALKER) DECLS ENV)
  (DECLARE (IGNORE ENV))
  DECLS)
(DEFUN WALK-LAMBDA-LIST
       (WALKER LAMBDA-LIST DECLS ENV &AUX NEW-LAMBDA-LIST (STATE :REQVARS))
  (LABELS ((AUGMENT-ENV (&REST VARS &AUX (VARS (REMOVE-IF #'NULL VARS)))
             (SETQ ENV
                     (AUGMENT-WALKER-ENVIRONMENT WALKER ENV :VARIABLE VARS
                                                 :DECLARE DECLS)))
           (WALK-VAR (VAR)
             (WALK-ATOMIC-FORM WALKER :BINDING VAR ENV))
           (UPDATE-STATE (KEYWORD)
             (SETQ STATE
                     (ECASE KEYWORD
                       ((NIL) STATE)
                       (&OPTIONAL :OPTVARS)
                       ((&REST &BODY) :RESTVAR)
                       (&KEY :KEYVARS)
                       (&AUX :AUXVARS)
                       (&ENVIRONMENT :ENVVAR))))
           (MAYBE-DESTRUCTURE (VAR/PATTERN)
             (IF (CONSP VAR/PATTERN)
                 (WALK-LAMBDA-LIST WALKER VAR/PATTERN DECLS ENV)
                 (VALUES (WALK-VAR VAR/PATTERN) (AUGMENT-ENV VAR/PATTERN)))))
    (LET ((WHOLEVAR
           (AND (CONSP LAMBDA-LIST) (EQL (CAR LAMBDA-LIST) '&WHOLE)
                (PUSH (POP LAMBDA-LIST) NEW-LAMBDA-LIST)
                (CAR (PUSH (WALK-VAR (POP LAMBDA-LIST)) NEW-LAMBDA-LIST))))
          (ENVVAR
           (DO ((LAMBDA-LIST LAMBDA-LIST (CDR LAMBDA-LIST)))
               ((ATOM LAMBDA-LIST) NIL)
             (WHEN (EQL (CAR LAMBDA-LIST) '&ENVIRONMENT)
               (RETURN (CADR LAMBDA-LIST))))))
      (AUGMENT-ENV WHOLEVAR ENVVAR))
    (DO* ((LAMBDA-LIST LAMBDA-LIST (CDR LAMBDA-LIST))
          (ARG (CAR LAMBDA-LIST) (CAR LAMBDA-LIST)))
         ((NULL LAMBDA-LIST) (VALUES (NREVERSE NEW-LAMBDA-LIST) ENV))
      (ECASE STATE
        (:ENVVAR
         (PUSH (WALK-VAR (POP LAMBDA-LIST)) NEW-LAMBDA-LIST)
         (WHEN (CONSP LAMBDA-LIST) (UPDATE-STATE (CAR LAMBDA-LIST))))
        ((:REQVARS :RESTVAR)
         (ETYPECASE ARG
           (SYMBOL
            (COND
             ((MEMBER ARG LAMBDA-LIST-KEYWORDS) (PUSH ARG NEW-LAMBDA-LIST)
              (UPDATE-STATE ARG))
             (T (SETQ ARG (WALK-VAR ARG)) (AUGMENT-ENV ARG)
              (PUSH ARG NEW-LAMBDA-LIST))))
           (CONS
            (MULTIPLE-VALUE-BIND (PATTERN NEW-ENV)
                (WALK-LAMBDA-LIST WALKER ARG DECLS ENV)
              (SETQ ENV NEW-ENV)
              (PUSH PATTERN NEW-LAMBDA-LIST)))))
        (:OPTVARS
         (ETYPECASE ARG
           (SYMBOL
            (COND
             ((MEMBER ARG LAMBDA-LIST-KEYWORDS) (PUSH ARG NEW-LAMBDA-LIST)
              (UPDATE-STATE ARG))
             (T (SETQ ARG (WALK-VAR ARG)) (AUGMENT-ENV ARG)
              (PUSH ARG NEW-LAMBDA-LIST))))
           (CONS
            (DESTRUCTURING-BIND
                (VAR/PATTERN &OPTIONAL INIT-FORM SUPPLIED-P-PARAMETER)
                ARG
              (WHEN INIT-FORM
                (SETQ INIT-FORM (WALK-FORM WALKER INIT-FORM ENV)))
              (MULTIPLE-VALUE-SETQ (VAR/PATTERN ENV)
                (MAYBE-DESTRUCTURE VAR/PATTERN))
              (WHEN SUPPLIED-P-PARAMETER (AUGMENT-ENV SUPPLIED-P-PARAMETER))
              (PUSH
               (NCONC (LIST VAR/PATTERN) (AND INIT-FORM (LIST INIT-FORM))
                      (AND SUPPLIED-P-PARAMETER (LIST SUPPLIED-P-PARAMETER)))
               NEW-LAMBDA-LIST)))))
        (:KEYVARS
         (COND
          ((EQL ARG '&ALLOW-OTHER-KEYS)
           (PUSH (POP LAMBDA-LIST) NEW-LAMBDA-LIST)
           (UPDATE-STATE (CAR LAMBDA-LIST)))
          (T
           (ETYPECASE ARG
             (SYMBOL
              (COND
               ((MEMBER ARG LAMBDA-LIST-KEYWORDS) (PUSH ARG NEW-LAMBDA-LIST)
                (UPDATE-STATE ARG))
               (T (SETQ ARG (WALK-VAR ARG)) (AUGMENT-ENV ARG)
                (PUSH ARG NEW-LAMBDA-LIST))))
             (CONS
              (DESTRUCTURING-BIND
                  (VAR/KV &OPTIONAL INIT-FORM SUPPLIED-P-PARAMETER)
                  ARG
                (WHEN INIT-FORM
                  (SETQ INIT-FORM (WALK-FORM WALKER INIT-FORM ENV)))
                (COND
                 ((CONSP VAR/KV)
                  (DESTRUCTURING-BIND
                      (KEYWORD-NAME VAR/PATTERN)
                      VAR/KV
                    (MULTIPLE-VALUE-SETQ (VAR/PATTERN ENV)
                      (MAYBE-DESTRUCTURE VAR/PATTERN))
                    (SETQ VAR/KV (LIST (WALK-VAR KEYWORD-NAME) VAR/PATTERN))))
                 (T (SETQ VAR/KV (WALK-VAR VAR/KV)) (AUGMENT-ENV VAR/KV)))
                (WHEN SUPPLIED-P-PARAMETER
                  (SETQ SUPPLIED-P-PARAMETER (WALK-VAR SUPPLIED-P-PARAMETER))
                  (AUGMENT-ENV SUPPLIED-P-PARAMETER))
                (PUSH
                 (NCONC (LIST VAR/KV) (AND INIT-FORM (LIST INIT-FORM))
                        (AND SUPPLIED-P-PARAMETER (LIST SUPPLIED-P-PARAMETER)))
                 NEW-LAMBDA-LIST)))))))
        (:AUXVARS
         (ETYPECASE ARG
           (SYMBOL
            (COND
             ((MEMBER ARG LAMBDA-LIST-KEYWORDS) (PUSH ARG NEW-LAMBDA-LIST)
              (UPDATE-STATE ARG))
             (T (SETQ ARG (WALK-VAR ARG)) (AUGMENT-ENV ARG)
              (PUSH ARG NEW-LAMBDA-LIST))))
           (CONS
            (DESTRUCTURING-BIND
                (VAR &OPTIONAL INIT-FORM)
                ARG
              (SETQ VAR (WALK-VAR VAR)
                    INIT-FORM (AND INIT-FORM (WALK-FORM WALKER INIT-FORM ENV)))
              (AUGMENT-ENV VAR)
              (PUSH (NCONC (LIST VAR) (AND INIT-FORM (LIST INIT-FORM)))
                    NEW-LAMBDA-LIST))))))
      (WHEN
          (OR (ATOM LAMBDA-LIST)
              (AND (CDR LAMBDA-LIST) (ATOM (CDR LAMBDA-LIST))))
        (LET ((VAR
               (WALK-VAR
                (IF (CONSP LAMBDA-LIST)
                    (CDR LAMBDA-LIST)
                    LAMBDA-LIST))))
          (AUGMENT-ENV VAR)
          (PUSH '&REST NEW-LAMBDA-LIST)
          (PUSH VAR NEW-LAMBDA-LIST))
        (SETQ LAMBDA-LIST NIL)))))
(DEFTYPE CLASS-SPECIALIZER () '(CONS SYMBOL (CONS SYMBOL NULL)))
(DEFTYPE COMPOUND-SPECIALIZER (&OPTIONAL (OPERATOR (QUOTE EQL)))
  `(CONS SYMBOL (CONS (CONS (EQL ,OPERATOR) *) NULL)))
(DEFUN WALK-SPECIALIZED-LAMBDA-LIST (WALKER LAMBDA-LIST DECLS ENV)
  (LET ((REQ-PARAMS
         (FLET ((AUGMENT-ENV (VAR)
                  (SETQ ENV
                          (AUGMENT-WALKER-ENVIRONMENT WALKER ENV :VARIABLE
                                                      (LIST VAR) :DECLARE
                                                      DECLS)))
                (WALK-VAR (SPEC)
                  (ETYPECASE SPEC
                    (SYMBOL (WALK-ATOMIC-FORM WALKER :BINDING SPEC ENV))
                    (CLASS-SPECIALIZER
                     (LIST (WALK-ATOMIC-FORM WALKER :BINDING (CAR SPEC) ENV)
                           (WALK-ATOMIC-FORM WALKER :CLASS-SPECIALIZER
                                             (CADR SPEC) ENV)))
                    ((COMPOUND-SPECIALIZER EQL)
                     (LIST (WALK-ATOMIC-FORM WALKER :BINDING (CAR SPEC) ENV)
                           `(EQL ,(WALK-FORM WALKER (CADADR SPEC))))))))
           (LOOP UNTIL (OR (NULL LAMBDA-LIST)
                           (MEMBER (CAR LAMBDA-LIST)
                                   LAMBDA-LIST-KEYWORDS)) AS VAR = (WALK-VAR
                                                                    (POP
                                                                     LAMBDA-LIST))
                 DO (AUGMENT-ENV
                     (IF (CONSP VAR)
                         (CAR VAR)
                         VAR))
                 COLLECT VAR))))
    (MULTIPLE-VALUE-BIND (OTHER-PARAMS ENV)
        (WALK-LAMBDA-LIST WALKER LAMBDA-LIST DECLS ENV)
      (VALUES (NCONC REQ-PARAMS OTHER-PARAMS) ENV))))
(DEFUN WALK-LAMBDA-EXPRESSION
       (WALKER FORM ENV
        &REST ARGS
        &AUX (LAMBDA-LIST (CADR FORM)) (BODY (CDDR FORM)))
  (MULTIPLE-VALUE-BIND (FORMS DECLS DOC)
      (PARSE-BODY BODY :WALKER WALKER :ENV ENV :DOC-STRING-ALLOWED T)
    (MULTIPLE-VALUE-BIND (LAMBDA-LIST ENV)
        (WALK-LAMBDA-LIST WALKER LAMBDA-LIST DECLS ENV)
      `(,(APPLY #'WALK-FUNCTION-NAME WALKER (CAR FORM) ENV ARGS) ,LAMBDA-LIST
        ,@(IF DOC
              `(,DOC))
        ,@(IF DECLS
              `((DECLARE ,@DECLS)))
        ,@(WALK-LIST WALKER FORMS ENV)))))
(DEFINE-SPECIAL-FORM-WALKER LAMBDA
    ((WALKER WALKER) FORM ENV)
  (WALK-LAMBDA-EXPRESSION WALKER FORM ENV))
(DEFUN WALK-VARIABLE-BINDING
       (WALKER P ENV
        &AUX
        (BINDING
         (IF (CONSP P)
             P
             (LIST P))))
  (LIST (WALK-ATOMIC-FORM WALKER :BINDING (CAR BINDING) ENV)
        (AND (CDR BINDING) (WALK-FORM WALKER (CADR BINDING) ENV))))
(DEFINE-SPECIAL-FORM-WALKER LET
    ((WALKER WALKER) FORM ENV &AUX
     (BINDINGS
      (MAPCAR (LAMBDA (P) (WALK-VARIABLE-BINDING WALKER P ENV)) (CADR FORM)))
     (BODY (CDDR FORM)))
  (MULTIPLE-VALUE-BIND (FORMS DECLS)
      (PARSE-BODY BODY :WALKER WALKER :ENV ENV)
    `(,(CAR FORM) ,BINDINGS
      ,@(IF DECLS
            `((DECLARE ,@DECLS)))
      ,@(WALK-LIST WALKER FORMS
                   (AUGMENT-WALKER-ENVIRONMENT WALKER ENV :VARIABLE
                                               (MAPCAR #'CAR BINDINGS) :DECLARE
                                               DECLS)))))
(DEFINE-SPECIAL-FORM-WALKER FLET
    ((WALKER WALKER) FORM ENV &AUX
     (BINDINGS
      (MAPCAR
       (LAMBDA (P)
         (WALK-LAMBDA-EXPRESSION WALKER P ENV :OPERATOR 'FLET :LOCAL T :DEF T))
       (CADR FORM)))
     (BODY (CDDR FORM)))
  (MULTIPLE-VALUE-BIND (FORMS DECLS)
      (PARSE-BODY BODY :WALKER WALKER :ENV ENV)
    `(,(CAR FORM) ,BINDINGS
      ,@(IF DECLS
            `((DECLARE ,@DECLS)))
      ,@(WALK-LIST WALKER FORMS
                   (AUGMENT-WALKER-ENVIRONMENT WALKER ENV :FUNCTION
                                               (MAPCAR #'CAR BINDINGS) :DECLARE
                                               DECLS)))))
(DEFUN MAKE-MACRO-DEFINITIONS (WALKER DEFS ENV)
  (MAPCAR
   (LAMBDA
       (DEF
        &AUX
        (NAME (WALK-ATOMIC-FORM WALKER :SYMBOL-MACRO-BINDING (CAR DEF) ENV)))
     (LIST NAME
           (ENCLOSE (PARSE-MACRO NAME (CADR DEF) (CDDR DEF) ENV) ENV WALKER)))
   DEFS))
(DEFINE-SPECIAL-FORM-WALKER MACROLET
    ((WALKER WALKER) FORM ENV &AUX
     (BINDINGS
      (MAPCAR
       (LAMBDA (P)
         (WALK-LAMBDA-EXPRESSION WALKER P ENV :OPERATOR 'MACROLET :LOCAL T :DEF
                                 T))
       (CADR FORM)))
     (BODY (CDDR FORM)))
  (MULTIPLE-VALUE-BIND (FORMS DECLS)
      (PARSE-BODY BODY :WALKER WALKER :ENV ENV)
    `(,(CAR FORM) ,BINDINGS
      ,@(IF DECLS
            `((DECLARE ,@DECLS)))
      ,@(WALK-LIST WALKER FORMS
                   (AUGMENT-WALKER-ENVIRONMENT WALKER ENV :MACRO
                                               (MAKE-MACRO-DEFINITIONS WALKER
                                                                       BINDINGS
                                                                       ENV)
                                               :DECLARE DECLS)))))
(DEFINE-SPECIAL-FORM-WALKER SYMBOL-MACROLET
    ((WALKER WALKER) FORM ENV &AUX
     (BINDINGS
      (MAPCAR (LAMBDA (P) (WALK-VARIABLE-BINDING WALKER P ENV)) (CADR FORM)))
     (BODY (CDDR FORM)))
  (MULTIPLE-VALUE-BIND (FORMS DECLS)
      (PARSE-BODY BODY :WALKER WALKER :ENV ENV)
    `(,(CAR FORM) ,BINDINGS
      ,@(IF DECLS
            `((DECLARE ,@DECLS)))
      ,@(WALK-LIST WALKER FORMS
                   (AUGMENT-WALKER-ENVIRONMENT WALKER ENV :SYMBOL-MACRO
                                               BINDINGS :DECLARE DECLS)))))
(DEFINE-SPECIAL-FORM-WALKER LET*
    ((WALKER WALKER) FORM ENV &AUX (BINDINGS (CADR FORM)) (BODY (CDDR FORM)))
  (MULTIPLE-VALUE-BIND (FORMS DECLS)
      (PARSE-BODY BODY :WALKER WALKER :ENV ENV)
    `(,(CAR FORM)
      ,(MAPCAR
        (LAMBDA
            (P
             &AUX (WALKED-BINDING (WALK-VARIABLE-BINDING WALKER P ENV))
             (VARIABLE (LIST (CAR WALKED-BINDING))))
          (SETQ ENV
                  (AUGMENT-WALKER-ENVIRONMENT WALKER ENV :VARIABLE VARIABLE
                                              :DECLARE DECLS))
          WALKED-BINDING)
        BINDINGS)
      ,@(IF DECLS
            `((DECLARE ,@DECLS)))
      ,@(WALK-LIST WALKER FORMS ENV))))
(DEFINE-SPECIAL-FORM-WALKER LABELS
    ((WALKER WALKER) FORM ENV &AUX (BINDINGS (CADR FORM)) (BODY (CDDR FORM)))
  (MULTIPLE-VALUE-BIND (FORMS DECLS)
      (PARSE-BODY BODY :WALKER WALKER :ENV ENV)
    (LET* ((FUNCTION-NAMES
            (MAPCAR
             (LAMBDA (P)
               (WALK-FUNCTION-NAME WALKER (CAR P) ENV :OPERATOR 'LABELS :LOCAL
                                   T :DEF T))
             BINDINGS))
           (ENV
            (AUGMENT-WALKER-ENVIRONMENT WALKER ENV :FUNCTION FUNCTION-NAMES
                                        :DECLARE DECLS)))
      `(,(CAR FORM)
        ,(MAPCAR (LAMBDA (P) (WALK-LAMBDA-EXPRESSION WALKER P ENV)) BINDINGS)
        ,@(IF DECLS
              `((DECLARE ,@DECLS)))
        ,@(WALK-LIST WALKER FORMS ENV)))))
(DEFINE-SPECIAL-FORM-WALKER LOCALLY
    ((WALKER WALKER) FORM ENV)
  (MULTIPLE-VALUE-BIND (FORMS DECLS)
      (PARSE-BODY (CDR FORM) :WALKER WALKER :ENV ENV)
    `(,(CAR FORM)
      ,@(IF DECLS
            `((DECLARE ,@DECLS)))
      ,@(WALK-LIST WALKER FORMS
                   (AUGMENT-WALKER-ENVIRONMENT WALKER ENV :DECLARE DECLS)))))
(DEFUN INDEX-PACKAGE (PACKAGES &AUX (PACKAGES (ENSURE-LIST PACKAGES)))
  "Inform the weaver that it should index the symbols in PACKAGES."
  (DOLIST (PACKAGE PACKAGES) (PUSHNEW (FIND-PACKAGE PACKAGE) *INDEX-PACKAGES*)))
(DEFGENERIC INTERESTING-SYMBOL-P
    (OBJECT))
(DEFMETHOD INTERESTING-SYMBOL-P (OBJECT) (DECLARE (IGNORE OBJECT)))
(DEFMETHOD INTERESTING-SYMBOL-P ((OBJECT SYMBOL))
  (MEMBER (SYMBOL-PACKAGE OBJECT) *INDEX-PACKAGES*))
(DEFUN JOIN-STRINGS
       (STRINGS
        &OPTIONAL (DELIMITER #\ )
        &AUX (STRINGS (ENSURE-LIST STRINGS)) (DELIMITER (STRING DELIMITER)))
  (WITH-OUTPUT-TO-STRING (OUT)
    (LOOP FOR (STRING . MORE) ON STRINGS
          DO (WRITE-STRING (STRING STRING) OUT)
          WHEN MORE
          DO (WRITE-STRING DELIMITER OUT))))
(DEFINE-METHOD-COMBINATION JOIN-STRINGS (&OPTIONAL (DELIMITER #\ ))
                           ((PREFIX (:PREFIX)) (PRIMARY NIL :REQUIRED T)
                            (SUFFIX (:SUFFIX)))
                           (FLET ((CALL-METHODS (METHODS)
                                    (MAPCAR
                                     (LAMBDA (METHOD)
                                       `(ENSURE-LIST (CALL-METHOD ,METHOD)))
                                     METHODS)))
                             `(JOIN-STRINGS
                               (APPEND ,@(CALL-METHODS PREFIX)
                                       ,@(CALL-METHODS PRIMARY)
                                       ,@(CALL-METHODS (REVERSE SUFFIX)))
                               ,DELIMITER)))
(DEFGENERIC HEADING-NAME
    (HEADING)
  (:METHOD-COMBINATION JOIN-STRINGS))
(DEFCLASS HEADING NIL
          ((NAME :INITARG :NAME :INITFORM "")
           (SUB-HEADING :READER SUB-HEADING :INITARG :SUB-HEADING :INITFORM
                        NIL)))
(DEFCLASS TT-HEADING (HEADING) NIL)
(DEFCLASS CUSTOM-HEADING (HEADING) NIL)
(DEFUN MAKE-HEADING (NAME &OPTIONAL SUB-HEADING)
  (MAKE-INSTANCE 'HEADING :NAME NAME :SUB-HEADING SUB-HEADING))
(DEFMETHOD HEADING-NAME ((HEADING HEADING))
  (STRING-LEFT-TRIM '(#\  #\Tab #\Newline #\\)
                    (STRING-DOWNCASE (SLOT-VALUE HEADING 'NAME))))
(DEFMETHOD HEADING-NAME :SUFFIX ((HEADING HEADING))
  (WHEN (SUB-HEADING HEADING) (HEADING-NAME (SUB-HEADING HEADING))))
(DEFGENERIC ENTRY-HEADING-LESSP
    (H1 H2))
(DEFMETHOD ENTRY-HEADING-LESSP ((H1 NULL) (H2 NULL)) NIL)
(DEFMETHOD ENTRY-HEADING-LESSP ((H1 HEADING) (H2 NULL)) NIL)
(DEFMETHOD ENTRY-HEADING-LESSP ((H1 NULL) (H2 HEADING)) T)
(DEFMETHOD ENTRY-HEADING-LESSP ((H1 HEADING) (H2 HEADING))
  (OR (STRING-LESSP (HEADING-NAME H1) (HEADING-NAME H2))
      (AND (STRING-EQUAL (HEADING-NAME H1) (HEADING-NAME H2))
           (ENTRY-HEADING-LESSP (SUB-HEADING H1) (SUB-HEADING H2)))))
(DEFGENERIC ENTRY-HEADING-EQUALP
    (H1 H2))
(DEFMETHOD ENTRY-HEADING-EQUALP (H1 H2) (DECLARE (IGNORE H1 H2)))
(DEFMETHOD ENTRY-HEADING-EQUALP ((H1 NULL) (H2 NULL)) T)
(DEFMETHOD ENTRY-HEADING-EQUALP ((H1 HEADING) (H2 HEADING))
  (AND (STRING-EQUAL (HEADING-NAME H1) (HEADING-NAME H2))
       (ENTRY-HEADING-EQUALP (SUB-HEADING H1) (SUB-HEADING H2))))
(DEFCLASS TYPE-HEADING (HEADING)
          ((ALLOWABLE-MODIFIERS :READER ALLOWABLE-MODIFIERS :INITARG
                                :ALLOWABLE-MODIFIERS :ALLOCATION :CLASS)
           (MODIFIERS :ACCESSOR HEADING-MODIFIERS :INITARG :MODIFIERS)))
(DEFMETHOD INITIALIZE-INSTANCE :AFTER
           ((HEADING TYPE-HEADING) &REST INITARGS &KEY NAME &ALLOW-OTHER-KEYS)
  (ETYPECASE NAME
    (STRING)
    (SYMBOL (SETF (SLOT-VALUE HEADING 'NAME) (STRING-DOWNCASE NAME))))
  (SETF (HEADING-MODIFIERS HEADING)
          (LOOP WITH ALLOWABLE-MODIFIERS = (ALLOWABLE-MODIFIERS HEADING)
                FOR (NAME VALUE) ON INITARGS BY #'CDDR
                WHEN (AND (MEMBER NAME ALLOWABLE-MODIFIERS) VALUE)
                COLLECT NAME INTO MODIFIERS
                FINALLY (RETURN
                         (SORT MODIFIERS
                               (LAMBDA (X Y)
                                 (< (POSITION X ALLOWABLE-MODIFIERS)
                                    (POSITION Y ALLOWABLE-MODIFIERS))))))))
(DEFMETHOD HEADING-NAME :PREFIX ((HEADING TYPE-HEADING))
  (MAPCAR #'STRING-DOWNCASE (HEADING-MODIFIERS HEADING)))
(EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)
  (DEFUN TYPE-HEADING-CLASS-NAME (NAME)
    (INTERN (WITH-STANDARD-IO-SYNTAX (FORMAT NIL "~A-HEADING" NAME)))))
(DEFMACRO DEFINE-TYPE-HEADING (NAME SLOTS &REST OPTIONS)
  (FLET ((OPTION (INDICATOR)
           (CDR
            (FIND-IF (LAMBDA (OPTION) (EQ (CAR OPTION) INDICATOR)) OPTIONS))))
    `(DEFCLASS ,(TYPE-HEADING-CLASS-NAME NAME) (TYPE-HEADING) ,SLOTS
               (:DEFAULT-INITARGS :NAME ,(OR (CAR (OPTION :NAME)) `',NAME)
                :ALLOWABLE-MODIFIERS ',(OPTION :MODIFIERS)))))
(DEFUN MAKE-TYPE-HEADING (TYPE &REST ARGS)
  (APPLY #'MAKE-INSTANCE (TYPE-HEADING-CLASS-NAME TYPE) ARGS))
(DEFINE-TYPE-HEADING FUNCTION NIL (:MODIFIERS :LOCAL :GENERIC :SETF))
(DEFINE-TYPE-HEADING METHOD
                     ((QUALIFIERS :READER METHOD-HEADING-QUALIFIERS :INITARG
                       :QUALIFIERS :INITFORM NIL))
                     (:MODIFIERS :SETF))
(DEFINE-TYPE-HEADING MACRO NIL (:MODIFIERS :LOCAL))
(DEFINE-TYPE-HEADING SYMBOL-MACRO NIL (:NAME "symbol macro")
                     (:MODIFIERS :LOCAL))
(DEFINE-TYPE-HEADING CLASS NIL)
(DEFINE-TYPE-HEADING CONDITION-CLASS NIL (:NAME "condition class"))
(DEFINE-TYPE-HEADING VARIABLE NIL (:MODIFIERS :SPECIAL :CONSTANT))
(DEFINE-TYPE-HEADING METHOD-COMBINATION NIL (:NAME "method combination"))
(DEFMETHOD HEADING-NAME :PREFIX ((HEADING METHOD-HEADING))
  (MAPCAR #'STRING-DOWNCASE
          (OR (METHOD-HEADING-QUALIFIERS HEADING) '(:PRIMARY))))
(DEFCLASS LOCATOR NIL NIL)
(DEFCLASS SECTION-LOCATOR (LOCATOR)
          ((SECTION :ACCESSOR LOCATION :INITARG :SECTION)
           (DEF :ACCESSOR LOCATOR-DEFINITION-P :INITARG :DEF :INITFORM NIL)))
(DEFCLASS XREF-LOCATOR (LOCATOR)
          ((HEADING :ACCESSOR LOCATION :INITARG :HEADING)))
(DEFCLASS SEE-LOCATOR (XREF-LOCATOR) NIL)
(DEFCLASS SEE-ALSO-LOCATOR (XREF-LOCATOR) NIL)
(DEFUN MAKE-LOCATOR (&KEY SECTION DEF SEE SEE-ALSO)
  (ASSERT
   (IF (OR SEE SEE-ALSO)
       (AND (NOT SECTION) (NOT DEF))
       T)
   (SECTION DEF SEE SEE-ALSO)
   "Can't use :SECTION or :DEF with :SEE or :SEE-ALSO.")
  (ASSERT
   (IF DEF
       SECTION
       T)
   (SECTION DEF) "Can't use :DEF without :SECTION.")
  (ASSERT (NOT (AND SEE SEE-ALSO)) (SEE SEE-ALSO)
          "Can't use both :SEE and :SEE-ALSO.")
  (COND (SECTION (MAKE-INSTANCE 'SECTION-LOCATOR :SECTION SECTION :DEF DEF))
        (SEE (MAKE-INSTANCE 'SEE-LOCATOR :HEADING SEE))
        (SEE-ALSO (MAKE-INSTANCE 'SEE-LOCATOR :HEADING SEE-ALSO))))
(DEFCLASS INDEX-ENTRY (BINARY-SEARCH-TREE)
          ((KEY :ACCESSOR ENTRY-HEADING)
           (LOCATORS :ACCESSOR ENTRY-LOCATORS :INITARG :LOCATORS :INITFORM
            'NIL)))
(DEFMETHOD FIND-OR-INSERT
           (ITEM (ROOT INDEX-ENTRY)
            &KEY (PREDICATE #'ENTRY-HEADING-LESSP)
            (TEST #'ENTRY-HEADING-EQUALP) (INSERT-IF-NOT-FOUND T))
  (CALL-NEXT-METHOD ITEM ROOT :PREDICATE PREDICATE :TEST TEST
   :INSERT-IF-NOT-FOUND INSERT-IF-NOT-FOUND))
(DEFCLASS INDEX NIL ((ENTRIES :ACCESSOR INDEX-ENTRIES :INITFORM NIL)))
(DEFUN MAKE-INDEX () (MAKE-INSTANCE 'INDEX))
(DEFGENERIC ADD-INDEX-ENTRY
    (INDEX HEADING LOCATOR &KEY))
(DEFGENERIC FIND-INDEX-ENTRIES
    (INDEX HEADING))
(DEFINE-MODIFY-MACRO ORF (&REST ARGS) OR)
(DEFMETHOD ADD-INDEX-ENTRY ((INDEX INDEX) HEADING (SECTION SECTION) &KEY DEF)
  (FLET ((MAKE-LOCATOR ()
           (MAKE-LOCATOR :SECTION SECTION :DEF DEF)))
    (IF (NULL (INDEX-ENTRIES INDEX))
        (SETF (INDEX-ENTRIES INDEX)
                (MAKE-INSTANCE 'INDEX-ENTRY :KEY HEADING :LOCATORS
                               (LIST (MAKE-LOCATOR))))
        (LET* ((ENTRY (FIND-OR-INSERT HEADING (INDEX-ENTRIES INDEX)))
               (OLD-LOCATOR
                (FIND SECTION (ENTRY-LOCATORS ENTRY) :KEY #'LOCATION)))
          (IF OLD-LOCATOR
              (ORF (LOCATOR-DEFINITION-P OLD-LOCATOR) DEF)
              (PUSH (MAKE-LOCATOR) (ENTRY-LOCATORS ENTRY)))))))
(DEFMETHOD FIND-INDEX-ENTRIES ((INDEX INDEX) HEADING)
  (LET ((ENTRIES (INDEX-ENTRIES INDEX)))
    (WHEN ENTRIES
      (MULTIPLE-VALUE-BIND (ENTRY PRESENT-P)
          (FIND-OR-INSERT HEADING ENTRIES :INSERT-IF-NOT-FOUND NIL)
        (WHEN PRESENT-P (ENTRY-LOCATORS ENTRY))))))
(DEFUN GENERIC-FUNCTION-P (FUNCTION-NAME)
  (OR (TYPEP FUNCTION-NAME 'GENERIC-FUNCTION)
      (AND (FBOUNDP FUNCTION-NAME)
           (TYPEP (FDEFINITION FUNCTION-NAME) 'GENERIC-FUNCTION))))
(DEFGENERIC INDEX-VARIABLE
    (INDEX VARIABLE ENV SECTION))
(DEFMETHOD INDEX-VARIABLE ((INDEX INDEX) VARIABLE ENV SECTION)
  (MULTIPLE-VALUE-BIND (TYPE LOCAL)
      (VARIABLE-INFORMATION VARIABLE ENV)
    (WHEN
        (OR (MEMBER TYPE '(:SPECIAL :SYMBOL-MACRO :CONSTANT))
            (AND *INDEX-LEXICAL-VARIABLES* (EQL TYPE :LEXICAL)))
      (ADD-INDEX-ENTRY INDEX
                       (MAKE-HEADING VARIABLE
                                     (ECASE TYPE
                                       (:LEXICAL (MAKE-TYPE-HEADING 'VARIABLE))
                                       (:SPECIAL
                                        (MAKE-TYPE-HEADING 'VARIABLE :SPECIAL
                                                           T))
                                       (:CONSTANT
                                        (MAKE-TYPE-HEADING 'VARIABLE :CONSTANT
                                                           T))
                                       (:SYMBOL-MACRO
                                        (MAKE-TYPE-HEADING 'SYMBOL-MACRO :LOCAL
                                                           LOCAL))))
                       SECTION))))
(DEFGENERIC INDEX-FUNCALL
    (INDEX FUNCTION-NAME FORM ENV SECTION))
(DEFMETHOD INDEX-FUNCALL ((INDEX INDEX) FUNCTION-NAME FORM ENV SECTION)
  (DECLARE (IGNORE FORM))
  (MULTIPLE-VALUE-BIND (TYPE LOCAL)
      (FUNCTION-INFORMATION FUNCTION-NAME ENV)
    (WHEN (MEMBER TYPE '(:FUNCTION :MACRO))
      (ADD-INDEX-ENTRY INDEX
                       (MAKE-HEADING FUNCTION-NAME
                                     (ECASE TYPE
                                       (:FUNCTION
                                        (MAKE-TYPE-HEADING 'FUNCTION :LOCAL
                                                           LOCAL :GENERIC
                                                           (GENERIC-FUNCTION-P
                                                            FUNCTION-NAME)))
                                       (:MACRO
                                        (MAKE-TYPE-HEADING 'MACRO :LOCAL
                                                           LOCAL))))
                       SECTION))))
(DEFGENERIC INDEX-DEFUN
    (INDEX FUNCTION-NAME SECTION &KEY))
(DEFMETHOD INDEX-DEFUN
           ((INDEX INDEX) FUNCTION-NAME SECTION
            &KEY OPERATOR LOCAL GENERIC QUALIFIERS)
  (ADD-INDEX-ENTRY INDEX
                   (MAKE-HEADING
                    (ETYPECASE FUNCTION-NAME
                      (SYMBOL FUNCTION-NAME)
                      (SETF-FUNCTION-NAME (CADR FUNCTION-NAME)))
                    (MAKE-TYPE-HEADING
                     (CASE OPERATOR
                       ((DEFMACRO MACROLET) 'MACRO)
                       ((DEFINE-SYMBOL-MACRO SYMBOL-MACROLET) 'SYMBOL-MACRO)
                       ((DEFMETHOD)
                        (ETYPECASE FUNCTION-NAME
                          (SYMBOL
                           (IF QUALIFIERS
                               'METHOD
                               'FUNCTION))
                          (SETF-FUNCTION-NAME 'METHOD)))
                       (OTHERWISE 'FUNCTION))
                     :SETF (SETF-FUNCTION-NAME-P FUNCTION-NAME) :LOCAL LOCAL
                     :GENERIC (OR GENERIC (GENERIC-FUNCTION-P FUNCTION-NAME))
                     :QUALIFIERS QUALIFIERS))
                   SECTION :DEF T))
(DEFGENERIC INDEX-SYMBOL
    (INDEX CONTEXT SYMBOL ENV &KEY SECTION DEF))
(DEFMETHOD INDEX-SYMBOL (INDEX CONTEXT SYMBOL ENV &KEY SECTION DEF)
  (DECLARE (IGNORE CONTEXT DEF))
  (INDEX-VARIABLE INDEX SYMBOL ENV SECTION))
(DEFMACRO DEFINE-SYMBOL-INDEXER (CONTEXT TYPE &REST ARGS)
  `(DEFMETHOD INDEX-SYMBOL :AFTER
              (INDEX (CONTEXT (EQL ,CONTEXT)) SYMBOL ENV &KEY SECTION DEF)
     (DECLARE (IGNORE ENV))
     (ADD-INDEX-ENTRY INDEX
                      (MAKE-HEADING SYMBOL (MAKE-TYPE-HEADING ,TYPE ,@ARGS))
                      SECTION :DEF DEF)))
(DEFMETHOD INDEX-SYMBOL :AFTER
           (INDEX (CONTEXT (EQL :BINDING)) SYMBOL ENV &KEY SECTION DEF)
  (DECLARE (IGNORE ENV))
  (WHEN *INDEX-LEXICAL-VARIABLES*
    (ADD-INDEX-ENTRY INDEX (MAKE-HEADING SYMBOL (MAKE-TYPE-HEADING 'VARIABLE))
                     SECTION :DEF DEF)))
(DEFUN SUBSTITUTE-SYMBOLS (FORM SECTION &AUX SYMBOLS)
  (LABELS ((GET-SYMBOLS (FORM)
             (COND ((INTERESTING-SYMBOL-P FORM) (PUSHNEW FORM SYMBOLS))
                   ((ATOM FORM) NIL)
                   (T (GET-SYMBOLS (CAR FORM)) (GET-SYMBOLS (CDR FORM))))))
    (GET-SYMBOLS FORM)
    (SUBLIS
     (MAP 'LIST
          (LAMBDA (SYM)
            (LET ((REFSYM (COPY-SYMBOL SYM)))
              (SETF (SYMBOL-VALUE REFSYM) SYM)
              (SETF (GET REFSYM 'SECTION) SECTION)
              (CONS SYM REFSYM)))
          SYMBOLS)
     FORM)))
(DEFUN SYMBOL-PROVENANCE (SYMBOL)
  (LET ((SECTION (GET SYMBOL 'SECTION)))
    (IF (AND (NULL (SYMBOL-PACKAGE SYMBOL)) (BOUNDP SYMBOL) SECTION)
        (VALUES (SYMBOL-VALUE SYMBOL) SECTION)
        SYMBOL)))
(DEFMETHOD SECTION-CODE :AROUND ((SECTION SECTION))
  (LET ((CODE (CALL-NEXT-METHOD)))
    (IF *INDEXING*
        (SUBSTITUTE-SYMBOLS (TANGLE CODE :EXPAND-NAMED-SECTIONS NIL) SECTION)
        CODE)))
(DEFUN TANGLE-CODE-FOR-INDEXING (SECTIONS)
  (LET ((*INDEXING* T))
    (TANGLE (UNNAMED-SECTION-CODE-PARTS SECTIONS))))
(DEFCLASS INDEXING-WALKER (WALKER)
          ((INDEX :ACCESSOR WALKER-INDEX :INITARG :INDEX :INITFORM
            (MAKE-INDEX))))
(DEFMETHOD MACROEXPAND-FOR-WALK ((WALKER INDEXING-WALKER) FORM ENV)
  (TYPECASE FORM
    (SYMBOL
     (MULTIPLE-VALUE-BIND (SYMBOL SECTION)
         (SYMBOL-PROVENANCE FORM)
       (COND
        (SECTION
         (CASE (VARIABLE-INFORMATION SYMBOL ENV)
           (:SYMBOL-MACRO
            (INDEX-VARIABLE (WALKER-INDEX WALKER) SYMBOL ENV SECTION)
            (CALL-NEXT-METHOD WALKER (CONS SYMBOL (CDR FORM)) ENV))
           (T FORM)))
        (T (CALL-NEXT-METHOD)))))
    (CONS
     (MULTIPLE-VALUE-BIND (SYMBOL SECTION)
         (SYMBOL-PROVENANCE (CAR FORM))
       (COND
        (SECTION
         (CASE (FUNCTION-INFORMATION SYMBOL ENV)
           (:MACRO
            (INDEX-FUNCALL (WALKER-INDEX WALKER) SYMBOL FORM ENV SECTION)
            (CALL-NEXT-METHOD WALKER (CONS SYMBOL (CDR FORM)) ENV))
           (T FORM)))
        (T (CALL-NEXT-METHOD)))))
    (T FORM)))
(DEFMETHOD WALK-ATOMIC-FORM :AROUND
           ((WALKER INDEXING-WALKER) CONTEXT FORM ENV &KEY DEF)
  (IF (SYMBOLP FORM)
      (MULTIPLE-VALUE-BIND (SYMBOL SECTION)
          (SYMBOL-PROVENANCE FORM)
        (WHEN SECTION
          (INDEX-SYMBOL (WALKER-INDEX WALKER) CONTEXT SYMBOL ENV :SECTION
                        SECTION :DEF DEF))
        (CALL-NEXT-METHOD WALKER CONTEXT SYMBOL ENV))
      (CALL-NEXT-METHOD WALKER CONTEXT FORM ENV)))
(DEFMETHOD WALK-COMPOUND-FORM :BEFORE
           ((WALKER INDEXING-WALKER) OPERATOR FORM ENV)
  (MULTIPLE-VALUE-BIND (SYMBOL SECTION)
      (SYMBOL-PROVENANCE OPERATOR)
    (WHEN SECTION
      (INDEX-FUNCALL (WALKER-INDEX WALKER) SYMBOL FORM ENV SECTION))))
(DEFMETHOD WALK-FUNCTION-NAME :BEFORE
           ((WALKER INDEXING-WALKER) FUNCTION-NAME ENV &REST ARGS &KEY DEF)
  (LET ((INDEX (WALKER-INDEX WALKER)))
    (TYPECASE FUNCTION-NAME
      (SYMBOL
       (MULTIPLE-VALUE-BIND (SYMBOL SECTION)
           (SYMBOL-PROVENANCE FUNCTION-NAME)
         (WHEN SECTION
           (IF DEF
               (APPLY #'INDEX-DEFUN INDEX SYMBOL SECTION :ALLOW-OTHER-KEYS T
                      ARGS)
               (INDEX-FUNCALL INDEX SYMBOL NIL ENV SECTION)))))
      (SETF-FUNCTION-NAME
       (MULTIPLE-VALUE-BIND (SYMBOL SECTION)
           (SYMBOL-PROVENANCE (CADR FUNCTION-NAME))
         (WHEN SECTION
           (IF DEF
               (APPLY #'INDEX-DEFUN INDEX `(SETF ,SYMBOL) SECTION
                      :ALLOW-OTHER-KEYS T ARGS)
               (INDEX-FUNCALL INDEX SYMBOL NIL ENV SECTION))))))))
(MACROLET ((DEFINE-DEFUN-LIKE-WALKER (OPERATOR)
             `(DEFINE-SPECIAL-FORM-WALKER ,OPERATOR
                  ((WALKER INDEXING-WALKER) FORM ENV)
                `(,(CAR FORM)
                  ,@(WALK-LAMBDA-EXPRESSION WALKER (CDR FORM) ENV :OPERATOR
                                            (CAR FORM) :DEF T)))))
  (DEFINE-DEFUN-LIKE-WALKER DEFUN)
  (DEFINE-DEFUN-LIKE-WALKER DEFMACRO))
(MACROLET ((DEFINE-INDEXING-DEFVAR-WALKER (OPERATOR TYPE)
             `(DEFINE-SPECIAL-FORM-WALKER ,OPERATOR
                  ((WALKER INDEXING-WALKER) FORM ENV)
                `(,(CAR FORM)
                  ,(WALK-ATOMIC-FORM WALKER ,TYPE (CADR FORM) ENV :DEF T)
                  ,@(WALK-LIST WALKER (CDDR FORM) ENV)))))
  (DEFINE-INDEXING-DEFVAR-WALKER DEFVAR :SPECIAL-BINDING)
  (DEFINE-INDEXING-DEFVAR-WALKER DEFPARAMETER :SPECIAL-BINDING)
  (DEFINE-INDEXING-DEFVAR-WALKER DEFCONSTANT :CONSTANT-BINDING))
(DEFINE-SYMBOL-INDEXER :SPECIAL-BINDING 'VARIABLE :SPECIAL T)
(DEFINE-SYMBOL-INDEXER :CONSTANT-BINDING 'VARIABLE :CONSTANT T)
(DEFMETHOD WALK-DECLARATION-SPECIFIERS ((WALKER INDEXING-WALKER) DECLS ENV)
  (LOOP FOR (IDENTIFIER . DATA) IN DECLS
        IF (EQL IDENTIFIER 'SPECIAL)
        COLLECT `(SPECIAL ,@(WALK-LIST WALKER DATA ENV)) ELSE
        IF (EQL IDENTIFIER 'OPTIMIZE)
        COLLECT `(OPTIMIZE ,@DATA)))
(DEFMACRO POP-QUALIFIERS (PLACE)
  `(LOOP UNTIL (LISTP (CAR ,PLACE))
         COLLECT (POP ,PLACE)))
(DEFINE-SPECIAL-FORM-WALKER DEFGENERIC
    ((WALKER INDEXING-WALKER) FORM ENV)
  (DESTRUCTURING-BIND
      (OPERATOR FUNCTION-NAME LAMBDA-LIST &REST OPTIONS)
      FORM
    `(,OPERATOR
      ,(WALK-FUNCTION-NAME WALKER FUNCTION-NAME ENV :OPERATOR 'DEFGENERIC
                           :GENERIC T :DEF T)
      ,(WALK-LAMBDA-LIST WALKER LAMBDA-LIST NIL ENV)
      ,@(LOOP FOR FORM IN OPTIONS
              COLLECT (CASE (CAR FORM)
                        (:METHOD-COMBINATION
                         `(,(CAR FORM)
                           ,(WALK-ATOMIC-FORM WALKER :METHOD-COMBINATION
                                              (CADR FORM) ENV)
                           ,@(WALK-LIST WALKER (CDDR FORM) ENV)))
                        (:METHOD
                         (LET* ((OPERATOR (POP FORM))
                                (QUALIFIERS
                                 (MAPCAR
                                  (LAMBDA (Q)
                                    (WALK-ATOMIC-FORM WALKER :METHOD-QUALIFIER
                                                      Q ENV))
                                  (POP-QUALIFIERS FORM)))
                                (LAMBDA-LIST (POP FORM))
                                (BODY FORM))
                           (WALK-FUNCTION-NAME WALKER FUNCTION-NAME ENV
                                               :OPERATOR 'DEFMETHOD :GENERIC T
                                               :QUALIFIERS QUALIFIERS :DEF T)
                           (WALK-METHOD-DEFINITION WALKER OPERATOR NIL
                                                   QUALIFIERS LAMBDA-LIST BODY
                                                   ENV)))
                        (T (WALK-LIST WALKER FORM ENV)))))))
(DEFUN WALK-METHOD-DEFINITION
       (WALKER OPERATOR FUNCTION-NAME QUALIFIERS LAMBDA-LIST BODY ENV)
  (MULTIPLE-VALUE-BIND (BODY-FORMS DECLS DOC)
      (PARSE-BODY BODY :WALKER WALKER :ENV ENV)
    (MULTIPLE-VALUE-BIND (LAMBDA-LIST ENV)
        (WALK-SPECIALIZED-LAMBDA-LIST WALKER LAMBDA-LIST DECLS ENV)
      `(,OPERATOR ,@(WHEN FUNCTION-NAME `(,FUNCTION-NAME)) ,@QUALIFIERS
        ,LAMBDA-LIST
        ,@(IF DOC
              `(,DOC))
        ,@(IF DECLS
              `((DECLARE ,@DECLS)))
        ,@(WALK-LIST WALKER BODY-FORMS ENV)))))
(DEFINE-SPECIAL-FORM-WALKER DEFMETHOD
    ((WALKER INDEXING-WALKER) FORM ENV &AUX (OPERATOR (POP FORM))
     (FUNCTION-NAME (POP FORM))
     (QUALIFIERS
      (MAPCAR (LAMBDA (Q) (WALK-ATOMIC-FORM WALKER :METHOD-QUALIFIER Q ENV))
              (POP-QUALIFIERS FORM)))
     (LAMBDA-LIST (POP FORM)) (BODY FORM))
  (WALK-METHOD-DEFINITION WALKER OPERATOR
                          (WALK-FUNCTION-NAME WALKER FUNCTION-NAME ENV
                                              :OPERATOR 'DEFMETHOD :GENERIC T
                                              :QUALIFIERS QUALIFIERS :DEF T)
                          QUALIFIERS LAMBDA-LIST BODY ENV))
(MACROLET ((DEFINE-DEFCLASS-WALKER (OPERATOR TYPE)
             `(DEFINE-SPECIAL-FORM-WALKER ,OPERATOR
                  ((WALKER INDEXING-WALKER) FORM ENV)
                (DESTRUCTURING-BIND
                    (OPERATOR NAME SUPERS SLOT-SPECS &REST OPTIONS)
                    FORM
                  `(,OPERATOR ,(WALK-ATOMIC-FORM WALKER ,TYPE NAME ENV :DEF T)
                    ,(MAPCAR
                      (LAMBDA (SUPER)
                        (WALK-ATOMIC-FORM WALKER ,TYPE SUPER ENV))
                      SUPERS)
                    ,(MAPCAR
                      (LAMBDA (SPEC) (WALK-SLOT-SPECIFIER WALKER SPEC ENV))
                      SLOT-SPECS)
                    ,@(WALK-LIST WALKER OPTIONS ENV))))))
  (DEFINE-DEFCLASS-WALKER DEFCLASS :CLASS)
  (DEFINE-DEFCLASS-WALKER DEFINE-CONDITION :CONDITION-CLASS))
(DEFINE-SYMBOL-INDEXER :CLASS 'CLASS)
(DEFINE-SYMBOL-INDEXER :CONDITION-CLASS 'CONDITION-CLASS)
(DEFUN WALK-SLOT-SPECIFIER (WALKER SPEC ENV)
  (ETYPECASE SPEC
    (SYMBOL (WALK-ATOMIC-FORM WALKER :SLOT-NAME SPEC ENV))
    (CONS
     (DESTRUCTURING-BIND
         (NAME &REST OPTIONS)
         SPEC
       (LOOP FOR (OPT-NAME OPT-VALUE) ON OPTIONS BY #'CDDR
             IF (MEMBER OPT-NAME '(:READER :WRITER :ACCESSOR))
             DO (MULTIPLE-VALUE-BIND (SYMBOL SECTION)
                    (SYMBOL-PROVENANCE OPT-VALUE)
                  (WHEN SECTION
                    (INDEX-DEFUN (WALKER-INDEX WALKER) SYMBOL SECTION :OPERATOR
                                 'DEFMETHOD :GENERIC T)
                    (WHEN (EQL OPT-NAME :ACCESSOR)
                      (INDEX-DEFUN (WALKER-INDEX WALKER) `(SETF ,SYMBOL)
                                   SECTION :OPERATOR 'DEFMETHOD :GENERIC T)))))
       `(,(WALK-ATOMIC-FORM WALKER :SLOT-NAME NAME ENV)
         ,@(WALK-LIST WALKER OPTIONS ENV))))))
(DEFINE-SPECIAL-FORM-WALKER DEFINE-METHOD-COMBINATION
    ((WALKER INDEXING-WALKER) FORM ENV)
  `(,(CAR FORM)
    ,(WALK-ATOMIC-FORM WALKER :METHOD-COMBINATION (CADR FORM) ENV :DEF T)
    ,@(WALK-LIST WALKER (CDDR FORM) ENV)))
(DEFINE-SYMBOL-INDEXER :METHOD-COMBINATION 'METHOD-COMBINATION)
(DEFUN INDEX-SECTIONS
       (SECTIONS
        &KEY (INDEX *INDEX*)
        (WALKER (MAKE-INSTANCE 'INDEXING-WALKER :INDEX INDEX)))
  (LET ((*EVALUATING* T))
    (INDEX-PACKAGE *PACKAGE*)
    (DOLIST (FORM (TANGLE-CODE-FOR-INDEXING SECTIONS) (WALKER-INDEX WALKER))
      (WALK-FORM WALKER FORM))))
(DEFCLASS SECTION-RANGE NIL
          ((START :READER START-SECTION :INITARG :START)
           (END :READER END-SECTION :INITARG :END)))
(DEFUN COALESCE-LOCATORS (LOCATORS)
  (FLET ((MAYBE-MAKE-SECTION-RANGE (START END)
           (COND ((EQL START END) START)
                 ((AND START END)
                  (MAKE-INSTANCE 'SECTION-RANGE :START (LOCATION START) :END
                                 (LOCATION END))))))
    (DO* ((LOCATORS LOCATORS (CDR LOCATORS))
          (LOC (CAR LOCATORS) (CAR LOCATORS))
          (COALESCED-LOCATORS 'NIL)
          START
          END)
         ((ENDP LOCATORS)
          (NRECONC COALESCED-LOCATORS
                   (ENSURE-LIST (MAYBE-MAKE-SECTION-RANGE START END))))
      (FLET ((MAYBE-PUSH-RANGE (START END)
               (LET ((RANGE (MAYBE-MAKE-SECTION-RANGE START END)))
                 (WHEN RANGE (PUSH RANGE COALESCED-LOCATORS)))))
        (COND
         ((LOCATOR-DEFINITION-P LOC) (MAYBE-PUSH-RANGE START END)
          (PUSH LOC COALESCED-LOCATORS)
          (SETQ START NIL
                END NIL))
         ((AND END
               (= (SECTION-NUMBER (LOCATION LOC))
                  (1+ (SECTION-NUMBER (LOCATION END)))))
          (SETQ END LOC))
         (T (MAYBE-PUSH-RANGE START END)
          (SETQ START LOC
                END START)))))))
(SET-WEAVE-DISPATCH 'INDEX
                    (LAMBDA (STREAM INDEX)
                      (MAP-BST (LAMBDA (ENTRY) (WRITE ENTRY :STREAM STREAM))
                               (INDEX-ENTRIES INDEX))))
(SET-WEAVE-DISPATCH 'INDEX-ENTRY
                    (LAMBDA (STREAM ENTRY)
                      (FORMAT STREAM
                              "\\I~/clweb::print-entry-heading/~{, ~W~}.~%"
                              (ENTRY-HEADING ENTRY)
                              (COALESCE-LOCATORS
                               (SORT (COPY-LIST (ENTRY-LOCATORS ENTRY)) #'<
                                     :KEY
                                     (LAMBDA (LOC)
                                       (SECTION-NUMBER (LOCATION LOC))))))))
(SET-WEAVE-DISPATCH 'SECTION-RANGE
                    (LAMBDA (STREAM RANGE)
                      (FORMAT STREAM "\\hbox{~D--~D}"
                              (SECTION-NUMBER (START-SECTION RANGE))
                              (SECTION-NUMBER (END-SECTION RANGE)))))
(SET-WEAVE-DISPATCH 'SECTION-LOCATOR
                    (LAMBDA (STREAM LOC)
                      (FORMAT STREAM "~:[~D~;\\[~D]~]"
                              (LOCATOR-DEFINITION-P LOC)
                              (SECTION-NUMBER (LOCATION LOC)))))
(DEFGENERIC PRINT-ENTRY-HEADING
    (STREAM HEADING &REST ARGS))
(DEFMETHOD PRINT-ENTRY-HEADING (STREAM (HEADING TYPE-HEADING) &REST ARGS)
  (DECLARE (IGNORE ARGS))
  (WRITE-STRING (HEADING-NAME HEADING) STREAM))
(DEFMETHOD PRINT-ENTRY-HEADING (STREAM (HEADING HEADING) &REST ARGS)
  (DECLARE (IGNORE ARGS))
  (WITH-SLOTS (NAME)
      HEADING
    (ETYPECASE NAME
      (SYMBOL (FORMAT STREAM "\\(~W\\)" NAME))
      (CHARACTER (PRINT-CHAR STREAM NAME))
      (STRING
       (FORMAT STREAM "~[\\.~;\\9~]{~/clweb::print-TeX/}"
               (TYPECASE HEADING
                 (TT-HEADING 0)
                 (CUSTOM-HEADING 1)
                 (OTHERWISE -1))
               (READ-TEX-FROM-STRING NAME)))))
  (WHEN (SUB-HEADING HEADING)
    (WRITE-CHAR #\  STREAM)
    (PRINT-ENTRY-HEADING STREAM (SUB-HEADING HEADING))))
(DEFCLASS MACRO-CHAR-HEADING (HEADING)
          ((NAME :READER MACRO-CHAR :INITARG :CHAR))
          (:DEFAULT-INITARGS :SUB-HEADING (MAKE-HEADING "macro character")))
(DEFUN MAKE-MACRO-CHAR-HEADING (CHAR &OPTIONAL SUB-CHAR)
  (APPLY #'MAKE-INSTANCE 'MACRO-CHAR-HEADING :CHAR CHAR
         (AND SUB-CHAR `(:SUB-HEADING ,(MAKE-MACRO-CHAR-HEADING SUB-CHAR)))))
(DEFUN DISPATCHING-MACRO-CHAR-HEADING (HEADING)
  (TYPEP (SUB-HEADING HEADING) 'MACRO-CHAR-HEADING))
(DEFMETHOD ENTRY-HEADING-LESSP ((H1 MACRO-CHAR-HEADING) (H2 HEADING)) T)
(DEFMETHOD ENTRY-HEADING-LESSP ((H1 HEADING) (H2 MACRO-CHAR-HEADING)) NIL)
(DEFMETHOD ENTRY-HEADING-LESSP
           ((H1 MACRO-CHAR-HEADING) (H2 MACRO-CHAR-HEADING))
  (COND
   ((AND (NOT (DISPATCHING-MACRO-CHAR-HEADING H1))
         (DISPATCHING-MACRO-CHAR-HEADING H2))
    T)
   ((AND (DISPATCHING-MACRO-CHAR-HEADING H1)
         (NOT (DISPATCHING-MACRO-CHAR-HEADING H2)))
    NIL)
   (T
    (OR (CHAR-LESSP (MACRO-CHAR H1) (MACRO-CHAR H2))
        (AND (DISPATCHING-MACRO-CHAR-HEADING H1)
             (DISPATCHING-MACRO-CHAR-HEADING H2)
             (ENTRY-HEADING-LESSP (SUB-HEADING H1) (SUB-HEADING H2)))))))
(DEFMETHOD ENTRY-HEADING-EQUALP ((H1 MACRO-CHAR-HEADING) (H2 HEADING)) NIL)
(DEFMETHOD ENTRY-HEADING-EQUALP ((H1 HEADING) (H2 MACRO-CHAR-HEADING)) NIL)
(DEFMETHOD ENTRY-HEADING-EQUALP
           ((H1 MACRO-CHAR-HEADING) (H2 MACRO-CHAR-HEADING))
  (AND (CHAR= (MACRO-CHAR H1) (MACRO-CHAR H2))
       (COND
        ((AND (DISPATCHING-MACRO-CHAR-HEADING H1)
              (DISPATCHING-MACRO-CHAR-HEADING H2))
         (ENTRY-HEADING-EQUALP (SUB-HEADING H1) (SUB-HEADING H2)))
        ((OR (DISPATCHING-MACRO-CHAR-HEADING H1)
             (DISPATCHING-MACRO-CHAR-HEADING H2))
         NIL)
        (T T))))
(DEFMETHOD INTERESTING-SYMBOL-P ((OBJECT (EQL (QUOTE SET-MACRO-CHARACTER)))) T)
(DEFMETHOD INTERESTING-SYMBOL-P
           ((OBJECT (EQL (QUOTE SET-DISPATCH-MACRO-CHARACTER))))
  T)
(DEFMETHOD INDEX-FUNCALL
           ((INDEX INDEX) (FUNCTION-NAME (EQL (QUOTE SET-MACRO-CHARACTER)))
            FORM ENV SECTION)
  (DECLARE (IGNORE ENV))
  (WHEN (CHARACTERP (SECOND FORM))
    (ADD-INDEX-ENTRY INDEX (MAKE-MACRO-CHAR-HEADING (SECOND FORM)) SECTION :DEF
                     T)))
(DEFMETHOD INDEX-FUNCALL
           ((INDEX INDEX)
            (FUNCTION-NAME (EQL (QUOTE SET-DISPATCH-MACRO-CHARACTER))) FORM ENV
            SECTION)
  (DECLARE (IGNORE ENV))
  (WHEN (CHARACTERP (SECOND FORM))
    (ADD-INDEX-ENTRY INDEX
                     (MAKE-MACRO-CHAR-HEADING (SECOND FORM)
                                              (AND (CHARACTERP (THIRD FORM))
                                                   (THIRD FORM)))
                     SECTION :DEF T)))