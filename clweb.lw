% CLWEB is a literate programming system for Common Lisp.
% It was inspired by CWEB by Silvio Levy and Donald E. Knuth, which was
% based on Knuth's original WEB system.

\def\pb{\.{|...|}} % program brackets
\def\v{\.{\char'174}} % vertical bar in typewriter font

@*Introduction. The two primary operations that a literate programming
system makes available are {\it tangling\/} and {\/weaving\/}. The former
creates a machine-readable output file from a \WEB, while the latter prepares
the \WEB\ for formatting using \TeX\ or some other formatting engine.

There are three interface functions defined by this system: |tangle-file|,
|load-web|, and |weave|. The first is analogous to |compile-file|: given
an input file containing \WEB\ source, it produces a compiled output file
that can subsequently be loaded into a Lisp image with |load|. The function
|load-web| is analogous to |load|, but again accepts \WEB\ as input
instead of ordinary Lisp source. And finally, |weave| takes a \WEB\ as
input and generates a \TeX\ source file containing the commentary parts
of each section together with pretty-printed code parts.

@ @e
(defpackage "COMMON-LISP-WEB"
  (:nicknames "CLWEB")
  (:use "COMMON-LISP")
  (:export "TANGLE-FILE" "LOAD-WEB" "LOAD-SECTIONS-FROM-TEMP-FILE" "WEAVE"))
(in-package "CLWEB")

@*Sections. The fundamental unit of a \WEB\ is the {\it section}, which
consists essentially of two parts, either of which may be null: a commentary
part and a code part. Every section is automatically assigned a number, and
each section is either {\it named\/} or {\it unnamed\/}. The code parts of
named sections may be included in those of another (named or unnamed)
section via \.{@@<$ldots$@@>} commands, while unnamed sections are output
or evaluated in the order in which they appear in the \WEB\ source file.

@l
(defclass section ()
  ((number :accessor section-number)
   (commentary :accessor section-commentary :initarg :commentary)
   (name :accessor section-name :initarg :name)
   (code :accessor section-code :initarg :code)
   (used-by :accessor used-by :initarg :used-by))
  (:default-initargs :commentary nil :name nil :code nil :used-by nil))

(defclass limbo-section (section) ())

(defclass starred-section (section) ())

@ Whenever a section is created, we store it in the global |*sections*|
vector and set its number to its index therein. This is only used during
weaving, but it doesn't cost much even during tangling, since the section
instances themselves are around in any case.

@l
(defvar *sections* (make-array 128
                               :element-type 'section
                               :adjustable t
                               :fill-pointer 0))

(defun current-section ()
  (elt *sections* (1- (fill-pointer *sections*))))

(defmethod initialize-instance :after ((section section) &rest initargs &key)
  (declare (ignore initargs))
  (setf (section-number section) (vector-push-extend section *sections*)))

@ @<Initialize global variables@>=
(setf (fill-pointer *sections*) 0)

@ Named sections are stored in a binary search tree whose keys are the
section names and whose values are the code to be substituted in place of
a reference to the section so named. The reason for using a tree instead
of, say, a hash table is so that we can support abbreviations (see below).

@l
(defclass binary-search-tree ()
  ((key :accessor node-key :initarg :key)
   (value :accessor node-value :initarg :value)
   (left-child :accessor left-child :initarg :left)
   (right-child :accessor right-child :initarg :right))
  (:default-initargs :left nil :right nil))

@ The primary interface to the {\sc BST} is the following routine, which
attempts to locate the node with key |item| in the tree rooted at |root|.
If it is not already present and the |:insert-if-not-found| argument
is true, a new node is created with that key and added to the tree. The
arguments |predicate| and |test| should be designators for functions
of two arguments, both of which will be node keys. |predicate| should
return true iff its first argument precedes its second in the total
ordering used for the tree, and |test| should return true iff the two
keys are to be considered equivalent.

Two values are returned: the node with key |item| (or |nil| if no such node
was found and |:insert-if-not-found| is false), and a boolean representing
whether the key was already in the tree or not.

@l
(defgeneric find-or-insert (item root &key predicate test insert-if-not-found))

(defmethod find-or-insert (item (root binary-search-tree) &key
                           (predicate #'<) (test #'eql)
                           (insert-if-not-found t))
  (flet ((lessp (item node) (funcall predicate item (node-key node)))
         (samep (item node) (funcall test item (node-key node))))
    (do ((parent nil node)
         (node root (if (lessp item node)
                        (left-child node)
                        (right-child node))))
        ((or (null node) (samep item node))
         (if node
             (values node t)
             (if insert-if-not-found
                 @<Insert a new node with key |item| and return it@>
                 (values nil nil)))))))

@ @<Insert a new node...@>=
(let ((node (make-instance (class-of root) :key item)))
  (when parent
    (if (lessp item parent)
        (setf (left-child parent) node)
        (setf (right-child parent) node)))
  (values node nil))

@ It's important to keep in mind that named sections can be defined
piecemeal, with the code spread out over several physical sections. We
might think of a full named section as a sort of `virtual' section, which
consists of a name, the combined code parts of all of the physical sections
with that name, and the number of the first such section.

And that's what we store in the {\sc BST}: nodes that look like sections,
inasmuch as they have specialized |section-name|, |section-code|, and
|section-number| methods, but are not actually instances of the class
|section|.

@l
(defclass named-section (binary-search-tree)
  ((key :accessor section-name :initarg :name)
   (value :accessor section-code :initarg :code)
   (number :accessor section-number)
   (used-by :accessor used-by :initform '())
   (see-also :accessor see-also :initform '())))

@ Setting the code for a named section usually involves appending the given
forms to whatever forms were already defined for that section, which allows
piecemeal definition. However, sometimes we want to override that behavior
and have the new forms replace the old, such as during interactive
development.

@l
(defun set-named-section-code (section forms &optional (append-p t))
  (setf (section-code section)
        (if (and append-p (slot-boundp section 'value))
            (append (section-code section) forms)
            forms)))

@ When we look up a named section, the name used to perform the lookup,
the name for the section in the tree, or both may be an abbreviation of
the full section name. Any prefix of the full name is allowed, followed by
`$\ldots$': e.g., \.{@@<foo...@@>} is an acceptable abbreviation for either
\.{@@<foo bar@@>} or \.{@@<foo baz@@>}. It is a correctable error if a prefix
is ambiguous.

@l
(defmethod find-or-insert (item (root named-section) &key
                           (predicate #'section-name-lessp)
                           (test #'section-name-equal)
                           (insert-if-not-found t))
  (multiple-value-bind (node present-p)
      (call-next-method item root
                        :predicate predicate
                        :test test
                        :insert-if-not-found insert-if-not-found)
    (if present-p
        (or @<Check for an ambiguous match, and raise an error in that case@>
            (values node t))
        (values node nil))))

@ @<Check for an ambiguous match...@>=
(dolist (child (list (left-child node) (right-child node)))
  (when child
    (multiple-value-bind (alt present-p)
        (call-next-method item child
                          :predicate predicate
                          :test test
                          :insert-if-not-found nil)
      (when present-p
        (restart-case
            (error "~<Ambiguous prefix <~A>: matches both <~A> and <~A>~:@>"
                   (list item (node-key node) (node-key alt)))
          (use-first-match ()
            :report "Use the first match."
            (return (values node t)))
          (use-alt-match ()
            :report "Use the alternate match."
            (return (values alt t))))))))

@ The named section tree is stored in the global variable |*named-sections*|,
which is reset before each tangling or weaving.

@l
(defvar *named-sections* nil)

@ @<Initialize global variables@>=
(setq *named-sections* nil)

@ The next routine is the primary interface to named sections: it looks up
a section by name, and creates a new one if no such section exists.

@l
(defun find-section (name)
  (if (null *named-sections*)
      (values (setq *named-sections* (make-instance 'named-section :name name))
              nil)
      (multiple-value-bind (section present-p)
          (find-or-insert name *named-sections*)
        (when present-p
          ;; Update the section name in case the new one is better.
          (setf (section-name section) name))
        (values section present-p))))

@ Section names are normalized by |squeeze|, which trims leading and
trailing whitespace, and replaces all runs of one or more whitespace
characters with a single space.

@l
(defparameter *whitespace*
  (coerce '(#\Space #\Tab #\Newline #\Linefeed #\Page #\Return) 'simple-string))

(defun squeeze (string)
  (flet ((whitespace-p (char) (find char *whitespace* :test #'char=)))
    (coerce @<Collect characters of |string|, squeezing whitespace@>
            'simple-string)))

@ @<Collect characters...@>=
(loop with squeezing = nil
      for char across (string-trim *whitespace* string)
      if (not squeezing)
        if (whitespace-p char) do (setq squeezing t) and collect #\Space
        else collect char
      else
        unless (whitespace-p char) do (setq squeezing nil) and collect char)

@ Here's a little utility routine that makes working with section names
easier. Given a name, it returns two values: |t| or~|nil| depending on
whether the name is a prefix or not, and the length of the non-`\.{...}'
segment of the name.

@l
(defun section-name-prefix-p (name)
  (let ((len (length name)))
    (if (string= (subseq name (max (- len 3) 0) len) "...")
        (values t (- len 3))
        (values nil len))))

@ Next we need some special comparison routines for section names that
handle abbreviations.

@l
(defun section-name-equal (name1 name2)
  (multiple-value-bind (prefix-1-p len1) (section-name-prefix-p name1)
    (multiple-value-bind (prefix-2-p len2) (section-name-prefix-p name2)
      (let ((end (min len1 len2)))
        (if (or prefix-1-p prefix-2-p)
            (string-equal name1 name2 :end1 end :end2 end)
            (string-equal name1 name2))))))

(defun section-name-lessp (name1 name2)
  (multiple-value-bind (prefix-1-p len1) (section-name-prefix-p name1)
    (declare (ignore prefix-1-p))
    (multiple-value-bind (prefix-2-p len2) (section-name-prefix-p name2)
      (declare (ignore prefix-2-p))
      (string-lessp name1 name2 :end1 len1 :end2 len2))))

@ We only actually update the name of a section in two cases: if the new
name is not an abbreviation but the old one was, or if they are both
abbreviations, but the new one is shorter. (We only need to compare against
the shortest available prefix, since we detect ambiguous matches.)

@l
(defmethod (setf section-name) :around (new-name (section named-section))
  (multiple-value-bind (new-prefix-p new-len)
      (section-name-prefix-p new-name)
    (multiple-value-bind (old-prefix-p old-len)
        (section-name-prefix-p (section-name section))
      (if (or (and old-prefix-p (not new-prefix-p))
              (and old-prefix-p new-prefix-p (< new-len old-len)))
          (call-next-method)
          new-name))))

@*Reading. We recognize five distinct modes, or contexts, for reading.
Limbo mode is for \TeX\ text that proceeds the first section in a file.
\TeX\ mode is used for reading the commentary that begins a section.
Lisp mode is used for reading the code part of a section, and inner-Lisp
mode is for reading Lisp forms that are embedded within \TeX\ material.
Finally, restricted mode is used for reading material in section names
and a few other places.

Note that we do not support the `middle' part of a section that the
original \WEB\ and \CWEB\ used for macro definitions and the like;
those features are simply unnecessary with Lisp.

@l
(eval-when (:compile-toplevel :load-toplevel :execute)
  (defparameter *modes* '(:limbo :TeX :lisp :inner-lisp :restricted)))
(deftype mode () `(member ,@*modes*))

@ We use seperate readtables for each mode, which are accessed via
|readtable-for-mode|. We add an extra readtable with key |nil| that
stores a virgin copy of the standard readtable.

@l
(defvar *readtables*
  (loop for mode in (append *modes* '(nil))
        collect (cons mode (copy-readtable nil))))

(defun readtable-for-mode (mode)
  (declare (type (or mode null) mode))
  (cdr (assoc mode *readtables*)))

@ The following macro is just a bit of syntactic sugar for executing the
given forms with |*readtable*| bound appropriately for the given mode.

@l
(defmacro with-mode (mode &body body)
  `(let ((*readtable* (readtable-for-mode ,mode)))
     ,@body))

@ We frequently need an object to use as the |eof-value| argument to
|read|. It need not be a symbol; it need not even be an atom.

@l
(eval-when (:compile-toplevel :load-toplevel :execute)
  (defvar *eof* (make-symbol "EOF")))
(defun eof-p (x) (eq x *eof*))
(deftype eof () '(satisfies eof-p)) ; should be |`(eql ,*eof*)|

@ Next, we define a class of objects called {\it markers\/} that denote
objects in source code, but that would ordinarily never be returned by
|read|. Markers may be {\it bound\/} to a value, which will be used in
place of an occurrence of that marker when the containing form is
tangled. They may also be unbound, in which case they are removed from
their containing form.

@l
(defclass marker ()
  ((name :accessor marker-name :initarg :name)
   (value :accessor marker-value :initarg :value))
  (:default-initargs :name nil))

(defgeneric marker-boundp (marker))
(defmethod marker-boundp ((marker marker))
  (slot-boundp marker 'value))

@ This is purely for debugging purposes; later, we'll define define
pretty-printing functions for markers that we use during weaving.

@l
(defmethod print-object ((object marker) stream)
  (let ((name (marker-name object)))
    (if name
        (print-unreadable-object (object stream :type t :identity nil)
          (princ name stream))
        (print-unreadable-object (object stream :type t :identity t)))))

@ We preserve newlines in Lisp code so that we don't have to rely on the
pretty-printer to decide where to break lines. They are represented in
code forms by a unique unbound marker.

@l
(defvar *newline* (make-instance 'marker :name "Newline"))

(set-pprint-dispatch `(eql ,*newline*)
                     (lambda (stream obj)
                       (declare (ignore obj))
                       (terpri stream)))

(set-macro-character #\Newline (constantly *newline*)
                     nil (readtable-for-mode :lisp))

@ Comments in Lisp code also need to be preserved for output during
weaving. We use a derived marker class with a special slot for storing the
text of the comment, so that they can remain unbound, and thus be stripped
during tangling.

@l
(defclass comment-marker (marker)
  ((text :reader comment-text :initarg :text)))

(defmethod print-object ((object comment-marker) stream)
  (print-unreadable-object (object stream :type t :identity nil)
    (prin1 (comment-text object) stream)))

(set-pprint-dispatch 'comment-marker
                     (lambda (stream obj)
                       (write-string (comment-text obj) stream)))

@ Usually, to read a comment we accumulate all of the characters starting
with the semicolon and ending just before the next newline, which we leave
for the newline reader to pick up. But as a special exception, if the
comment is empty (that is, consists solely of a single semicolon), the
newline is consumed, and we return zero values. This provides for
`soft-newlines'---that is, newlines in the source file that will not
appear in the output.

@l
(defun comment-reader (stream char)
  (if (char= (peek-char nil stream nil nil t) #\Newline)
      (progn (read-char stream t nil t) (values))
      (make-instance 'comment-marker :text @<Read characters up to...@>)))

(set-macro-character #\; #'comment-reader nil (readtable-for-mode :lisp))

@ @<Read characters up to, but not including, the next newline@>=
(with-output-to-string (s)
  (write-char char s) ; include the opening |#\;|
  (do ()
      ((char= (peek-char nil stream nil #\Newline t) #\Newline))
    (write-char (read-char stream t nil t) s)))

@ The standard Lisp reader does not distinguish between |nil| and the empty
list, but we want to preserve the distinction so that we can output what
was given as input. The simplest way to do this seems to be to override the
reader macro function for |#\(|. However, we don't want to re-implement
the (quite complex) logic needed for reading an arbitrary list, so in the
non-empty-list case we fall back to using the reader macro function in the
standard readtable.

Note that we bind the |*empty-list*| marker to the value |'()| so that
it's preserved during tangling.

@l
(defvar *empty-list* (make-instance 'marker :name "()" :value '()))

(set-pprint-dispatch `(eql ,*empty-list*)
                     (lambda (stream obj)
                       (write-string (marker-value obj) stream)))

(defun read-list (stream char)
  (if (char= (peek-char t stream t nil t) #\))
      (progn (read-char stream t nil t) *empty-list*)
      (funcall (get-macro-character #\( nil) stream char)))

(dolist (mode '(:lisp :inner-lisp))
  (set-macro-character #\( #'read-list nil (readtable-for-mode mode)))

@ Similarly, we want to preserve the distinction between a form quoted
with |#\'| and one quoted (for whatever reason) with |quote|.

@l
(defclass quote-marker (marker)
  ((value :accessor quoted-form :initarg :form)))

(defmethod print-object ((object quote-marker) stream)
  (print-unreadable-object (object stream :type t :identity nil)
    (format stream "'~S" (quoted-form object))))

(set-pprint-dispatch 'quote-marker
                     (lambda (stream obj)
                       (format stream "'~W" (quoted-form obj))))

(defmethod marker-value ((marker quote-marker))
  (list 'quote (quoted-form marker)))

(defun single-quote-reader (stream char)
  (declare (ignore char))
  (make-instance 'quote-marker :form (read stream t nil t)))

(dolist (mode '(:lisp :inner-lisp))
  (set-macro-character #\' #'single-quote-reader nil (readtable-for-mode mode)))

@ Backquote is hairy, and so we use a kludge to avoid implementing the
whole thing. What we do is set up our Lisp and inner-Lisp mode readtables
so that the reader macro functions for |#\`| and |#\,| do the absolute
minimum amount of processing necessary to be able to reconstruct the forms
that were read. Then, when the tangler asks for the |marker-value| of a
backquote marker, we reconstruct the source form using the pretty-printer,
and read it back in using the standard readtable. It's a sleazy trick, but
it works.

We assume |read|-|print| equivalence (not unreasonable, since without it
the file tangler won't work anyway).

@l
(defclass backquote-marker (marker)
  ((value :accessor backq-form :initarg :form)))

(defmethod marker-value ((marker backquote-marker))
  (with-mode nil
    (read-from-string (with-output-to-string (s) (pprint marker s)))))

(defun backquote-reader (stream char)
  (declare (ignore char))
  (make-instance 'backquote-marker :form (read stream t nil t)))

(dolist (mode '(:lisp :inner-lisp))
  (set-macro-character #\` #'backquote-reader nil (readtable-for-mode mode)))

(set-pprint-dispatch 'backquote-marker
                     (lambda (stream obj)
                       (format stream "`~W" (backq-form obj))))

@ @l
(defclass comma-marker (marker)
  ((value :accessor comma-form :initarg :form)
   (modifier :reader comma-modifier :initarg :modifier))
  (:default-initargs :modifier nil))

(defmethod marker-value ((marker comma-marker))
  (with-mode nil
    (read-from-string (with-output-to-string (s) (pprint marker s)))))

(defun comma-reader (stream char)
  (declare (ignore char))
  (let ((c (read-char stream)))
    (case c
      (#\@ (make-instance 'comma-marker
                          :modifier #\@
                          :form (read stream t nil t)))
      (#\. (make-instance 'comma-marker
                          :modifier #\.
                          :form (read stream t nil t)))
      (t (unread-char c stream)
         (make-instance 'comma-marker :form (read stream t nil t))))))

(dolist (mode '(:lisp :inner-lisp))
  (set-macro-character #\, #'comma-reader nil (readtable-for-mode mode)))

(set-pprint-dispatch 'comma-marker
                     (lambda (stream obj)
                       (format stream ",~@[~C~]~W"
                               (comma-modifier obj)
                               (comma-form obj))))

@ We accumulate \TeX\ mode material such as commentary, section names,
\etc. using the following function, which reads from |stream| until
encountering either {\sc EOF} or a {\it control character\/}. The set of
control characters is given by the |control-chars| argument, which should
be a designator for a list of characters.

@l
(defun snarf-until-control-char (stream control-chars &aux
                                 (control-chars (if (listp control-chars)
                                                    control-chars
                                                    (list control-chars))))
  (with-output-to-string (string)
    (loop for char = (peek-char nil stream nil *eof* nil)
          until (or (eof-p char) (member char control-chars))
            do (write-char (read-char stream) string))))

@ In \TeX\ mode (including restricted contexts), we allow embedded Lisp
code to be surrounded by \pb, where it is read in inner-Lisp mode, which is
almost, but not quite, the same as Lisp mode.

@l
(defun read-inner-lisp (stream char)
  (with-mode :inner-lisp
    (read-delimited-list char stream t)))

(dolist (mode '(:TeX :restricted))
  (set-macro-character #\| #'read-inner-lisp nil (readtable-for-mode mode)))

@ The call to |read-delimited-list| in |read-inner-lisp| will only stop at
the closing \v\ if we set it to be a terminating macro character,
overriding its usual Lisp meaning as an escape character. The following
makes it an error to use \v\ in inner-Lisp mode.

@l
(set-macro-character #\| (get-macro-character #\) nil)
                     nil (readtable-for-mode :inner-lisp))

@ We make |#\@| a non-terminating dispatching macro character in every
mode, and define some convenience routines for retrieving and setting the
reader macro functions that implement the control codes.

@l
(dolist (mode *modes*)
  ;; The CL standard does not say that calling MAKE-DISPATCH-MACRO-CHARACTER
  ;; on a character that's already a dispatching macro character is supposed
  ;; to signal an error, but SBCL does so; hence the IGNORE-ERRORS.
  (ignore-errors
    (make-dispatch-macro-character #\@ t (readtable-for-mode mode))))

(defun get-control-code (sub-char mode)
  (get-dispatch-macro-character #\@ sub-char (readtable-for-mode mode)))

(defun set-control-code (sub-char function &optional (modes *modes*))
  (dolist (mode modes)
    (set-dispatch-macro-character #\@ sub-char function
                                  (readtable-for-mode mode))))

@ The control code \.{@@@@} yields the string `\.{"@@"}' in all modes, but
it should really only be used in \TeX\ text.

@l
(set-control-code #\@ (lambda (stream sub-char arg)
                        (declare (ignore sub-char stream arg))
                        (string "@")))

@ Sections are introduced by the two section-starting control codes, \.{@@ }
and~\.{@@*}, which differ only in the way they are output during weaving.
The reader macro functions that implement these control codes return an
instance of the appropriate section class.

@l
(defun start-section-reader (stream sub-char arg)
  (declare (ignore stream arg))
  (make-instance (ecase sub-char
                   (#\Space 'section)
                   (#\* 'starred-section))))

(dolist (sub-char '(#\Space #\*))
  (set-control-code sub-char #'start-section-reader '(:limbo :TeX :lisp)))

@ The control codes \.{@@l} and ~\.{@@p} (where `l' is for `Lisp' and `p'
is for `Program'---both control codes do the same thing) begin the code
part of an unnamed section. They are recognized only in \TeX\ mode---every
section must begin with a commentary, even if it is empty.

The control code \.{@@e} (`e' for `evaluate') is similar to \.{@@l} in that
it begins the code part of an unnamed section, but every form in that part
is evaluated at read-time {\it in addition to\/} being tangled and therefore
evaluated at run-time and possibly compile-time, too. Sections containing
evaluated code-parts should be used only for establishing state that is
needed by the reader: package definitions, structure definitions that are
used with the \.{#S} reader macro, \etc.

@l
(defclass start-code-marker (marker)
  ((evalp :reader evaluated-code-p :initarg :evalp))
  (:default-initargs :evalp nil))

(defun start-code-reader (stream sub-char arg)
  (declare (ignore stream arg))
  (make-instance 'start-code-marker
                 :evalp (ecase sub-char
                          ((#\L #\P) nil)
                          ((#\E) t))))

(dolist (sub-char '(#\l #\p #\e))
  (set-control-code sub-char #'start-code-reader '(:TeX)))

@ Several control codes, including \.{@@<}, contain `restricted' \TeX\ text,
called {\it control text}, that extends to the matching \.{@@>}. When we
first read control text, we ignore inner-Lisp material (that is, Lisp forms
surrounded by \pb). During weaving, we'll re-scan it to pick up such
material.

@l
(defvar *end-control-text* (make-symbol "@>"))
(set-control-code #\> (constantly *end-control-text*) '(:restricted))

(defun read-control-text (stream)
  (with-mode :restricted
    (apply #'concatenate 'string
           (loop for text = (snarf-until-control-char stream #\@)
                 as x = (read-preserving-whitespace stream t nil t)
                 collect text
                 until (eq x *end-control-text*) collect x))))

@ The control code \.{@@<} introduces a section name, which extends to the
closing \.{@@>}. Its meaning is context-dependent.

In \TeX\ mode, a name must be followed by \.{=}, in which case it indicates
that the name should be attached to the current section and begins the
code part of the section.

In Lisp and inner-Lisp modes, a name is taken to refer to the section so
named. During tangling, such references in Lisp mode will be replaced with
the code defined for that section. References in inner-Lisp mode are used
only during weaving.

@l
(defun make-section-name-reader (definition-allowed-p)
  (lambda (stream sub-char arg)
    (declare (ignore sub-char arg))
    (let* ((name (read-control-text stream))
           (definition-p (eql (peek-char nil stream nil nil t) #\=)))
      (if definition-p
          (if definition-allowed-p
              (progn
                (read-char stream)
                (make-instance 'start-code-marker :name name))
              @<Signal an error about section definition in Lisp mode@>)
          (if definition-allowed-p
               @<Signal an error about section name use in \TeX\ mode@>
               (let ((named-section (find-section name)))
                 (pushnew (current-section) (used-by named-section))
                 named-section))))))

(set-control-code #\< (make-section-name-reader t) '(:TeX))
(set-control-code #\< (make-section-name-reader nil) '(:lisp :inner-lisp))

@ @<Signal an error about section definition in Lisp mode@>=
(restart-case
    (error "Can't define a named section in Lisp mode: ~A" name)
  (use-section ()
    :report "Don't define the section, just use it."
    (find-section name)))

@ @<Signal an error about section name use in \TeX\ mode@>=
(restart-case
    (error "Can't use a section name in TeX mode: ~A" name)
  (name-section ()
    :report "Name the current section and start the code part."
    (make-instance 'start-code-marker :name name))
  (cite-section ()
    :report "Assume the section is just being cited."
    (find-section name)))

@ We need one last utility before coming to the main section reader.
When we're accumulating text, we don't want to bother with empty strings.
So we use the following macro, which is like |push|, but does nothing if
the new object is an empty string or |nil|.

@l
(defmacro maybe-push (obj place &aux (g (gensym)))
  `(let ((,g ,obj))
     (when (typecase ,g
             (string (plusp (length ,g)))
             (t ,g))
       (push ,g ,place))))

@ We come now to the heart of the \WEB\ parser. This function is a
tiny state machine that models the global syntax of a \WEB\ file.
(We can't just use reader macros since sections and their parts lack
explicit closing delimiters.) It returns a list of |section| objects.

@l
(defun read-sections (stream append-p)
  (flet ((finish-section (section commentary code)
           (setf (section-commentary section) (nreverse commentary))
           (setf (section-code section) (nreverse code))
           (when (section-name section) @<Setup named section...@>)
           section))
    (prog (form commentary code section sections)
     limbo
      (setq section (make-instance 'limbo-section))
      @<Accumulate limbo text in |commentary|@>
     commentary
      (push (finish-section section commentary code) sections)
      @<Initialize section variables@>
      @<Accumulate \TeX-mode material in |commentary|@>
     lisp
      @<Accumulate Lisp-mode material in |code|@>
     eof
      (push (finish-section section commentary code) sections)
      (return (nreverse sections)))))

@ Limbo text is \TeX\ text that proceeds the first section marker, and we
treat it as commentary for a special section with no code. Note that
inner-Lisp material is not recognized in limbo text.

@<Accumulate limbo text in |commentary|@>=
(with-mode :limbo
  (loop
    (maybe-push (snarf-until-control-char stream #\@) commentary)
    (setq form (read-preserving-whitespace stream nil *eof* nil))
    (typecase form
      (eof (go eof))
      (section (go commentary))
      (t (push form commentary)))))

@ @<Initialize section variables@>=
(check-type form section)
(setq section form
      commentary '()
      code '())

@ The commentary part that begins a section consists of \TeX\ text and
inner-Lisp material surrounded by \pb. It is terminated by either the start
of a new section, the beginning of the code part, or {\sc EOF}. If a code
part is detected, we also set the name of the current section, which may be
|nil|.

@<Accumulate \TeX-mode material in |commentary|@>=
(with-mode :TeX
  (loop
    (maybe-push (snarf-until-control-char stream '(#\@ #\|)) commentary)
    (setq form (read-preserving-whitespace stream nil *eof* nil))
    (typecase form
      (eof (go eof))
      (section (go commentary))
      (start-code-marker (setf (section-name section) (marker-name form))
                         (go lisp))
      (t (push form commentary)))))

@ The code part of a section consists of zero or more Lisp forms and is
terminated by either {\sc EOF} or the start of a new section. If the code
part was begun by a \.{@@e} control code, we evaluate the code forms as we
read them.

@<Accumulate Lisp-mode material in |code|@>=
(check-type form start-code-marker)
(with-mode :lisp
  (let ((evalp (evaluated-code-p form)))
    (loop
      (setq form (read-preserving-whitespace stream nil *eof* nil))
      (typecase form
        (eof (go eof))
        (section (go commentary))
        (start-code-marker (error "Can't start a section with a code part"))
        (t (when evalp (eval (tangle form)))
           (push form code))))))

@ @<Setup named section code, number, and cross-references@>=
(let ((named-section (find-section (section-name section)))
      (number (section-number section))
      (code (section-code section)))
  (set-named-section-code named-section code append-p)
  (when (or (not (slot-boundp named-section 'number))
            (not append-p))
    (setf (section-number named-section) number))
  (if append-p
      (pushnew section (see-also named-section))
      (setf (see-also named-section) (list section))))

@*The tangler. Tangling involves recursively replacing each reference to a
named section with the code accumulated for that section. The function
|tangle-1| expands one level of such references, returning the
possibly-expanded form, and a boolean representing whether or not any
expansions were actually performed.

Note that this is a splicing operation, not a simple replacement: if
|@<foo@>\='(x y)|, then |(tangle-1 '(a @<foo@> b))|$\rarrow$|(a x y b)|,~|t|.

Tangling also replaces {\it bound markers\/} with their associated values.
Markers are objects that behave much like symbols: they have names, and may
be bound to a value. We usually use them to stand for objects that would
not ordinarily be returned or preserved by the reader, such as newlines and
comments. If a marker is not bound (as is the case for newlines and comments),
it is simply removed from the form.

@l
(defun tangle-1 (form)
  (cond ((atom form) (values form nil))
        ((typep (car form) 'named-section)
         (values (append (section-code (car form)) (tangle-1 (cdr form)))
                 t))
        ((typep (car form) 'marker)
         (values (if (marker-boundp (car form))
                     (cons (marker-value (car form)) (tangle-1 (cdr form)))
                     (tangle-1 (cdr form)))
                 t))
        (t (multiple-value-bind (a car-expanded-p) (tangle-1 (car form))
             (multiple-value-bind (d cdr-expanded-p) (tangle-1 (cdr form))
               (values (if (and (eql a (car form))
                                (eql d (cdr form)))
                           form
                           (cons a d))
                       (or car-expanded-p cdr-expanded-p)))))))

@ |tangle| repeatedly calls |tangle-1| on |form| until it can no longer be
expanded. Like |tangle-1|, it returns the possibly-expanded form and an
`expanded' flag.

@l
(defun tangle (form)
  (labels ((expand (form expanded)
             (multiple-value-bind (new-form newly-expanded-p)
                 (tangle-1 form)
               (if newly-expanded-p
                   (expand new-form t)
                   (values new-form expanded)))))
    (expand form nil)))

@ A little utility function invokes the main section reader and returns a
list of all of the forms in all of the unnamed sections' code parts.

@l
(defun read-code-parts (stream append-p)
  (apply #'append
         (map 'list
              #'section-code
              (remove-if #'section-name (read-sections stream append-p)))))

@ We're now ready for the high-level tangler interface. We begin with
|load-web|, which uses a helper function, |load-web-from-stream|, so
that it can handle input from a file or an arbitrary stream. The logic
is straightfoward: loop over the tangled forms read from the stream,
evaluating each one in turn.

Note that like |load|, we bind |*readtable*| and |*package*| to their
current values, so that assignments to those variables in the \WEB\ code
will not effect the calling environment.

@l
(defun load-web-from-stream (stream verbose print &optional (append-p t))
  (when verbose (format t "~&; loading WEB from ~S~%" (pathname stream)))
  (let ((*readtable* *readtable*)
        (*package* *package*))
    (dolist (form (tangle (read-code-parts stream append-p)) t)
      (if print
          (let ((results (multiple-value-list (eval form))))
            (format t "~&; ~{~S~^, ~}~%" results))
          (eval form)))))

(defun load-web (filespec &key
                 (verbose *load-verbose*)
                 (print *load-print*)
                 (if-does-not-exist t)
                 (external-format :default))
  @<Initialize global variables@>
  (if (streamp filespec)
      (load-web-from-stream filespec verbose print)
      (with-open-file (stream filespec
                       :direction :input
                       :external-format external-format
                       :if-does-not-exist (if if-does-not-exist :error nil))
        (load-web-from-stream stream verbose print))))

@ This next function exists solely for the sake of front-ends that wish to
load a piece of a \WEB, such as the author's `\.{clweb.el}'. Note that it
does {\it not\/} initialize the global variables like |*named-sections*|;
this allows for incremental redefinition.

@l
(defun load-sections-from-temp-file (file append-p &aux
                                     (truename (probe-file file)))
  (when truename
    (unwind-protect
         (with-open-file (stream truename :direction :input)
           (load-web-from-stream stream nil t append-p))
      (delete-file truename))))

@ The file tangler operates by writing out the tangled code to a Lisp source
file and then invoking the file compiler on that file.

@l
(defun tangle-file (input-file &rest args &key
                    output-file
                    (verbose *compile-verbose*)
                    (print *compile-print*)
                    (external-format :default) &allow-other-keys &aux
                    (lisp-file (merge-pathnames (make-pathname :type "lisp")
                                                input-file)))
  (declare (ignore output-file print))
  (when verbose (format t "~&; tangling WEB from ~S~%" input-file))
  @<Initialize global variables@>
  (with-open-file (input input-file
                   :direction :input
                   :external-format external-format)
    (with-open-file (lisp lisp-file
                     :direction :output
                     :if-exists :supersede
                     :external-format external-format)
      (format lisp ";;;; TANGLED OUTPUT FROM WEB ~S.  DO NOT EDIT." input-file)
      (dolist (form (tangle (read-code-parts input t)))
        (pprint form lisp))))
  (apply #'compile-file lisp-file args))

@*The weaver. Most of the hard work is done while reading the sections in,
so weaving consists almost entirely of pretty-printing.

@ We set up our own pretty-print dispatch table for weaving, and a utility
function for setting its entries.

@l
(defparameter *weave-pprint-dispatch* (copy-pprint-dispatch nil))

(defun set-weave-dispatch (type-specifier function &optional (priority 0))
  (set-pprint-dispatch type-specifier function priority
                       *weave-pprint-dispatch*))

@ @l
(defun weave (filespec &key
              (output-file nil)
              (verbose *load-verbose*)
              (print *load-print*)
              (if-does-not-exist t)
              (external-format :default))
  (unless output-file
    (setq output-file (merge-pathnames (make-pathname :type "tex") filespec)))
  (load-web filespec
            :verbose verbose
            :print print
            :if-does-not-exist if-does-not-exist
            :external-format external-format)
  (weave-sections *sections* output-file))

@ @l
(defparameter *tex-prologue* (format nil "\\input clwebmac~%"))

(defun weave-sections (sections output-file)
  (with-open-file (output output-file
                   :direction :output
                   :if-exists :supersede)
    (princ *tex-prologue* output)
    (loop with *print-case* = :downcase
          with *print-escape* = nil
          with *print-pretty* = t
          with *print-pprint-dispatch* = *weave-pprint-dispatch*
          with *print-right-margin* = 1000
          for section across sections
          do (pprint section output)
          finally (format output "~&\\bye~%"))))

@ \TeX-mode material consists of a list of strings containing pure \TeX\ text
and lists of (inner-)Lisp forms.

@l
(defvar *inner-lisp* nil)

(defun print-TeX (stream tex-mode-material)
  (dolist (x tex-mode-material)
    (etypecase x
      (string (write-string x stream))
      (list (let ((*inner-lisp* t))
              (dolist (form x)
                (write form :stream stream)))))))

@ Control text (like section names) and comments are initially read as
strings containing pure \TeX\ text, but they actually contain restricted
\TeX-mode material, which may include inner-Lisp material. This routine
re-reads such strings and picks up any inner-Lisp material.

@l
(defun read-TeX-from-string (input-string)
  (with-input-from-string (stream input-string)
    (with-mode :restricted
      (loop for text = (snarf-until-control-char stream #\|)
            for forms = (read-preserving-whitespace stream nil *eof* nil)
            collect text
            until (eof-p forms) collect forms))))

@ @l
(defun print-limbo (stream section)
  (let ((commentary (section-commentary section)))
    (when commentary
      (print-TeX stream commentary))))

(set-weave-dispatch 'limbo-section #'print-limbo 1)

@ @l
(defun print-section (stream section)
  (format stream "~&\\~:[M~;N{1}~]{~D}" ; `\.{\{1\}}' should be depth
          (typep section 'starred-section)
          (section-number section))
  (let* ((commentary (section-commentary section))
         (name (section-name section))
         (named-section (and name (find-section name)))
         (code (section-code section)))
    (print-TeX stream commentary)
    (when (and commentary code) (write-string "\\Y" stream))
    (when named-section
      (print-section-name stream named-section)
      (format stream "${}~:[\\mathrel+~;~]\\E{}$"
              (= (section-number section) (section-number named-section))))
    (dolist (form code)
      (pprint-logical-block (stream form :per-line-prefix "\\+" :suffix "\\cr")
        (write form :stream stream)))
    (when named-section
      (print-xrefs stream #\A (remove section (see-also named-section)))
      (print-xrefs stream #\U (remove section (used-by named-section)))))
  (write-string "\\fi" stream))

(set-weave-dispatch 'section #'print-section)

@ The cross-references lists use the macros \.{\\A} (for `also'), \.{\\U}
(for `use'), \.{\\Q} (for `quote'), and their pluralized variants, along
with the conjunction macros \.{\\ET} (for two section numbers) and~\.{\\ETs}
(for between the last of three or more).

@l
(defun print-xrefs (stream kind xrefs)
  (when xrefs
    ;; This was fifteen lines of code in \CWEB. I love |format|.
    (format stream "~&\\~C~{~#[~;~D~;s ~D\\ET~D~:;s~@{~#[~;\\ETs~D~;~D~:;~D, ~]~}~]~}."
            kind (sort (mapcar #'section-number xrefs) #'<))))

@ @l
(defun print-section-name (stream named-section)
  (format stream "\\X~D:" (section-number named-section))
  (print-TeX stream (read-TeX-from-string (section-name named-section)))
  (write-string "\\X" stream))

(set-weave-dispatch 'named-section #'print-section-name)

@ Some of the markers get simple specialized pretty-printing functions.

@l
(set-weave-dispatch `(eql ,*newline*)
                    (lambda (stream obj)
                      (declare (ignore obj))
                      (terpri stream)))

(set-weave-dispatch `(eql ,*empty-list*)
                    (lambda (stream obj)
                      (declare (ignore obj))
                      (write-string "\\(\\)" stream)))

(set-weave-dispatch 'quote-marker
                    (lambda (stream obj)
                      (write-string "\\'" stream)
                      (print-list stream (quoted-form obj))))

(set-weave-dispatch 'comment-marker
                    (lambda (stream obj)
                      (print-TeX stream
                                 (read-TeX-from-string (comment-text obj)))))

@ Because we're outputting \TeX, we need to carefully escape characters that
\TeX\ treats as special. Unfortunately, because \TeX's syntax is so malleable
(not unlike Lisp's), it's nontrivial to decide what to escape, how, and when.

The following routine is the basis for most of the escaping. It writes the
given string to an output stream, escaping the characters given in the
|escape-chars| a-list. The entries in this a-list should be of the form
`(\metasyn{characters}~.~\metasyn{replacement})', where
\metasyn{characters} is a string of characters to be escaped with
\metasyn{replacement}, which may be a single character, in which case that
character is output before any occurrences of \metasyn{character}, or a
string, in which case it is output instead of the character being considered.

@l
(defun write-escaped-string (stream string escape-chars)
  (dotimes (i (length string))
    (let* ((char (char string i))
           (escape (cdr (assoc char escape-chars :test #'find))))
      (etypecase escape
        (character (write-char escape stream)
                   (write-char char stream))
        (string (write-string escape stream))
        (null (write-char char stream))))))

(defparameter *tex-escape-alist*
  '((" \\%&#$^_|~" . #\\) ("{" . "$\\{$") ("}" . "$\\}$")))

@ @l
(defun print-string (stream string)
  (write-string "\\.{\"" stream)
  (write-escaped-string stream string
                        (list* '("{}" . #\\)
                               '("\\" . "\\\\\\\\")
                               '("\"" . "\\\\\"")
                               *tex-escape-alist*))
  (write-string "\"}" stream))

(set-weave-dispatch 'string #'print-string)

@ @l
(defun print-char (stream char)
  (let ((graphicp (and (graphic-char-p char)
                       (standard-char-p char)))
        (name (char-name char)))
    (write-string "{\\tt \\#\\\\" stream)
    (write-escaped-string stream
                          (if (and name (not graphicp))
                              name
                              (make-string 1 :initial-element char))
                          (list* '("{}" . #\\) *tex-escape-alist*))
    (write-string "}" stream)))

(set-weave-dispatch 'character #'print-char)

@ Some symbols are sometimes printed using a special format for
emphasis. These symbols include (but are not limited to) the Common Lisp
special operators, $\lambda$-list keywords, and symbols whose names begin
with `DEF'.

@l
(defvar *highlight-special-symbols* nil)

(defun def-p (symbol)
  (let* ((name (symbol-name symbol))
         (len (length name)))
    (and (> len 3) (string= name "DEF" :end1 3))))

(defun highlight-symbol-p (symbol)
  (cond ((or (special-operator-p symbol)
             (member symbol '(cond loop)))
         (member :special-operator *highlight-special-symbols*))
        ((operator-with-body-p symbol)
         (member :body *highlight-special-symbols*))
        ((member symbol lambda-list-keywords)
         (member :lambda-list-keyword *highlight-special-symbols*))
        ((def-p symbol)
         (member :def *highlight-special-symbols*))))

@ @l
(defun print-symbol (stream symbol)
  (let ((group-p (cond ((highlight-symbol-p symbol)
                        (write-string "\\&{" stream))
                       ((keywordp symbol)
                        (write-string "\\:{" stream))
                       (*inner-lisp*
                        (write-string "\\\\{" stream)))))
    (write-escaped-string stream
                          (write-to-string symbol :escape nil :pretty nil)
                          (list* '("*" . "\\/$\\ast$")
                                 '("&" . "\\AM ")
                                 *tex-escape-alist*))
    (when group-p (write-string "}" stream))))

(set-weave-dispatch 'symbol #'print-symbol)

@ Rather than tracking and attempting to duplicate the exact indentation
given in the input file, we use a set of heuristics (described below)
to do indentation, but respect the line breaks given in the input.

This macro aids with that task. It takes objects from the current
pretty-printing list using |pprint-pop|, and either writes that object to
|stream|, or, if it is a newline marker, ends the current line, optionally
outputs some indentation, and continues on to the next object. The
indentation is computed by the |:indent| argument, which should be a form
that evaluates to a string. That form is re-evaluated when and only when a
non-newline object has just been printed and the list is still non-empty.
This allows routines like |print-form-with-body|, below, to keep track of
the number of sub-forms that have been printed.

If the |:first| argument is supplied, that object is used instead of the
next item from the pprint list for the first iteration. This facility is
to support one-token look-ahead in the caller.

@l
(defmacro print-remaining-objects-and-newlines (stream &key
                                                (first nil first-supplied-p)
                                                indent)
  (let ((obj (gensym)) (next (gensym)) (indentation (gensym)))
    `(do ((,obj ,(if first-supplied-p first '(pprint-pop)) ,next)
          (,next)
          (,indentation ,indent))
         (nil)
       (declare (ignorable ,indentation))
       (cond ((eq ,obj *newline*)
              (format ,stream "\\cr~:@_")
              ,@(when indent
                  (list `(write-string ,indentation ,stream)))
              (pprint-exit-if-list-exhausted)
              (setq ,next (pprint-pop)))
             (t (write ,obj :stream ,stream)
                (pprint-exit-if-list-exhausted)
                (setq ,next (pprint-pop)
                      ,@(when indent `(,indentation ,indent)))
                (unless (eq ,next *newline*)
                  (write-char #\Space ,stream)))))))

@ Now, suppose we are outputting a compound form $f$. We first examine the
|car| of $f$: if it not |fboundp| (i.e., it's a data list), we use the
following simple routine, which indents to the first column after the
opening parenthesis.

We set a slightly negative priority for this routine, since almost every
other list-printing routine is more specialized, and should be used instead
when applicable.

@l
(defun print-list (stream list)
  (write-string "\\(" stream)
  (pprint-logical-block (stream list :per-line-prefix "&" :suffix "\\)")
    (print-remaining-objects-and-newlines stream)))

(set-weave-dispatch 'cons #'print-list -2)

@ If the |car| of some form $f$ is |fboundp|, but we don't have a more
specific pretty-printing routine, then we choose between two generic
indentation styles: {\it fun-call style\/} and {\it body style}.

Fun-call style is the indentation style used for almost all compound forms
in Common Lisp: the second and subsequent subforms are aligned directly
under the start of the first subform, unless the second subform is on the
same line as the first, in which case the third and subsequent subforms are
aligned under the start of the second. (Read that again and you'll get it).

This routine also has a slightly negative priority, but higher than that of
|print-list|.

@l
(defun print-fun-call (stream form)
  (write-string "\\(" stream)
  (pprint-logical-block (stream form :per-line-prefix "&" :suffix "\\)")
    (write (pprint-pop) :stream stream)
    (pprint-exit-if-list-exhausted)
    (let ((next (pprint-pop)))
      (cond ((eq next *newline*)
             (format stream "\\cr~:@_")
             (print-remaining-objects-and-newlines stream))
            (t (write-char #\Space stream)
               (pprint-indent :current 0 stream)
               (write-char #\& stream)
               (print-remaining-objects-and-newlines stream
                                                     :first next
                                                     :indent "&"))))))

(set-weave-dispatch '(cons (and symbol (satisfies fboundp)))
                     #'print-fun-call -1)

@ Body-style indentation is used, unsurprisingly, for forms with a |&body|
parameter (or a |&rest| parameter that should have been a |&body|
parameter). We indent all of the subforms before the |&body| by two quads
from the opening parenthesis, and the body subforms by one quad.

@l
(defun print-form-with-body (stream form)
  (write-string "\\(" stream)
  (pprint-logical-block (stream form :per-line-prefix "&" :suffix "\\)")
    (write (pprint-pop) :stream stream)
    (pprint-exit-if-list-exhausted)
    (write-char #\Space stream)
    (let ((body (or (lambda-list-body (car form)) -1))
          (i 0))
      (print-remaining-objects-and-newlines
       stream
       :indent (if (<= (incf i) body) "\\2" "\\1")))))

(defun operator-with-body-p (operator)
  (and (fboundp operator) (lambda-list-body operator)))

(set-weave-dispatch '(cons (and symbol (satisfies operator-with-body-p)))
                     #'print-form-with-body 0)

@ We'll need a function that can reliably extract a $\lambda$-list from a
function designator. Under SBCL, such a routine is available in the
"SB-INTROSPECT" package.

@e
#+sbcl
(eval-when (:compile-toplevel :load-toplevel :execute)
  (require 'sb-introspect)
  (import (find-symbol "FUNCTION-ARGLIST" "SB-INTROSPECT")))

@ This routine returns the position of the |&body| parameter in |operator|'s
$\lambda$-list, or |nil| if there is no such parameter. The little |labels|
function is used to remove |&whole|, |&enviroment|, and |&aux| arguments
from the argument list.

@l
(defun lambda-list-body (operator)
  (labels ((clean-arglist (arglist)
             (cond ((null arglist) '())
                   ((member (car arglist) '(&whole &environment))
                    (clean-arglist (cddr arglist)))
                   ((eq (car arglist) '&aux) '())
                   (t (cons (car arglist) (clean-arglist (cdr arglist)))))))
   (let ((lambda-list (remove '&optional
                              (clean-arglist (function-arglist operator)))))
     (or (position '&body lambda-list)
         @<Position of a |&rest| parameter named `BODY' in |lambda-list|@>))))

@ Some macros don't use a |&body| parameter, but should. So we accept a
|&rest| parameter whose name is `BODY' as being close enough.

@<Position of a |&rest|...@>=
(let ((rest (position '&rest lambda-list)))
  (when rest
    (let ((restarg (symbol-name (elt lambda-list (1+ rest)))))
      (when (string= restarg "BODY")
        rest))))

@ Backquote printing is easy with the markers we've defined.

@l
(set-weave-dispatch 'backquote-marker
                    (lambda (stream marker)
                      (write-string "\\`" stream)
                      (write (backq-form marker) :stream stream)))

(set-weave-dispatch 'comma-marker
                    (lambda (stream marker)
                      (format stream "\\C{~@[~C~]}~W"
                              (comma-modifier marker)
                              (comma-form marker))))
