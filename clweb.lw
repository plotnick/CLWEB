% CLWEB is a literate programming system for Common Lisp.
% It was inspired by CWEB by Silvio Levy and Donald E. Knuth, which was
% based on Knuth's original WEB system.

\def\pb{\.{|...|}} % program brackets
\def\v{\.{\char'174}} % vertical bar in typewriter font

@ @e
(defpackage "COMMON-LISP-WEB"
  (:nicknames "CLWEB")
  (:use "COMMON-LISP")
  (:export "TANGLE-FILE" "LOAD-WEB" "LOAD-SECTIONS-FROM-TEMP-FILE" "WEAVE"))
(in-package "CLWEB")

@*Tangling \& weaving. The two primary operations that a literate programming
system makes available are {\it tangling\/} and {\/weaving\/}. The former
creates a machine-readable output file from a \WEB, while the latter prepares
the \WEB\ for formatting using \TeX\ or some other formatting engine.

There are three interface functions defined by this system: |tangle-file|,
|load-web|, and |weave|. The first is analogous to |compile-file|: given
an input file containing \WEB\ source, it produces a compiled output file
that can subsequently be loaded into a Lisp image with |load|. The function
|load-web| is analogous to |load|, but again accepts \WEB\ as input
instead of ordinary Lisp source. And finally, |weave| takes a \WEB\ as
input and generates a \TeX\ source file containing the commentary parts
of each section together with pretty-printed code parts.

@ The fundamental unit of a \WEB\ is the {\it section}, which consists
essentially of two parts, either of which may be null: a commentary part
and a code part. Every section is automatically assigned a number,
and each section is either {\it named\/} or {\it unnamed\/}. The code parts
of named sections may be included in those of another (named or unnamed)
section via \.{@@<$ldots$@@>} commands, while unnamed sections are output
or evaluated in the order in which they appear in the \WEB\ source file.

@l
(defvar *section-counter* 0)

(defclass section ()
  ((number :reader section-number
           :initarg :number
           :initform (incf *section-counter*))
   (commentary :accessor section-commentary :initarg :commentary)
   (name :accessor section-name :initarg :name)
   (code :accessor section-code :initarg :code)
   (used-by :accessor used-by :initarg :used-by))
  (:default-initargs :commentary nil :name nil :code nil :used-by nil))

(defclass limbo-section (section) ())

(defclass starred-section (section) ())

@ @<Initialize global variables@>=
(setq *section-counter* 0)

@ Named sections are stored in a binary search tree whose keys are the
section names and whose values are the code to be substituted in place of
a reference to the section so named. The reason for using a tree instead
of, say, a hash table is so that we can support abbreviations (see below).

@l
(defclass binary-search-tree ()
  ((key :accessor node-key :initarg :key)
   (value :accessor node-value :initarg :value)
   (left-child :accessor left-child :initarg :left)
   (right-child :accessor right-child :initarg :right))
  (:default-initargs :left nil :right nil))

@ The primary interface to the {\sc BST} is the following routine, which
attempts to locate the node with key |item| in the tree rooted at |root|.
If it is not already present and the |:insert-if-not-found| argument
is true, a new node is created with that key and added to the tree. The
arguments |predicate| and |test| should be designators for functions
of two arguments, both of which will be node keys. |predicate| should
return true iff its first argument precedes its second in the total
ordering used for the tree, and |test| should return true iff the two
keys are to be considered equivalent.

Two values are returned: the node with key |item| (or |nil| if no such node
was found and |:insert-if-not-found| is false), and a boolean representing
whether the key was already in the tree or not.

@l
(defgeneric find-or-insert (item root &key predicate test insert-if-not-found))

(defmethod find-or-insert (item (root binary-search-tree) &key
                           (predicate #'<) (test #'eql)
                           (insert-if-not-found t))
  (flet ((lessp (item node) (funcall predicate item (node-key node)))
         (samep (item node) (funcall test item (node-key node))))
    (do ((parent nil node)
         (node root (if (lessp item node)
                        (left-child node)
                        (right-child node))))
        ((or (null node) (samep item node))
         (if node
             (values node t)
             (if insert-if-not-found
                 @<Insert a new node with key |item| and return it@>
                 (values nil nil)))))))

@ @<Insert a new node...@>=
(let ((node (make-instance (class-of root) :key item)))
  (when parent
    (if (lessp item parent)
        (setf (left-child parent) node)
        (setf (right-child parent) node)))
  (values node nil))

@ It's important to keep in mind that named sections can be defined
piecemeal, with the code spread out over several physical sections. We
might think of a full named section as a sort of `virtual' section, which
consists of a name, the combined code parts of all of the physical sections
with that name, and the number of the first such section.

And that's what we store in the {\sc BST}: nodes that look like sections,
inasmuch as they have specialized |section-name| and |section-code| methods,
but are not actually instances of the class |section|.

@l
(defclass named-section (binary-search-tree)
  ((key :accessor section-name :initarg :name)
   (value :accessor section-code :initarg :code)))

@ Setting the code for a named section usually involves appending the given
forms to whatever forms were already defined for that section, which allows
piecemeal definition. However, sometimes we want to override that behavior
and have the new forms replace the old, such as during interactive
development.

@l
(defun set-named-section-code (section forms &optional (append-p t))
  (setf (section-code section)
        (if (and append-p (slot-boundp section 'value))
            (append (section-code section) forms)
            forms)))

@ When we look up a named section, the name used to perform the lookup,
the name for the section in the tree, or both may be an abbreviation of
the full section name. Any prefix of the full name is allowed, followed by
`$\ldots$': e.g., |@<foo...@>| is an acceptable abbreviation for either
|@<foo bar@>| or |@<foo baz@>|. It is a correctable error if a prefix is
ambiguous.

@l
(defmethod find-or-insert (item (root named-section) &key
                           (predicate #'section-name-lessp)
                           (test #'section-name-equal)
                           (insert-if-not-found t))
  (multiple-value-bind (node present-p)
      (call-next-method item root
                        :predicate predicate
                        :test test
                        :insert-if-not-found insert-if-not-found)
    (if present-p
        (or @<Check for an ambiguous match, and raise an error in that case@>
            (values node t))
        (values node nil))))

@ @<Check for an ambiguous match...@>=
(dolist (child (list (left-child node) (right-child node)))
  (when child
    (multiple-value-bind (alt present-p)
        (call-next-method item child
                          :predicate predicate
                          :test test
                          :insert-if-not-found nil)
      (when present-p
        (restart-case
            (error "~<Ambiguous prefix <~A>: matches both <~A> and <~A>~:@>"
                   (list item (node-key node) (node-key alt)))
          (use-first-match ()
            :report "Use the first match."
            (return (values node t)))
          (use-alt-match ()
            :report "Use the alternate match."
            (return (values alt t))))))))

@ The named section tree is stored in the global variable |*named-sections*|,
which is reset before each tangling or weaving.

@l
(defvar *named-sections* nil)

@ @<Initialize global variables@>=
(setq *named-sections* nil)

@ The next routine is the primary interface to named sections: it looks up
a section by name, and creates a new one if no such section exists.

@l
(defun find-section (name)
  (if (null *named-sections*)
      (values (setq *named-sections* (make-instance 'named-section :name name))
              nil)
      (multiple-value-bind (section present-p)
          (find-or-insert name *named-sections*)
        (when present-p
          ;; Update the section name in case the new one is longer.
          (setf (section-name section) name))
        (values section present-p))))

@ Section names are normalized processed by |squeeze|, which trims leading
and trailing whitespace and replaces all runs of one or more whitespace
characters with a single space.

@l
(defparameter *whitespace*
  (coerce '(#\Space #\Tab #\Newline #\Linefeed #\Page #\Return) 'simple-string))

(defun squeeze (string)
  (flet ((whitespace-p (char) (find char *whitespace* :test #'char=)))
    (coerce
     (loop with squeezing = nil
           for char across (string-trim *whitespace* string)
           if (not squeezing)
             if (whitespace-p char) do (setq squeezing t) and collect #\Space
             else collect char
           else
             unless (whitespace-p char)
               do (setq squeezing nil) and collect char)
     'simple-string)))

@ We need some special comparison routines for section names that deal with
abbreviations.

@l
(defun section-name-prefix-p (name)
  (let ((len (length name)))
    (if (string= (subseq name (max (- len 3) 0) len) "...")
        (values t (- len 3))
        (values nil len))))

(defun section-name-equal (name1 name2)
  (multiple-value-bind (prefix-1-p len1) (section-name-prefix-p name1)
    (multiple-value-bind (prefix-2-p len2) (section-name-prefix-p name2)
      (let ((end (min len1 len2)))
        (if (or prefix-1-p prefix-2-p)
            (string-equal name1 name2 :end1 end :end2 end)
            (string-equal name1 name2))))))

(defun section-name-lessp (name1 name2)
  (multiple-value-bind (prefix-1-p len1) (section-name-prefix-p name1)
    (declare (ignore prefix-1-p))
    (multiple-value-bind (prefix-2-p len2) (section-name-prefix-p name2)
      (declare (ignore prefix-2-p))
      (string-lessp name1 name2 :end1 len1 :end2 len2))))

@ We only actually update the name of a section in two cases: if the new
name is not an abbreviation but the old one was, or if they are both
abbreviations, but the new one is shorter.

@l
(defmethod (setf section-name) :around (new-name (section named-section))
  (multiple-value-bind (new-prefix-p new-len)
      (section-name-prefix-p new-name)
    (multiple-value-bind (old-prefix-p old-len)
        (section-name-prefix-p (section-name section))
      (if (or (and old-prefix-p (not new-prefix-p))
              (and old-prefix-p new-prefix-p (< new-len old-len)))
          (call-next-method)
          new-name))))

@*The tangler. Tangling involves recursively replacing each reference to a
named section with the code accumulated for that section. The function
|tangle-1| expands one level of such references, returning the
possibly-expanded form, and a boolean representing whether or not any
expansions were actually performed.

Note that this is a splicing operation, not a simple replacement: if
|@<foo@>\='(x y)|, then |(tangle-1 '(a @<foo@> b))|$\rarrow$|(a x y b)|,~|t|.

@l
(defun tangle-1 (form)
  (cond ((atom form) (values form nil))
        ((typep (car form) 'named-section)
         (values (append (section-code (car form)) (tangle-1 (cdr form)))
                 t))
        (t (multiple-value-bind (a car-expanded-p) (tangle-1 (car form))
             (multiple-value-bind (d cdr-expanded-p) (tangle-1 (cdr form))
               (values (if (and (eql a (car form)) (eql d (cdr form)))
                           form
                           (cons a d))
                       (or car-expanded-p cdr-expanded-p)))))))

@ |tangle| repeatedly calls |tangle-1| on |form| until it can no longer be
expanded. Like |tangle-1|, it returns the possibly-expanded form and an
`expanded' flag.

@l
(defun tangle (form)
  (labels ((expand (form expanded)
             (multiple-value-bind (new-form newly-expanded-p)
                 (tangle-1 form)
               (if newly-expanded-p
                   (expand new-form t)
                   (values new-form expanded)))))
    (expand form nil)))

@ Both of the high-level tangling routines use the following function,
which loops over the sections read from the given stream one at a time,
stores the code for the named sections as a side-effect, and returns a list
of Lisp forms from the code parts of the unnamed sections. If the second
argument is |t|, code for named sections will be appended to the code
already defined, if any; otherwise, old code will be replaced with the new.

@l
(defun read-code-parts (stream append-p)
  (loop for section in (read-sections stream)
        as name = (section-name section)
        as code = (section-code section)
        if name do (set-named-section-code (find-section name) code append-p)
        else append code))

@ We're now ready for the high-level tangler interface. We begin with
|load-web|, which uses a helper function, |load-web-from-stream|, so
that it can handle input from a file or an arbitrary stream. The logic
is straightfoward: loop over the tangled forms read from the stream,
evaluating each one in turn.

Note that like |load|, we bind |*readtable*| and |*package*| to their
current values, so that assignments to those variables in the \WEB\ code
will not effect the calling environment.

@l
(defun load-web-from-stream (stream verbose print &optional (append-p t))
  (when verbose (format t "~&; loading WEB from ~S~%" (pathname stream)))
  (let ((*readtable* *readtable*)
        (*package* *package*))
    (dolist (form (tangle (read-code-parts stream append-p)) t)
      (if print
          (let ((results (multiple-value-list (eval form))))
            (format t "~&; ~{~S~^, ~}~%" results))
          (eval form)))))

(defun load-web (filespec &key
                 (verbose *load-verbose*)
                 (print *load-print*)
                 (if-does-not-exist t)
                 (external-format :default))
  @<Initialize global variables@>
  (if (streamp filespec)
      (load-web-from-stream filespec verbose print)
      (with-open-file (stream filespec
                       :direction :input
                       :external-format external-format
                       :if-does-not-exist (if if-does-not-exist :error nil))
        (load-web-from-stream stream verbose print))))

@ This next function exists solely for the sake of front-ends that wish to
load a piece of a \WEB, such as the author's `\.{clweb.el}'. Note that it
does {\it not\/} initialize the global variables like |*named-sections*|;
this allows for incremental redefinition.

@l
(defun load-sections-from-temp-file (file append-p &aux
                                     (truename (probe-file file)))
  (when truename
    (unwind-protect
         (with-open-file (stream truename :direction :input)
           (load-web-from-stream stream nil t append-p))
      (delete-file truename))))

@ The file tangler operates by writing out the tangled code to a Lisp source
file and then invoking the file compiler on that file.

@l
(defun tangle-file (input-file &rest args &key
                    output-file
                    (verbose *compile-verbose*)
                    (print *compile-print*)
                    (external-format :default) &allow-other-keys &aux
                    (lisp-file (merge-pathnames (make-pathname :type "lisp")
                                                input-file)))
  (declare (ignore output-file print))
  (when verbose (format t "~&; tangling WEB from ~S~%" input-file))
  @<Initialize global variables@>
  (with-open-file (input input-file
                   :direction :input
                   :external-format external-format)
    (with-open-file (lisp lisp-file
                     :direction :output
                     :if-exists :supersede
                     :external-format external-format)
      (format lisp ";;;; TANGLED OUTPUT FROM WEB ~S.  DO NOT EDIT." input-file)
      (dolist (form (tangle (read-code-parts input t)))
        (pprint form lisp))))
  (apply #'compile-file lisp-file args))

@ Now that we've covered the high-level interfaces, we'll drop down to
the lower levels, beginning with the reader.

@*Reading. We recognize five distinct modes, or contexts, for reading.
Limbo mode is for \TeX\ text that proceeds the first section in a file.
\TeX\ mode is used for reading the commentary that begins a section.
Lisp mode is used for reading the code part of a section, and inner-Lisp
mode is for reading Lisp forms that are embedded within \TeX\ material.
Finally, restricted mode is used for reading material in section names
and a few other places.

Note that we do not support the `middle' part of a section that the
original \WEB\ and \CWEB\ used for macro definitions and the like;
those features are simply unnecessary with Lisp.

@l
(defparameter *modes* '(:limbo :TeX :lisp :inner-lisp :restricted))
(deftype mode () `(member ,@*modes*))

@ We use seperate readtables for each mode, which are accessed via
|readtable-for-mode|.

@l
(defvar *readtables*
  (loop for mode in *modes*
        collect (cons mode (copy-readtable nil))))

(defun readtable-for-mode (mode)
  (declare (type mode mode))
  (cdr (assoc mode *readtables*)))

@ The following macro is just a bit of syntactic sugar for executing the
given forms with |*readtable*| bound appropriately for the given mode.

@l
(defmacro with-mode (mode &body body)
  `(let ((*readtable* (readtable-for-mode ,mode)))
     ,@body))

@ We sometimes need to manually detect {\sc EOF}. In such cases, we use an
object that is (almost) guaranteed never to be returned by |read| as the
|eof-value| argument to the reader functions.

@l
(defvar *eof* (make-symbol "EOF"))
(defun eof-p (char) (eq char *eof*))

@ \TeX\ mode material, such as commentary, section names, \etc. is
accumulated using the following function, which simply reads from the given
stream until either {\sc EOF}, or a {\it control character\/} (defined
below) is encountered. The caller should then invoke |read| on the stream,
whereby the appropriate reader macro will pick up the object whose printed
representation follows.

A {\it control character\/} is normally one of \.{@@} or \v, but in
restricted mode and text in limbo, the latter is not recognized as such.

@l
(defun snarf-until-control-char (stream &optional restricted &aux
                                 (control-chars
                                  (if restricted '(#\@) '(#\@ #\|))))
  (with-output-to-string (string)
    (loop for char = (peek-char nil stream nil *eof* nil)
          until (or (eof-p char) (member char control-chars))
            do (write-char (read-char stream) string))))

@ In \TeX\ mode, we allow embedded Lisp code to be surrounded by \pb, where
it is read in inner-Lisp mode, which is almost, but not quite, the same as
Lisp mode.

@l
(defun read-inner-lisp (stream char)
  (with-mode :inner-lisp
    (read-delimited-list char stream t)))

(set-macro-character #\| #'read-inner-lisp nil (readtable-for-mode :TeX))

@ The call to |read-delimited-list| in |read-inner-lisp| will only stop at
the closing \v\ if we set it to be a terminating macro character,
overriding its usual Lisp meaning as an escape character. The following
makes it an error to use \v\ in inner-Lisp mode.

@l
(set-macro-character #\| (get-macro-character #\) nil)
                     nil (readtable-for-mode :inner-lisp))

@ We make |#\@| a non-terminating dispatching macro character in every
mode, and define some convenience routines for retrieving and setting the
reader macro functions that implement the control codes.

@l
(dolist (mode *modes*)
  ;; The CL standard does not say that calling MAKE-DISPATCH-MACRO-CHARACTER
  ;; on a character that's already a dispatching macro character is supposed
  ;; to signal an error, but SBCL does so; hence the IGNORE-ERRORS.
  (ignore-errors
    (make-dispatch-macro-character #\@ t (readtable-for-mode mode))))

(defun get-control-code (sub-char mode)
  (get-dispatch-macro-character #\@ sub-char (readtable-for-mode mode)))

(defun set-control-code (sub-char function &optional (modes *modes*))
  (dolist (mode modes)
    (set-dispatch-macro-character #\@ sub-char function
                                  (readtable-for-mode mode))))

@ The control code \.{@@@@} yields the string `\.{"@@"}' in all modes.
However, since |#\@| is a {\it non-terminating\/} macro character, you
don't usually need to use this control code in Lisp mode.

@l
(set-control-code #\@ (lambda (stream sub-char arg)
                        (declare (ignore stream arg))
                        (string sub-char)))

@ Sections are introduced by the two section-starting control codes, \.{@@ }
and~\.{@@*}, which differ only in the way they are output during weaving.
The reader macro functions that implement these control codes return an
instance of the appropriate section class.

@l
(defun start-section-reader (stream sub-char arg)
  (declare (ignore stream arg))
  (make-instance (ecase sub-char
                   (#\Space 'section)
                   (#\* 'starred-section))))

(dolist (sub-char '(#\Space #\*))
  (set-control-code sub-char #'start-section-reader '(:limbo :TeX :lisp)))

@ The control codes \.{@@l} and ~\.{@@p} (where `l' is for `Lisp' and `p'
is for `Program'---both control codes do the same thing) begin the code
part of an unnamed section. They are recognized only in \TeX\ mode---every
section must begin with a commentary, even if it is empty.

The control code \.{@@e} (`e' for `evaluate') is similar to \.{@@l} in that
it begins the code part of an unnamed section, but every form in that part
is evaluated at read-time {\it in addition to\/} being tangled and therefore
evaluated at run-time and possibly compile-time, too. Sections containing
evaluated code-parts should be used only for establishing state that is
needed by the reader: package definitions, structure definitions that are
used with the \.{#S} reader macro, \etc.

@l
(defstruct (start-code (:constructor make-start-code (evalp &optional name)))
  evalp name)

(defun start-code-reader (stream sub-char arg)
  (declare (ignore stream arg))
  (make-start-code (ecase sub-char
                     ((#\L #\P) nil)
                     (#\E t))))

(dolist (sub-char '(#\l #\p #\e))
  (set-control-code sub-char #'start-code-reader '(:TeX)))

@ Several control codes, including \.{@@<}, consist of restricted \TeX\ text
that extends to the matching \.{@@>}. Such text is known as {\it control text}.
During weaving, control text will be re-scanned to pick up inner-Lisp-mode
material, but during tangling we treat it as a simple string.

@l
(defvar *end-control-text* (make-symbol "@>"))
(set-control-code #\> (constantly *end-control-text*) '(:restricted))

(defun read-control-text (stream)
  (with-mode :restricted
    (apply #'concatenate 'string
           (loop for text = (snarf-until-control-char stream t)
                 as x = (read-preserving-whitespace stream t nil t)
                 collect text
                 until (eq x *end-control-text*) collect x))))

@ The control code \.{@@<} introduces a section name, which extends to the
closing \.{@@>}. Its meaning is context-dependent.

In \TeX\ mode, a name must be followed by \.{=}, in which case it indicates
that the name should be attached to the current section and begins the
code part of the section.

In Lisp and inner-Lisp modes, a name is taken to refer to the section so
named. During tangling, such references in Lisp mode will be replaced with
the code defined for that section. References in inner-Lisp mode are used
only during weaving.

@l
(defun make-section-name-reader (definition-allowed-p)
  (lambda (stream sub-char arg)
    (declare (ignore sub-char arg))
    (let* ((name (read-control-text stream))
           (definition-p (eql (peek-char nil stream nil nil t) #\=)))
      (if definition-p
          (if definition-allowed-p
              (progn (read-char stream) (make-start-code nil name))
              @<Signal an error about section definition in Lisp mode@>)
          (if definition-allowed-p
               @<Signal an error about section name use in \TeX\ mode@>
               (find-section name))))))

(set-control-code #\< (make-section-name-reader t) '(:TeX))
(set-control-code #\< (make-section-name-reader nil) '(:lisp :inner-lisp))

@ @<Signal an error about section definition in Lisp mode@>=
(restart-case
    (error "Can't define a named section in Lisp mode: ~A" name)
  (use-section ()
    :report "Don't define the section, just use it."
    (find-section name)))

@ @<Signal an error about section name use in \TeX\ mode@>=
(restart-case
    (error "Can't use a section name in TeX mode: ~A" name)
  (name-section ()
    :report "Name the current section and start the code part."
    (make-start-code nil name))
  (cite-section ()
    :report "Assume the section is just being cited."
    (find-section name)))

@ We come now to the heart of the \WEB\ parser. This function is a
tiny state machine that models the global syntax of a \WEB\ file.
(We can't just use reader macros since sections and their parts lack
explicit closing delimiters.) It returns a list of |section| objects.

@l
(defun read-sections (stream)
  (flet ((finish-section (section commentary code)
           (setf (section-commentary section) (nreverse commentary))
           (setf (section-code section) (nreverse code))
           section))
    (prog (form commentary code section sections)
     limbo
      (setq section (make-instance 'limbo-section))
      @<Accumulate limbo text in |commentary|@>
     commentary
      (push (finish-section section commentary code) sections)
      @<Initialize section variables@>
      @<Accumulate \TeX-mode material in |commentary|@>
     lisp
      @<Accumulate Lisp-mode material in |code|@>
     eof
      (push (finish-section section commentary code) sections)
      (return (nreverse sections)))))

@ Limbo text is \TeX\ text that proceeds the first section marker. We treat
it as commentary for a special section with no code. It can only end with
{\sc EOF} or the start of a regular section. Note that inner-Lisp material
is not allowed in limbo text: \v\ is not recognized as a control character
by |snarf-until-control-char| when its second argument is true.

@<Accumulate limbo text in |commentary|@>=
(with-mode :limbo
  (loop
    (push (snarf-until-control-char stream t) commentary)
    (setq form (read stream nil *eof* nil))
    (cond ((eof-p form) (go eof))
          ((typep form 'section) (go commentary))
          (t (push form commentary)))))

@ @<Initialize section variables@>=
(check-type form section)
(setq section form
      commentary '()
      code '())

@ The commentary part that begins a section consists of \TeX\ text and
inner-Lisp material surrounded by \pb. It is terminated by either the start
of a new section, the beginning of the code part, or {\sc EOF}. If a code
part is detected, we also set the name of the current section, which may be
|nil|.

@<Accumulate \TeX-mode material in |commentary|@>=
(with-mode :TeX
  (loop
    (push (snarf-until-control-char stream) commentary)
    (setq form (read stream nil *eof* nil))
    (cond ((eof-p form) (go eof))
          ((typep form 'section) (go commentary))
          ((start-code-p form)
           (setf (section-name section) (start-code-name form))
           (go lisp))
          (t (push form commentary)))))

@ The code part of a section consists of zero or more Lisp forms and is
terminated by either {\sc EOF} or the start of a new section. If the code
part was begun by a \.{@@e} control code, we evaluate the code forms as we
read them.

@<Accumulate Lisp-mode material in |code|@>=
(with-mode :lisp
  (let ((evalp (start-code-evalp form)))
    (loop
      (setq form (read stream nil *eof* nil))
      (cond ((eof-p form) (go eof))
            ((typep form 'section) (go commentary))
            ((start-code-p form)
             (error "Can't start a section with a code part"))
            (t (when evalp (eval form))
               (push form code))))))
