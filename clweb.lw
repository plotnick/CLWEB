% -*- Mode: Lisp -*-
\def\pb{\.{|...|}}
\def\v{\.{\char'174}} % vertical bar (|) in typewriter font

@ @e
(defpackage "COMMON-LISP-WEB"
  (:nicknames "CLWEB")
  (:use "COMMON-LISP")
  (:export "TANGLE-FILE" "LOAD-WEB" "WEAVE"))
(in-package "CLWEB")

@*Tangling \& weaving. The two primary operations that a literate programming
system makes available are {\it tangling\/} and {\/weaving\/}. The former
creates a machine-readable output file from a \WEB, while the latter prepares
the \WEB\ for formatting using \TeX\ or some other formatting engine.

There are three interface functions defined by this system: |tangle-file|,
|load-web|, and |weave|. The first is analogous to |compile-file|: given
an input file containing \WEB\ source, it produces a compiled output file
that can subsequently be loaded into a Lisp image with |load|. The function
|load-web| is analogous to |load|, but again accepts \WEB\ as input
instead of ordinary Lisp source. And finally, |weave| takes a \WEB\ as
input and generates a \TeX\ source file containing the commentary parts
of each section together with pretty-printed code parts.

@ The fundamental unit of a \WEB\ is the {\it section}, which consists
essentially of two parts, either of which may be null: a commentary part
and a code part. Every section is automatically assigned a number,
and each section is either {\it named\/} or {\it unnamed\/}. The code parts
of named sections may be included in those of another (named or unnamed)
section via \.{@@<$ldots$@@>} commands, while unnamed sections are output
or evaluated in the order in which they appear in the \WEB\ source file.

@l
(defparameter *section-number* 0)

(defclass section ()
  ((number :reader section-number
           :initarg :number
           :initform (incf *section-number*))
   (commentary :accessor section-commentary :initarg :commentary)
   (name :accessor section-name :initarg :name)
   (code :accessor section-code :initarg :code)
   (used-by :accessor used-by :initarg :used-by))
  (:default-initargs :commentary nil :name nil :code nil :used-by nil))

(defclass limbo-section (section)
  ()
  (:default-initargs :name (list (make-symbol "LIMBO"))))

(defclass starred-section (section)
  ())

@ @<Initialize global variables@>=
(setq *section-number* 0)

@ The code for named sections is stored in a binary search tree whose keys
are the section names (possibly abbreviated, as discussed below), and whose
values are the code to be substituted in place of a reference to the section
so named.

@l
(defclass binary-search-tree ()
  ((root :accessor root :initarg :root)
   (predicate :reader predicate :initarg :predicate)
   (node-class :reader node-class :initarg :node-class))
  (:default-initargs :root nil :predicate #'<))

(defclass binary-search-tree-node ()
  ((key :accessor node-key :initarg :key)
   (value :accessor node-value :initarg :value)
   (left-child :accessor left-child :initarg :left)
   (right-child :accessor right-child :initarg :right))
  (:default-initargs :key nil :value nil :left nil :right nil))

@ The only interface we need to the {\sc BST} is the following routine,
which attempts to locate the node in |tree| with key |item|. If it is not
already present, a new node is created with that key. The |predicate|
argument should be a designator for a function of two arguments that is
used to compare the keys of the nodes in the tree.

Two values are returned: the node for the given key, and a boolean
representing whether the key was already in the tree or not.

@l
(defmethod find-or-insert (item (tree binary-search-tree) &key
                           (test #'eql) &aux
                           (predicate (predicate tree)))
  (flet ((lessp (item node) (funcall predicate item (node-key node)))
         (samep (item node) (funcall test item (node-key node))))
    (do ((parent nil node)
         (node (root tree) (if (lessp item node)
                               (left-child node)
                               (right-child node))))
        ((or (null node) (samep item node))
         (if node
             (values node t)
             (let ((node (make-instance (node-class tree) :key item)))
               (if (null parent)
                   (setf (root tree) node)
                   (if (lessp item parent)
                       (setf (left-child parent) node)
                       (setf (right-child parent) node)))
               (values node nil)))))))

@ It's important to keep in mind that named sections can be defined
piecemeal, with the code spread out over several physical sections. We
might think of a full named section as a sort of `virtual' section, which
consists of a name and some code, but lacks, for instance, a section number
or commentary.

And that's what we store in the {\sc BST}: nodes that look like (but are not)
sections that have only names and code.

@l
(defclass named-section (binary-search-tree-node)
  ((name :accessor node-key
         :accessor section-name
         :initarg :key
         :initarg :name)
   (code :accessor node-value
         :accessor section-code
         :initarg :value
         :initarg :code)))

(defparameter *named-sections*
  (make-instance 'binary-search-tree
                 :predicate #'string<
                 :node-class 'named-section))

(defun flatten-name (name)
  (apply #'concatenate 'string
         (mapcar (lambda (x) (if (atom x) (string x) (flatten-name x))) name)))

(defun define-section (name forms &aux (name (flatten-name name)))
  (multiple-value-bind (node present-p)
      (find-or-insert name *named-sections* :test #'string=)
    (setf (node-value node) (if present-p
                                (nconc (node-value node) forms)
                                forms))))

(defun find-section (name &aux (name (flatten-name name)))
  (find-or-insert name *named-sections* :test #'string=))

@ @<Initialize global variables@>=
(setf (root *named-sections*) nil)

@ Tangling involves recursively replacing each reference to a named section
with the code accumulated for that section. The function |tangle-1| expands
one level of such references, returning the possibly-expanded form, and a
boolean representing whether or not any expansions were actually performed.

Note that this is a splicing operation, not a simple replacement: if
|@<foo@>\='(x y)|, then |(tangle-1 '(a @<foo@> b))|$\rarrow$|(a x y b)|,~|t|.

@l
(defun tangle-1 (form)
  (cond ((atom form) (values form nil))
        ((typep (car form) 'named-section)
         (values (append (section-code (car form)) (tangle-1 (cdr form)))
                 t))
        (t (multiple-value-bind (a car-expanded-p) (tangle-1 (car form))
             (multiple-value-bind (d cdr-expanded-p) (tangle-1 (cdr form))
               (values (if (and (eql a (car form)) (eql d (cdr form)))
                           form
                           (cons a d))
                       (or car-expanded-p cdr-expanded-p)))))))

@ |tangle| repeatedly calls |tangle-1| on |form| until it can no longer be
expanded. Like |tangle-1|, it returns the possibly-expanded form and an
`expanded' flag.

@l
(defun tangle (form)
  (labels ((expand (form expanded)
             (multiple-value-bind (new-form newly-expanded-p)
                 (tangle-1 form)
               (if newly-expanded-p
                   (expand new-form t)
                   (values new-form expanded)))))
    (expand form nil)))

@ Both of the high-level tangling routines use the following function,
which loops over the sections read from the given stream one at a time,
stores the code for the named sections as a side-effect, and returns a list
of Lisp forms from the code parts of the unnamed sections.

@l
(defun unnamed-section-code (stream)
  (loop for section in (read-sections stream)
        if (section-name section)
          do (define-section (section-name section) (section-code section))
        else
          append (section-code section)))

@ We're now ready for the high-level tangler interface. We begin with
|load-web|, which uses a helper function, |load-web-from-stream|, so
that it can handle input from a file or an arbitrary stream. The logic
is straightfoward: loop over the tangled forms read from the stream,
evaluating each one in turn.

Note that like |load|, we bind |*readtable*| and |*package*| to their
current values, so that assignments to those variables in the \WEB\ code
will not effect the calling environment.

@l
(defun load-web-from-stream (stream verbose print)
  (when verbose (format t "~&; loading WEB from ~S~%" (pathname stream)))
  @<Initialize global variables@>
  (let ((*readtable* *readtable*)
        (*package* *package*))
    (dolist (form (tangle (unnamed-section-code stream)))
      (if print
          (let ((results (multiple-value-list (eval form))))
            (format t "~&; ~{~S~^, ~}~%" results))
          (eval form)))))

(defun load-web (filespec &key
                 (verbose *load-verbose*)
                 (print *load-print*)
                 (if-does-not-exist t)
                 (external-format :default))
  (if (streamp filespec)
      (load-web-from-stream filespec verbose print)
      (with-open-file (stream filespec
                       :direction :input
                       :external-format external-format
                       :if-does-not-exist (if if-does-not-exist :error nil))
        (load-web-from-stream stream verbose print))))

@ The file tangler operates by writing out the tangled code to a Lisp source
file, and then invoking the file compiler on that file.

@l
(defun tangle-file (input-file &rest args &key
                    output-file
                    (verbose *compile-verbose*)
                    (print *compile-print*)
                    (external-format :default) &allow-other-keys &aux
                    (lisp-file (merge-pathnames (make-pathname :type "lisp")
                                                input-file)))
  (declare (ignore output-file print))
  (when verbose (format t "~&; tangling WEB from ~S~%" input-file))
  @<Initialize global variables@>
  (with-open-file (input input-file
                   :direction :input
                   :external-format external-format)
    (with-open-file (lisp lisp-file
                     :direction :output
                     :if-exists :supersede
                     :external-format external-format)
      (format lisp ";;;; TANGLED OUTPUT FROM WEB ~S.  DO NOT EDIT." input-file)
      (dolist (form (tangle (unnamed-section-code input)))
        (pprint form lisp))))
  (apply #'compile-file lisp-file args))

@ Now that we've covered the high-level interfaces, we'll drop down to
the lower levels, beginning with the reader.

@*Reading. We recognize five distinct modes, or contexts, for reading.
Limbo mode is for \TeX\ text that proceeds the first section in a file.
\TeX\ mode is used for reading the commentary that begins a section.
Lisp mode is used for reading the code part of a section, and inner-Lisp
mode is for reading Lisp forms that are embedded within \TeX\ material.
Finally, restricted mode is used for reading material in section names
and a few other places.

Note that we do not support the `middle' part of a section that the
original \WEB\ and \CWEB\ used for macro definitions and the like;
those features are simply unnecessary with Lisp.

@l
(defparameter *modes* '(:limbo :TeX :lisp :inner-lisp :restricted))
(deftype mode () `(member ,@*modes*))

@ We use seperate readtables for each mode, which are accessed via
|readtable-for-mode|.

@l
(defvar *readtables*
  (loop for mode in *modes*
        collect (cons mode (copy-readtable nil))))

(defun readtable-for-mode (mode)
  (declare (type mode mode))
  (cdr (assoc mode *readtables*)))

@ The following macro is just a bit of syntactic sugar for executing the
given forms with |*readtable*| bound appropriately for the given mode.

@l
(defmacro with-mode (mode &body body)
  `(let ((*readtable* (readtable-for-mode ,mode)))
     ,@body))

@ We sometimes need to manually detect {\sc EOF}. In such cases, we use an
object that is (almost) guaranteed never to be returned by |read| as the
|eof-value| argument to the reader functions.

@l
(defvar *eof* (make-symbol "EOF"))
(defun eof-p (char) (eq char *eof*))

@ \TeX\ mode material, such as commentary, section names, \etc. is
accumulated using the following function, which simply reads from the given
stream until either {\sc EOF}, or a {\it control character\/} (defined
below) is encountered. The caller should then invoke |read| on the stream,
whereby the appropriate reader macro will pick up the object whose printed
representation follows.

A {\it control character\/} is normally one of \.{@@} or \v, but in limbo
mode, the latter is not recognized as such.

@l
(defun snarf-until-control-char (stream &optional limbo &aux
                                 (control-chars (if limbo '(#\@) '(#\@ #\|))))
  (with-output-to-string (string)
    (loop for char = (peek-char nil stream nil *eof* nil)
          until (or (eof-p char) (member char control-chars))
            do (write-char (read-char stream) string))))

@ In \TeX\ mode, we allow embedded Lisp code to be surrounded by
\pb, where it is read in inner-Lisp mode, which is almost, but
not quite, the same as Lisp mode.

@l
(defun read-inner-lisp (stream char)
  (with-mode :inner-lisp
    (read-delimited-list char stream t)))

(set-macro-character #\| #'read-inner-lisp nil (readtable-for-mode :TeX))
(set-macro-character #\| #'read-inner-lisp nil (readtable-for-mode :restricted))

@ The call to |read-delimited-list| in |read-inner-lisp| will only stop at
the closing \v\ if we set it to be a terminating macro character,
overriding its usual Lisp meaning as an escape character. The following
makes it an error to use \v\ in inner-Lisp mode.

@l
(set-macro-character #\| (get-macro-character #\) nil)
                     nil (readtable-for-mode :inner-lisp))

@ We make |#\@| a non-terminating dispatching macro character in every
mode, and define some convenience routines for retrieving and setting the
reader macro functions that implement the control codes.

@l
(dolist (mode *modes*)
  ;; The CL standard does not say that calling MAKE-DISPATCH-MACRO-CHARACTER
  ;; on a character that's already a dispatching macro character is supposed
  ;; to signal an error, but SBCL does so; hence the IGNORE-ERRORS.
  (ignore-errors
    (make-dispatch-macro-character #\@ t (readtable-for-mode mode))))

(defun get-control-code (sub-char mode)
  (get-dispatch-macro-character #\@ sub-char (readtable-for-mode mode)))

(defun set-control-code (sub-char function &optional (modes *modes*))
  (dolist (mode modes)
    (set-dispatch-macro-character #\@ sub-char function
                                  (readtable-for-mode mode))))

@ The control code \.{@@@@} yields the string `\.{"@@"}' in all modes.
However, since |#\@| is a {\it non-terminating\/} macro character, you
don't usually need to use this control code in Lisp mode.

@l
(set-control-code #\@ (lambda (stream sub-char arg)
                        (declare (ignore stream arg))
                        (string sub-char)))

@ Sections are introduced by the two section-starting control codes, \.{@@ }
and~\.{@@*}, which differ only in the way they are output during weaving.
The reader macro functions that implement these control codes return an
instance of the appropriate section class.

% We might extend this with the prefix argument if we decide to support that.

@l
(defun start-section-reader (section-class)
  (lambda (stream sub-char arg)
    (declare (ignore stream sub-char arg))
    (make-instance section-class)))

(set-control-code #\Space (start-section-reader 'section) '(:limbo :TeX :lisp))
(set-control-code #\* (start-section-reader 'starred-section) '(:limbo :TeX :lisp))

@ The control codes \.{@@l} and ~\.{@@p} (where `l' is for `Lisp' and `p'
is for `Program'---both control codes do the same thing) begin the code
part of an unnamed section. They are recognized only in \TeX\ mode---every
section must begin with a commentary, even if it is empty.

The control code \.{@@e} (`e' for `evaluate') is similar to \.{@@l} in that
it begins the code part of an unnamed section, but every form in that part
is evaluated at read-time {\it in addition to\/} being tangled and therefore
evaluated at run-time and possibly compile-time, too. Sections containing
evaluated code-parts should be used only for establishing state that is
needed by the reader: package definitions, structure definitions that are
used with the \.{#S} reader macro, \etc.

@l
(defstruct (start-code (:constructor make-start-code (evalp &optional name)))
  evalp name)

(defun start-code-reader (evalp)
  (lambda (stream sub-char arg)
    (declare (ignore stream sub-char arg))
    (make-start-code evalp)))

(set-control-code #\l (start-code-reader nil) '(:TeX))
(set-control-code #\p (start-code-reader nil) '(:TeX))
(set-control-code #\e (start-code-reader t) '(:TeX))

@ Several control codes, including \.{@@<}, consist of restricted \TeX\ text
that extends to the matching \.{@@>}. The following routine reads such text.
% FIXME: Explain about the list that's returned.

@l
(defvar *end-control-text* (make-symbol "@>"))

(set-control-code #\> (constantly *end-control-text*) '(:restricted))

(defun read-control-text (stream)
  (with-mode :restricted
    (let ((text '()))
      (loop
        (push (snarf-until-control-char stream) text)
        (let ((x (read-preserving-whitespace stream t nil t)))
          (if (eq x *end-control-text*)
              (return (nreverse text))
              (push x text)))))))

@ The control code \.{@@<} introduces a section name, which extends to the
closing \.{@@>}. Its meaning is context-dependent.

In \TeX\ mode, it must be followed by \.{=}, in which case it indicates
that the name should be attached to the current section, and begins the
code part of the section.

@l
(set-control-code #\<
                  (lambda (stream sub-char arg)
                    (declare (ignore sub-char arg))
                    (let* ((name (read-control-text stream))
                           (next-char (peek-char nil stream nil *eof* t)))
                      (cond ((eql #\= next-char)
                             (read-char stream)
                             (make-start-code nil name))
                            (t
                             ;; There's no reason not to have a restart here
                             ;; that takes the reference to be in inner-Lisp
                             ;; mode.
                             (error "Can't use section name in TeX mode.")))))
                  '(:TeX))

@ In Lisp and inner-Lisp modes, a name is taken to refer to the section so
named.  During tangling, such references in Lisp mode will be replaced with
the code defined for that section. References in inner-Lisp mode are used
only during weaving.

@l
(set-control-code #\<
                  (lambda (stream sub-char arg)
                    (declare (ignore sub-char arg))
                    (let* ((name (read-control-text stream))
                           (next-char (peek-char nil stream nil *eof* t)))
                      (cond ((eql #\= next-char)
                             ;; There should be a restart here that simply
                             ;; ignores the #\=.
                             (error "Can't define a named section in code."))
                            (t (find-section name)))))
                  '(:lisp :inner-lisp))

@ We now come to the heart of the \WEB\ parser. This function is a
tiny state machine that models the global syntax of a \WEB\ file.
(We can't just use reader macros since sections and their parts lack
explicit closing delimiters.) It returns a list of |section| objects.

@l
(defun read-sections (stream)
  (flet ((finish-section (section commentary code)
           (setf (section-commentary section) (nreverse commentary))
           (setf (section-code section) (nreverse code))
           section))
    (prog (form commentary code section sections)
     limbo
      (setq section (make-instance 'limbo-section))
      @<Accumulate limbo text in |commentary|@>
     commentary
      (push (finish-section section commentary code) sections)
      @<Initialize section variables@>
      @<Accumulate \TeX-mode material in |commentary|@>
     lisp
      @<Accumulate Lisp-mode material in |code|@>
     eof
      (push (finish-section section commentary code) sections)
      (return (nreverse sections)))))

@ Limbo text is \TeX\ text that proceeds the first section marker. We treat
it as commentary for a special section with no code. It can only end with
{\sc EOF} or the start of a regular section. Note that inner-Lisp material
is not allowed in limbo text: \v\ is not recognized as a control character
by |snarf-until-control-char| when its second argument is true.

@<Accumulate limbo text in |commentary|@>=
(with-mode :limbo
  (loop
    (push (snarf-until-control-char stream t) commentary)
    (setq form (read stream nil *eof* nil))
    (cond ((eof-p form) (go eof))
          ((typep form 'section) (go commentary))
          (t (push form commentary)))))

@ @<Initialize section variables@>=
(check-type form section)
(setq section form
      commentary '()
      code '())

@ The commentary part that begins a section consists of \TeX\ text and
inner-Lisp material surrounded by \pb. It is terminated by either the start
of a new section, the beginning of the code part, or {\sc EOF}. If a code
part is detected, we also set the name of the current section, which may be
|nil|.

@<Accumulate \TeX-mode material in |commentary|@>=
(with-mode :TeX
  (loop
    (push (snarf-until-control-char stream) commentary)
    (setq form (read stream nil *eof* nil))
    (cond ((eof-p form) (go eof))
          ((typep form 'section) (go commentary))
          ((start-code-p form)
           (setf (section-name section) (start-code-name form))
           (go lisp))
          (t (push form commentary)))))

@ The code part consists of zero or more Lisp forms and is terminated by
either {\sc EOF} or the start of a new section. If the code part was begun
by a \.{@@e} control code, we evaluate the code forms as we read them.

@<Accumulate Lisp-mode material in |code|@>=
(with-mode :lisp
  (let ((evalp (start-code-evalp form)))
    (loop
      (setq form (read stream nil *eof* nil))
      (cond ((eof-p form) (go eof))
            ((typep form 'section) (go commentary))
            ((start-code-p form)
             (error "Can't start a section with a code part"))
            (t (when evalp (eval form))
               (push form code))))))
