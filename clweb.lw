% CLWEB is a literate programming system for Common Lisp.
% It was inspired by CWEB by Silvio Levy and Donald E. Knuth, which was
% based on Knuth's original WEB system.

\def\pb{\.{|...|}} % program brackets
\def\v{\.{\char'174}} % vertical bar in typewriter font
\def\WEB{{\tt WEB}}
\def\CWEB{{\tt CWEB}}
\def\etc.{{\it \char`&c.}} % doesn't handle spacefactor
\def\metasyn#1{\leavevmode $\langle${\it #1}$\rangle$} % metasyntactic variable

@*Introduction. The two primary operations that a literate programming
system makes available are {\it tangling\/} and {\/weaving\/}. The former
creates a machine-readable output file from a \WEB, while the latter prepares
the \WEB\ for formatting using \TeX\ or some other formatting engine.

There are three interface functions defined by this system: |tangle-file|,
|load-web|, and |weave|. The first is analogous to |compile-file|: given
an input file containing \WEB\ source, it produces a compiled output file
that can subsequently be loaded into a Lisp image with |load|. The function
|load-web| is analogous to |load|, but again accepts \WEB\ as input
instead of ordinary Lisp source. And finally, |weave| takes a \WEB\ as
input and generates a \TeX\ source file containing the commentary parts
of each section together with pretty-printed code parts.

@ @e
(declaim (optimize (debug 3)))

(defpackage "COMMON-LISP-WEB"
  (:nicknames "CLWEB")
  (:use "COMMON-LISP")
  (:export "TANGLE-FILE" "LOAD-WEB" "LOAD-SECTIONS-FROM-TEMP-FILE" "WEAVE"))
(in-package "CLWEB")

@*Sections. The fundamental unit of a \WEB\ is the {\it section}, which
consists essentially of two parts, either of which may be null: a commentary
part and a code part. Every section is automatically assigned a number, and
each section is either {\it named\/} or {\it unnamed\/}. The code parts of
named sections may be included in those of another (named or unnamed)
section via \.{@@<$\ldots$@@>} commands, while unnamed sections are output
or evaluated in the order in which they appear in the \WEB\ source file.

@l
(defclass section ()
  ((number :accessor section-number)
   (commentary :accessor section-commentary :initarg :commentary)
   (name :accessor section-name :initarg :name)
   (code :accessor section-code :initarg :code)
   (used-by :accessor used-by :initarg :used-by))
  (:default-initargs :commentary nil :name nil :code nil :used-by nil))

(defclass limbo-section (section) ())

(defclass starred-section (section) ())

@ Whenever a section is created, we store it in the global |*sections*|
vector and set its number to its index therein. This is only used during
weaving, but it doesn't cost much even during tangling, since the section
instances themselves are around in any case.

@l
(defvar *sections* (make-array 128
                               :element-type 'section
                               :adjustable t
                               :fill-pointer 0))

(defun current-section ()
  (elt *sections* (1- (fill-pointer *sections*))))

(defmethod initialize-instance :after ((section section) &rest initargs &key)
  (declare (ignore initargs))
  (setf (section-number section) (vector-push-extend section *sections*)))

@ @<Initialize global variables@>=
(setf (fill-pointer *sections*) 0)

@ Named sections are stored in a binary search tree whose keys are the
section names and whose values are the code to be substituted in place of
a reference to the section so named. The reason for using a tree instead
of, say, a hash table is so that we can support abbreviations (see below).

@l
(defclass binary-search-tree ()
  ((key :accessor node-key :initarg :key)
   (value :accessor node-value :initarg :value)
   (left-child :accessor left-child :initarg :left)
   (right-child :accessor right-child :initarg :right))
  (:default-initargs :left nil :right nil))

@ The primary interface to the {\sc BST} is the following routine, which
attempts to locate the node with key |item| in the tree rooted at |root|.
If it is not already present and the |:insert-if-not-found| argument
is true, a new node is created with that key and added to the tree. The
arguments |predicate| and |test| should be designators for functions
of two arguments, both of which will be node keys. |predicate| should
return true iff its first argument precedes its second in the total
ordering used for the tree, and |test| should return true iff the two
keys are to be considered equivalent.

Two values are returned: the node with key |item| (or |nil| if no such node
was found and |:insert-if-not-found| is false), and a boolean representing
whether the key was already in the tree or not.

@l
(defgeneric find-or-insert (item root &key predicate test insert-if-not-found))

(defmethod find-or-insert (item (root binary-search-tree) &key
                           (predicate #'<) (test #'eql)
                           (insert-if-not-found t))
  (flet ((lessp (item node) (funcall predicate item (node-key node)))
         (samep (item node) (funcall test item (node-key node))))
    (do ((parent nil node)
         (node root (if (lessp item node)
                        (left-child node)
                        (right-child node))))
        ((or (null node) (samep item node))
         (if node
             (values node t)
             (if insert-if-not-found
                 @<Insert a new node with key |item| and return it@>
                 (values nil nil)))))))

@ @<Insert a new node...@>=
(let ((node (make-instance (class-of root) :key item)))
  (when parent
    (if (lessp item parent)
        (setf (left-child parent) node)
        (setf (right-child parent) node)))
  (values node nil))

@ It's important to keep in mind that named sections can be defined
piecemeal, with the code spread out over several physical sections. We
might think of a full named section as a sort of `virtual' section, which
consists of a name, the combined code parts of all of the physical sections
with that name, and the number of the first such section.

And that's what we store in the {\sc BST}: nodes that look like sections,
inasmuch as they have specialized |section-name|, |section-code|, and
|section-number| methods, but are not actually instances of the class
|section|.

@l
(defclass named-section (binary-search-tree)
  ((key :accessor section-name :initarg :name)
   (value :accessor section-code :initarg :code)
   (number :accessor section-number)
   (used-by :accessor used-by :initform '())
   (see-also :accessor see-also :initform '())))

@ Setting the code for a named section usually involves appending the given
forms to whatever forms were already defined for that section, which allows
piecemeal definition. However, sometimes we want to override that behavior
and have the new forms replace the old, such as during interactive
development.

@l
(defun set-named-section-code (section forms &optional (append-p t))
  (setf (section-code section)
        (if (and append-p (slot-boundp section 'value))
            (append (section-code section) forms)
            forms)))

@ When we look up a named section, either the name used to perform the
lookup, the name for the section in the tree, or both may be an abbreviation
of the full section name. Any prefix of the full name is allowed, followed
by `$\ldots$': e.g., \.{@@<foo...@@>} is an acceptable abbreviation for
either \.{@@<foo bar@@>} or \.{@@<foo baz@@>}. It is a correctable error if
a prefix is ambiguous.

@l
(defmethod find-or-insert (item (root named-section) &key
                           (predicate #'section-name-lessp)
                           (test #'section-name-equal)
                           (insert-if-not-found t))
  (multiple-value-bind (node present-p)
      (call-next-method item root
                        :predicate predicate
                        :test test
                        :insert-if-not-found insert-if-not-found)
    (if present-p
        (or @<Check for an ambiguous match, and raise an error in that case@>
            (values node t))
        (values node nil))))

@ @<Check for an ambiguous match...@>=
(dolist (child (list (left-child node) (right-child node)))
  (when child
    (multiple-value-bind (alt present-p)
        (call-next-method item child
                          :predicate predicate
                          :test test
                          :insert-if-not-found nil)
      (when present-p
        (restart-case
            (error "~<Ambiguous prefix <~A>: matches both <~A> and <~A>~:@>"
                   (list item (node-key node) (node-key alt)))
          (use-first-match ()
            :report "Use the first match."
            (return (values node t)))
          (use-alt-match ()
            :report "Use the alternate match."
            (return (values alt t))))))))

@ The named section tree is stored in the global variable |*named-sections*|,
which is reset before each tangling or weaving.

@l
(defvar *named-sections* nil)

@ @<Initialize global variables@>=
(setq *named-sections* nil)

@ The next routine is the primary interface to named sections: it looks up
a section by name, and creates a new one if no such section exists.

@l
(defun find-section (name)
  (if (null *named-sections*)
      (values (setq *named-sections* (make-instance 'named-section :name name))
              nil)
      (multiple-value-bind (section present-p)
          (find-or-insert name *named-sections*)
        (when present-p
          ;; Update the section name in case the new one is better.
          (setf (section-name section) name))
        (values section present-p))))

@ Section names are normalized by |squeeze|, which trims leading and
trailing whitespace, and replaces all runs of one or more whitespace
characters with a single space.

@l
(defparameter *whitespace*
  (coerce '(#\Space #\Tab #\Newline #\Linefeed #\Page #\Return) 'simple-string))

(defun whitespace-p (char) (find char *whitespace* :test #'char=))

(defun squeeze (string)
  (coerce @<Collect characters of |string|, squeezing whitespace@> 'simple-string))

@ @<Collect characters...@>=
(loop with squeezing = nil
      for char across (string-trim *whitespace* string)
      if (not squeezing)
        if (whitespace-p char) do (setq squeezing t) and collect #\Space
        else collect char
      else
        unless (whitespace-p char) do (setq squeezing nil) and collect char)

@ Here's a little utility routine that makes working with section names
easier. Given a name, it returns two values: |t| or~|nil| depending on
whether the name is a prefix or not, and the length of the non-`\.{...}'
segment of the name.

@l
(defun section-name-prefix-p (name)
  (let ((len (length name)))
    (if (string= (subseq name (max (- len 3) 0) len) "...")
        (values t (- len 3))
        (values nil len))))

@ Next we need some special comparison routines for section names that
handle abbreviations.

@l
(defun section-name-equal (name1 name2)
  (multiple-value-bind (prefix-1-p len1) (section-name-prefix-p name1)
    (multiple-value-bind (prefix-2-p len2) (section-name-prefix-p name2)
      (let ((end (min len1 len2)))
        (if (or prefix-1-p prefix-2-p)
            (string-equal name1 name2 :end1 end :end2 end)
            (string-equal name1 name2))))))

(defun section-name-lessp (name1 name2)
  (multiple-value-bind (prefix-1-p len1) (section-name-prefix-p name1)
    (declare (ignore prefix-1-p))
    (multiple-value-bind (prefix-2-p len2) (section-name-prefix-p name2)
      (declare (ignore prefix-2-p))
      (string-lessp name1 name2 :end1 len1 :end2 len2))))

@ We only actually update the name of a section in two cases: if the new
name is not an abbreviation but the old one was, or if they are both
abbreviations, but the new one is shorter. (We only need to compare against
the shortest available prefix, since we detect ambiguous matches.)

@l
(defmethod (setf section-name) :around (new-name (section named-section))
  (when new-name
    (multiple-value-bind (new-prefix-p new-len)
        (section-name-prefix-p new-name)
      (multiple-value-bind (old-prefix-p old-len)
          (section-name-prefix-p (section-name section))
        (if (or (and old-prefix-p (not new-prefix-p))
                (and old-prefix-p new-prefix-p (< new-len old-len)))
            (call-next-method)
            new-name)))))

@*Reading. We recognize five distinct modes, or contexts, for reading.
Limbo mode is for \TeX\ text that proceeds the first section in a file.
\TeX\ mode is used for reading the commentary that begins a section.
Lisp mode is used for reading the code part of a section, and inner-Lisp
mode is for reading Lisp forms that are embedded within \TeX\ material.
Finally, restricted mode is used for reading material in section names
and a few other places.

Note that we do not support the `middle' part of a section that the
original \WEB\ and \CWEB\ used for macro definitions and the like;
those features are simply unnecessary with Lisp.

@l
(eval-when (:compile-toplevel :load-toplevel :execute)
  (defparameter *modes* '(:limbo :TeX :lisp :inner-lisp :restricted)))
(deftype mode () `(member ,@*modes*))

@ We use seperate readtables for each mode, which are accessed via
|readtable-for-mode|. We add an extra readtable with key |nil| that
stores a virgin copy of the standard readtable.

@l
(defvar *readtables*
  (loop for mode in (append *modes* '(nil))
        collect (cons mode (copy-readtable nil))))

(defun readtable-for-mode (mode)
  (declare (type (or mode null) mode))
  (cdr (assoc mode *readtables*)))

@ The following macro is just a bit of syntactic sugar for executing the
given forms with |*readtable*| bound appropriately for the given mode.

@l
(defmacro with-mode (mode &body body)
  `(let ((*readtable* (readtable-for-mode ,mode)))
     ,@body))

@ It's basically impossible to automatically indent Common Lisp code correctly.
(This may be tendentious, but it seems to be true.) And so we don't try. What
we do, instead, is rely on the fact that the {\it input\/} is indented correctly,
and approximate that on output.

In order to do this {\it indentation tracking\/}, we need the ability to
reliably determine the current column number, or {\it character position},
of a stream. One could use Gray streams to do this, but we don't actually
need them; the built-in stream types suffice.

@ We'll define a {\it charpos stream\/} as an object that tracks the output
position of an underlying stream. Note that these aren't actual streams, and
can't be, without relying on an extension to Common Lisp like Gray streams.
But that doesn't matter, because what we'll actually be passing around is the
value of the |stream| slot, which {\it will\/} be a stream---we call these
{\it proxy streams}.

The current character position is retrieved with the GF |charpos|. It relies
the last stored charpos (stored in the |charpos| slot) and a buffer that
stores the characters input or output since the last call to |charpos|.

@l
(defclass charpos-stream ()
  ((charpos :initarg :charpos)
   (stream :accessor charpos-stream :initarg :stream))
  (:default-initargs :charpos 0))

(defgeneric charpos (stream))
(defgeneric get-charpos-stream-buffer (stream))

@ We need slightly different classes for input charpos streams and output
charpos streams. For tracking charpos on input streams, our proxy stream is
an echo stream that takes input from the supplied stream (the original value
of the |:stream| initarg), echoes the characters read to a fresh string
stream, which we'll use as our buffer.

@l
(defclass charpos-input-stream (charpos-stream) ())

(defmethod shared-initialize :around ((instance charpos-input-stream) slot-names
                                      &rest initargs &key stream)
  (apply #'call-next-method instance slot-names
         (subst (make-echo-stream stream
                                  (make-string-output-stream
                                   :element-type (stream-element-type stream)))
                stream initargs)))

(defmethod get-charpos-stream-buffer ((stream charpos-input-stream))
  (get-output-stream-string
   (echo-stream-output-stream (charpos-stream stream))))

@ For the output stream case, our proxy stream is a broadcast stream to the
given stream and a fresh string stream, again used as a buffer.

@l
(defclass charpos-output-stream (charpos-stream) ())

(defmethod shared-initialize :around ((instance charpos-output-stream) slot-names
                                      &rest initargs &key stream)
  (apply #'call-next-method instance slot-names
         (subst (make-broadcast-stream (make-string-output-stream
                                        :element-type (stream-element-type stream))
                                       stream)
                stream initargs)))

(defmethod get-charpos-stream-buffer ((stream charpos-output-stream))
  (get-output-stream-string
   (first (broadcast-stream-streams (charpos-stream stream)))))

@ Finding the actual character position is now straightforward, and the same
for both input and output streams.

@l
(defmethod charpos ((stream charpos-stream))
  (let* ((i 0)
         (newline (position #\Newline (get-charpos-stream-buffer stream)
                            :key (lambda (x) (incf i) x)
                            :test #'char=
                            :from-end t)))
    (setf (slot-value stream 'charpos)
          (if newline i (+ i (slot-value stream 'charpos))))))

@ Because we'll be passing around the proxy streams, we need to manually
maintain a mapping between them and their associated instances of
|charpos-stream|.

@l
(defvar *charpos-streams* (make-hash-table :test #'eq))

(defmethod initialize-instance :after ((instance charpos-stream)
                                       &rest initargs &key)
  (declare (ignore initargs))
  (setf (gethash (charpos-stream instance) *charpos-streams*) instance))

@ The top-level interface the consists of two functions: |stream-charpos|
retrieves the character position of the stream for which |stream| is a
proxy, and |release-charpos-stream| deletes the reference to the stream
maintained by the associated |charpos-stream| instance. (Note that if there
were a standardized way of creating weak hash tables, we wouldn't need to do
that.)

@l
(defun stream-charpos (stream)
  (charpos (or (gethash stream *charpos-streams*)
               (error "Not tracking charpos for ~S" stream))))

(defun release-charpos-stream (stream)
  (multiple-value-bind (charpos-stream present-p)
      (gethash stream *charpos-streams*)
    (cond (present-p (setf (charpos-stream charpos-stream) nil) ; release stream
                     (remhash stream *charpos-streams*))
          (t (warn "Not tracking charpos for ~S" stream)))))

@ Here are a few convenience methods for creating charpos streams. Note that
|input-stream| and |output-stream| are {\it stream designators\/}.

@l
(defun make-charpos-input-stream (input-stream &key (charpos 0))
  (make-instance 'charpos-input-stream
                 :stream (case input-stream
                           ((t) *terminal-io*)
                           ((nil) *standard-input*)
                           (otherwise input-stream))
                 :charpos charpos))

(defun make-charpos-output-stream (output-stream &key (charpos 0))
  (make-instance 'charpos-output-stream
                 :stream (case output-stream
                           ((t) *terminal-io*)
                           ((nil) *standard-output*)
                           (otherwise output-stream))
                 :charpos charpos))

@ And finally, a couple of macros that make using them easy and trouble-free.

@l
(defmacro with-charpos-input-stream ((var stream &key (charpos 0)) &body body)
  `(let ((,var (charpos-stream
                (make-charpos-input-stream ,stream :charpos ,charpos))))
     (unwind-protect (progn ,@body)
       (release-charpos-stream ,var))))

(defmacro with-charpos-output-stream ((var stream &key (charpos 0)) &body body)
  `(let ((,var (charpos-stream
                (make-charpos-output-stream ,stream :charpos ,charpos))))
     (unwind-protect (progn ,@body)
       (release-charpos-stream ,var))))

@ Sometimes we want to look more than one character ahead in a stream.
This macro lets us do so.

@l
(defmacro with-rewind-stream ((var stream) &body body
                              &aux (buffer (gensym)))
  `(let* ((,buffer (make-string-output-stream))
          (,var (make-echo-stream ,stream ,buffer)))
     (flet ((rewind ()
              (make-concatenated-stream
               (make-string-input-stream (get-output-stream-string ,buffer))
               ,stream)))
       ,@body)))

@ We frequently need an object to use as the |eof-value| argument to
|read|. It need not be a symbol; it need not even be an atom.

@l
(eval-when (:compile-toplevel :load-toplevel :execute)
  (defvar *eof* (make-symbol "EOF")))
(defun eof-p (x) (eq x *eof*))
;; This should be |`(eql ,*eof*)|, but SBCL doesn't like that.
(deftype eof () '(satisfies eof-p))

@ Next, we define a class of objects called {\it markers\/} that denote
abstract objects in source code. Some of these objects, such as newlines
and comments, are ones that would ordinarily be ignored by the reader.
Others, such as \.{()} and~\.{'}, are indistinguishable after reading from
other, semantically equivalent objects (here, |nil| and |quote|), but we
want to preserve the distinction for the purposes of output. In fact, nearly
every standard macro character in Common Lisp is `lossy', in the sense that
the original source code form can not be reliably recovered from the object
returned by |read|.

But during weaving, we want to more closely approximate the original source
code than would be possible using the standard reader. Markers are our
solution to this problem: we define reader macro functions for all of the
standard macro characters that return markers that let us reconstruct, to
varying degrees of accuracy, what was originally given in the source.

Aside from defining whatever slots are necessary for a given marker class,
markers may also be {\it bound\/} to a value, which will be used in place
of an occurrence of that marker when the containing form is tangled. If a
marker is bound---i.e., if |marker-boundp| returns non-nil when called
with it as an argument---then the tangler will call |marker-value| to
obtain the associated value. Otherwise, the marker will be silently dropped
from its containing form: this is useful, e.g., for newlines and comments.

@l
(defclass marker ()
  ((value :reader marker-value :initarg :value)))
(defun marker-p (x) (typep x 'marker))

(defgeneric marker-boundp (marker))
(defmethod marker-boundp ((marker marker))
  (slot-boundp marker 'value))

@ We also define |print-object| methods for all marker classes. These
methods are distinct from the pretty-printing routines used by the weaver,
and usually less precise, in that they don't try to approximate the original
source form. The idea of these methods to produce a printed reprsentation of
an object that is semantically equivalent to the one originally specified.

The simple method defined here suffices for many marker types: it simply
prints the marker's value if it is bound.

@l
(defmethod print-object ((obj marker) stream)
  (when (marker-boundp obj)
    (write (marker-value obj) :stream stream)))

@ Our first marker is for newlines, which we preserve for the purposes of
indentation. They are represented in code forms by an unbound marker, so
they will simply be dropped by the tangler.

Note that we don't set a macro character for |#\Newline| in inner-Lisp mode,
since indentation is completely ignored there.

@l
(defclass newline-marker (marker)
  ((indentation :accessor indentation :initarg :indentation))
  (:default-initargs :indentation nil))
(defun newline-p (obj) (typep obj 'newline-marker))

;(defvar *newline* (make-instance 'newline-marker))

(set-macro-character #\Newline
                     (lambda (stream char)
                       (declare (ignore stream char))
                       (make-instance 'newline-marker))
                     nil (readtable-for-mode :lisp))

@ The rest of the reader macro functions for standard macro characters are
defined in the order given in section~2.4 of the ANSI Common Lisp standard.
We override all of the standard macro characters except |#\)| and~|#\"|
(the former because the standard reader macro function just signals an
error, and the latter because we don't need markers for strings).

@ {\it Left-Parenthesis.} We have two kinds of markers that we use when
reading lists. First, we record the character positions of the first and
second elements of the list for indentation purposes. And second, we
maintain a distinction that the standard Lisp reader does not: between the
empty list and |nil|.

Note that we bind our empty-list marker to the value |'()| so that it's
preserved during tangling, and that like newlines, we only need one.

@l
(defclass empty-list-marker (marker) () (:default-initargs :value '()))
(defvar *empty-list* (make-instance 'empty-list-marker))

(defclass list-marker (marker)
  ((length :reader list-marker-length :initarg :length)
   (list :reader list-marker-list :initarg :list)
   (charpos :reader list-marker-charpos :initarg :charpos)))
(defun list-marker-p (obj) (typep obj 'list-marker))

(defclass consing-dot-marker (marker) ())
(defvar *consing-dot* (make-instance 'consing-dot-marker))

(defmethod marker-boundp ((marker list-marker)) t)
(defmethod marker-value ((marker list-marker))
  (do* ((list (list nil))
        (tail list)
        (marker-list (list-marker-list marker) (cdr marker-list))
        (x (car marker-list) (car marker-list)))
       ((endp marker-list) (cdr list))
    (cond ((eq x *consing-dot*)
           (rplacd tail
                   (dolist (x marker-list (error "Nothing after . in list"))
                     (cond ((and (marker-p x) (marker-boundp x))
                            (return (marker-value x)))
                           ((not (marker-p x))
                            (return x)))))
           (return (cdr list)))
          ((marker-p x)
           (when (marker-boundp x)
             (let ((obj (list (marker-value x))))
               (rplacd tail obj)
               (setq tail obj))))
          (t (let ((obj (list x)))
               (rplacd tail obj)
               (setq tail obj))))))

@ @l
(defun make-list-reader (next)
  (lambda (stream char)
    (if (char= (peek-char t stream t nil t) #\) )
        (progn (read-char stream t nil t) *empty-list*)
        (funcall next stream char))))

(set-macro-character #\( (make-list-reader (get-macro-character #\( nil))
                     nil (readtable-for-mode :inner-lisp))

@ When we're looking for a consing dot while reading a list, we'll need to know
if the character following a dot terminates the token or not. This function
answers that question, but {\it only approximately\/}---if the user has frobbed
the current readtable and has set non-standard characters to whitespace syntax,
{\it this routine will not yield the correct result}. There's unfortunately
nothing that we can do about it portably, since there's no way of determining
the syntax of a character or of obtaining a list of all the characters with a
given syntax.

@l
(defun token-delimiter-p (char)
  (or (whitespace-p char)
      (multiple-value-bind (function non-terminating-p)
          (get-macro-character char)
        (declare (ignore function))
        (not non-terminating-p))))

@ @l
(defun list-reader (stream char)
  (declare (ignore char))
  (loop with list = '()
        with charpos-list = '()
        for n from 0
        for first-char = (peek-char t stream t nil t)
        as charpos = (stream-charpos stream)
        until (char= first-char #\) )
        do (cond ((char= first-char #\.)
                  @<Read the next token...@>)
                 (t (let ((obj (multiple-value-list (read stream t nil t))))
                      (when obj
                        (push (car obj) list)
                        (push charpos charpos-list)))))
        finally
          (read-char stream t nil t)
          (return (make-instance 'list-marker
                                 :length n
                                 :list (nreverse list)
                                 :charpos (nreverse charpos-list)))))

(set-macro-character #\( (make-list-reader #'list-reader)
                     nil (readtable-for-mode :lisp))

@ @<Read the next token, which might be a consing dot@>=
(with-rewind-stream (r stream)
  (let ((next-char (read-char r t)))
    (cond ((token-delimiter-p next-char)
           (unless (or list *read-suppress*)
             (simple-reader-error stream "Nothing appears before . in list."))
           (push *consing-dot* list)
           (push charpos charpos-list))
          (t (rewind)
             (let ((obj (multiple-value-list (read r t nil t))))
               (when obj
                 (push (car obj) list)
                 (push charpos charpos-list)))))))

@ {\it Single-Quote.} Similarly, we want to preserve the distinction
between a form quoted with |#\'| and one quoted (for whatever reason) with
|quote|. We'll use this marker class for \.{\#'}, too, which is why it's a
little more general than one might think is needed.

@l
(defclass quote-marker (marker)
  ((form :reader quoted-form :initarg :form)
   (quote :reader quote-marker-quote :initarg :quote)))

(defmethod marker-boundp ((marker quote-marker)) t)
(defmethod marker-value ((marker quote-marker))
  (list (slot-value marker 'quote) (slot-value marker 'form)))

(defmethod print-object ((obj quote-marker) stream)
  (format stream "(~W ~W)" (quote-marker-quote obj) (quoted-form obj)))

(defun single-quote-reader (stream char)
  (declare (ignore char))
  (make-instance 'quote-marker :quote 'quote :form (read stream t nil t)))

(dolist (mode '(:lisp :inner-lisp))
  (set-macro-character #\' #'single-quote-reader nil (readtable-for-mode mode)))

@ {\it Semicolon.} Comments in Lisp code also need to be preserved for
output during weaving. We use a special slot for storing the text of the
comment, so that they can remain unbound and thus be stripped during
tangling.

@l
(defclass comment-marker (marker)
  ((text :reader comment-text :initarg :text)))

@ Usually, to read a comment we accumulate all of the characters starting
with the semicolon and ending just before the next newline, which we leave
for the newline reader to pick up. But as a special exception, if the
comment is empty (that is, consists solely of a single semicolon), the
newline is consumed, and we return zero values. This provides for
`soft-newlines'---that is, newlines in the source file that will not
appear in the output.

@l
(defun comment-reader (stream char)
  (if (char= (peek-char nil stream nil nil t) #\Newline)
      (progn (read-char stream t nil t) (values))
      (make-instance 'comment-marker :text @<Read characters up to...@>)))

(set-macro-character #\; #'comment-reader nil (readtable-for-mode :lisp))

@ @<Read characters up to, but not including, the next newline@>=
(with-output-to-string (s)
  (write-char char s) ; include the opening |#\;|
  (do ()
      ((char= (peek-char nil stream nil #\Newline t) #\Newline))
    (write-char (read-char stream t nil t) s)))

@ {\it Backquote\/} is hairy, and so we use a kludge to avoid implementing
the whole thing. Our reader macro functions for |#\`| and |#\,| do the absolute
minimum amount of processing necessary to be able to reconstruct the forms
that were read. Then, when the tangler asks for the |marker-value| of a
backquote marker, we reconstruct the source form using the pretty-printer,
and read it back in using the standard readtable. It's a sleazy trick, but
it works. (It's also the reason we need pretty-printing routines for all
these markers.)

Of course, we assume |read|-|print| equivalence, but that's not
unreasonable, since without it the file tangler won't work anyway.

@l
(defclass backquote-marker (marker)
  ((form :reader backq-form :initarg :form)))

(defmethod marker-boundp ((marker backquote-marker)) t)
(defmethod marker-value ((marker backquote-marker))
  (let ((*print-pretty* nil)
        (*print-readably* t)
        (*readtable* (readtable-for-mode nil)))
    (read-from-string (prin1-to-string marker))))

(defmethod print-object ((obj backquote-marker) stream)
  (format stream "`~W" (backq-form obj)))

(defun backquote-reader (stream char)
  (declare (ignore char))
  (make-instance 'backquote-marker :form (read stream t nil t)))

(dolist (mode '(:lisp :inner-lisp))
  (set-macro-character #\` #'backquote-reader nil (readtable-for-mode mode)))

@ {\it Comma\/} is really just part of the backquote-syntax, and so we're
after the same goal as above: reconstructing just enough of the original
source so that the reader can do what it would have done had we not been
here in the first place.

Note that comma markers are bound, but self-evaluating: they need to be
printed and re-read as part of a backquote form to retrieve their actual
value.

@l
(defclass comma-marker (marker)
  ((form :reader comma-form :initarg :form)
   (modifier :reader comma-modifier :initarg :modifier))
  (:default-initargs :modifier nil))

(defmethod marker-boundp ((marker comma-marker)) t)
(defmethod marker-value ((marker comma-marker)) marker)

(defmethod print-object ((obj comma-marker) stream)
  (format stream ",~@[~C~]~W" (comma-modifier obj) (comma-form obj)))

(defun comma-reader (stream char)
  (declare (ignore char))
  (case (peek-char nil stream t nil t)
    ((#\@ #\.) (make-instance 'comma-marker
                              :modifier (read-char stream)
                              :form (read stream t nil t)))
    (t (make-instance 'comma-marker :form (read stream t nil t)))))

(dolist (mode '(:lisp :inner-lisp))
  (set-macro-character #\, #'comma-reader nil (readtable-for-mode mode)))

@ {\it Sharpsign\/} is the all-purpose dumping ground for Common Lisp
reader macros. Because it's a dispatching macro character, we have to
handle each sub-char individually, and unfortunately we need to override
most of them. We'll handle them in the order given in section~2.4.8
of the CL standard.

Note that we don't actually need to define tangle-time pretty-printing
routines for any of these, as they all have values that can be printed
using the standard printer. Of course, later we'll define pretty-printing
routines for all of these in the weaver.

@ Some of the reader macro functions store some value related to the occurrence
of the macro character and then just invoke the reader macro function defined
in the standard readtable.

@l
(defun call-standard-sharpm-fun (stream sub-char arg)
  (funcall
   (get-dispatch-macro-character #\# sub-char (readtable-for-mode nil))
   stream sub-char arg))

@ And sometimes, we have to do the reading and parsing ourselves, which means
detecting errors. This condition class and associated signaling function allow
|format|-style error reporting.

@l
(define-condition simple-reader-error (reader-error simple-condition) ()
  (:report (lambda (condition stream)
             (format stream "~S on ~S:~%~?"
                     condition (stream-error-stream condition)
                     (simple-condition-format-control condition)
                     (simple-condition-format-arguments condition)))))

(defun simple-reader-error (stream control &rest args)
  (error 'simple-reader-error
         :stream stream
         :format-control control
         :format-arguments args))

@ Sharpsign single-quote is just like single-quote, except the form is
`quoted' with |function| instead of |quote|.

@l
(defclass function-marker (quote-marker) ())

(defun sharpsign-quote-reader (stream sub-char arg)
  (declare (ignore sub-char arg))
  (make-instance 'function-marker :quote 'function :form (read stream t nil t)))

(dolist (mode '(:lisp :inner-lisp))
  (set-dispatch-macro-character #\# #\' #'sharpsign-quote-reader ;
                                (readtable-for-mode mode)))

@ Sharpsign left-parenthesis and sharpsign asterisk create simple vectors and
simple bit vectors, respectively. The feature that we care about preserving is
the length specification and consequent possible abbreviation.

@l
(defclass simple-vector-marker (marker)
  ((length :initarg :length)
   (elements :initarg :elements)
   (element-type :initarg :element-type))
  (:default-initargs :element-type t))

(defmethod marker-boundp ((marker simple-vector-marker)) t)
(defmethod marker-value ((marker simple-vector-marker))
  (with-slots (elements element-type) marker
    (if (slot-boundp marker 'length)
        (with-slots (length) marker
          (let ((supplied-length (length elements)))
            (fill (replace (make-array length :element-type element-type)
                           elements)
                  (elt elements (1- supplied-length))
                  :start supplied-length)))
        (coerce elements `(vector ,element-type)))))

;; Adapted from SBCL's |sharp-left-paren|.
(defun simple-vector-reader (stream sub-char arg)
  (declare (ignore sub-char))
  (let* ((list (read-delimited-list #\) stream t))
         (length (handler-case (length list)
                   (type-error (error)
                     (declare (ignore error))
                     (simple-reader-error
                      stream "improper list in #(): ~S" list)))))
    (unless *read-suppress*
      (if arg
          (if (> length arg)
              (simple-reader-error
               stream "vector longer than specified length: #~S~S" arg list)
              (make-instance 'simple-vector-marker :length arg :elements list))
          (make-instance 'simple-vector-marker :elements list)))))

(dolist (mode '(:lisp :inner-lisp))
  (set-dispatch-macro-character #\# #\( #'simple-vector-reader ;
                                (readtable-for-mode mode)))

@ Sharpsign asterisk is similar to sharpsign left-parenthesis, but the token
following the asterisk must be composed entirely of \.{0}s and \.{1}s, which
are used to initialize a simple bit vector. It supports the same kind of
abbreviation that \.{\#()} does.

But note the use of the word `token' above. By defining \.{\#*} in terms of the
{\it token\/} following the \.{*}, the authors of the standard have made it
very, very difficult for a portable program to emulate the specified behavior,
since only the built-in reader knows how to tokenize for the current
readtable. What we do is resort to a dirty trick: we set up an echo stream,
use the standard reader to parse the bit vector, then build our marker from
the echoed characters.

@l
(defclass bit-vector-marker (simple-vector-marker) ()
  (:default-initargs :element-type 'bit))

(defun simple-bit-vector-reader (stream sub-char arg)
  (declare (ignore sub-char))
  (with-open-stream (out (make-string-output-stream))
    (with-open-stream (echo (make-echo-stream stream out))
      (with-open-stream (rewind (make-concatenated-stream
                                 (make-string-input-stream
                                  (format nil "#~@[~D~]*" arg))
                                 echo))
        (let ((*readtable* (readtable-for-mode nil)))
          (read rewind))
        (let ((bits @<Build a bit vector...@>))
          (if arg
              (make-instance 'bit-vector-marker :length arg :elements bits)
              (make-instance 'bit-vector-marker :elements bits)))))))

(dolist (mode '(:lisp :inner-lisp))
  (set-dispatch-macro-character #\# #\* #'simple-bit-vector-reader ;
                                (readtable-for-mode mode)))

@ The string output stream |out| should now contain the `0' and~`1'
characters that make up the bit vector. But it might also contain the
delimiter that terminates the token, so we have to be careful.

@<Build a bit vector from the characters accumulated in |out|@>=
(map 'bit-vector
     (lambda (c) (ecase c (#\0 0) (#\1 1)))
     (let* ((bit-string (get-output-stream-string out))
            (length (length bit-string)))
       (subseq bit-string 0 (case (elt bit-string (1- length))
                              ((#\0 #\1) length)
                              (t (1- length))))))

@ Sharpsign dot permits read-time evaluation. Ordinarily, of course, the form
evaluated is lost, as only the result of the evaluation is returned.

@l
(defclass readtime-eval-marker (marker)
  ((form :reader read-eval-form :initarg :form)))

(defun sharpsign-dot-reader (stream sub-char arg)
  (declare (ignore sub-char arg))
  (let ((form (read stream t nil t)))
    (unless *read-suppress*
      (unless *read-eval*
        (simple-reader-error stream "can't read #. while *READ-EVAL* is NIL"))
      (make-instance 'readtime-eval-marker :form form :value (eval form)))))

(dolist (mode '(:lisp :inner-lisp))
  (set-dispatch-macro-character #\# #\. #'sharpsign-dot-reader ;
                                (readtable-for-mode mode)))

@ Sharpsign B, O, X, and~R all represent rational numbers in a specified radix,
but that radix is discarded by the standard reader.

@l
(defclass radix-marker (marker)
  ((base :reader radix-marker-base :initarg :base)))

(defvar *radix-prefix-alist* '((#\B . 2) (#\O . 8) (#\X . 16) (#\R . nil)))

(defun radix-reader (stream sub-char arg)
  (make-instance 'radix-marker
                 :base (or (cdr (assoc sub-char *radix-prefix-alist*)) arg) 
                 :value (call-standard-sharpm-fun stream sub-char arg)))

(dolist (mode '(:lisp :inner-lisp))
  (dolist (sub-char '(#\B #\O #\X #\R))
    (set-dispatch-macro-character #\# sub-char #'radix-reader ;
                                  (readtable-for-mode mode))))

@ Sharpsign~S requires determining the standard constructor function of the
structure type named, which we simply can't do portably. So, we use the same
trick we used for backquote above: we cache the form as given, then dump it
out to a string and let the standard reader parse it when we need the value.

@l
(defclass structure-marker (marker)
  ((form :reader structure-marker-form :initarg :form)))

(defmethod marker-boundp ((marker structure-marker)) t)
(defmethod marker-value ((marker structure-marker))
  (with-standard-io-syntax
    (read-from-string (prin1-to-string marker))))

(defmethod print-object ((obj structure-marker) stream)
  (format stream "#S~W" (structure-marker-form obj)))

(defun structure-reader (stream sub-char arg)
  (declare (ignore sub-char arg))
  (make-instance 'structure-marker :form (read stream t nil t)))

(dolist (mode '(:lisp :inner-lisp))
  (set-dispatch-macro-character #\# #\S #'structure-reader ;
                                (readtable-for-mode mode)))

@ Okay, so much for the standard macro characters. Now we're ready to move
on to \WEB-specific reading. We accumulate \TeX\ mode material such as
commentary, section names, \etc. using the following function, which reads
from |stream| until encountering either {\sc EOF} or a {\it control
character\/}. The set of control characters is given by the |control-chars|
argument, which should be a designator for a list of characters.

@l
(defun snarf-until-control-char (stream control-chars &aux
                                 (control-chars (if (listp control-chars)
                                                    control-chars
                                                    (list control-chars))))
  (with-output-to-string (string)
    (loop for char = (peek-char nil stream nil *eof* nil)
          until (or (eof-p char) (member char control-chars))
            do (write-char (read-char stream) string))))

@ In \TeX\ mode (including restricted contexts), we allow embedded Lisp
code to be surrounded by \pb, where it is read in inner-Lisp mode, which is
almost, but not quite, the same as Lisp mode.

@l
(defun read-inner-lisp (stream char)
  (with-mode :inner-lisp
    (read-delimited-list char stream t)))

(dolist (mode '(:TeX :restricted))
  (set-macro-character #\| #'read-inner-lisp nil (readtable-for-mode mode)))

@ The call to |read-delimited-list| in |read-inner-lisp| will only stop at
the closing \v\ if we set it to be a terminating macro character,
overriding its usual Lisp meaning as an escape character. The following
makes it an error to use \v\ in inner-Lisp mode.

@l
(set-macro-character #\| (get-macro-character #\) nil)
                     nil (readtable-for-mode :inner-lisp))

@ We make |#\@| a non-terminating dispatching macro character in every
mode, and define some convenience routines for retrieving and setting the
reader macro functions that implement the control codes.

@l
(dolist (mode *modes*)
  ;; The CL standard does not say that calling |make-dispatch-macro-character|
  ;; on a character that's already a dispatching macro character is supposed
  ;; to signal an error, but SBCL does so; hence the |ignore-errors|.
  (ignore-errors
    (make-dispatch-macro-character #\@ t (readtable-for-mode mode))))

(defun get-control-code (sub-char mode)
  (get-dispatch-macro-character #\@ sub-char (readtable-for-mode mode)))

(defun set-control-code (sub-char function &optional (modes *modes*))
  (dolist (mode modes)
    (set-dispatch-macro-character #\@ sub-char function
                                  (readtable-for-mode mode))))

@ The control code \.{@@@@} yields the string `\.{"@@"}' in all modes, but
it should really only be used in \TeX\ text.

@l
(set-control-code #\@ (lambda (stream sub-char arg)
                        (declare (ignore sub-char stream arg))
                        (string "@")))

@ Sections are introduced by the two section-starting control codes, \.{@@ }
and~\.{@@*}, which differ only in the way they are output during weaving.
The reader macro functions that implement these control codes return an
instance of the appropriate section class.

@l
(defun start-section-reader (stream sub-char arg)
  (declare (ignore stream arg))
  (make-instance (ecase sub-char
                   (#\Space 'section)
                   (#\* 'starred-section))))

(dolist (sub-char '(#\Space #\*))
  (set-control-code sub-char #'start-section-reader '(:limbo :TeX :lisp)))

@ The control codes \.{@@l} and ~\.{@@p} (where `l' is for `Lisp' and `p'
is for `Program'---both control codes do the same thing) begin the code
part of an unnamed section. They are recognized only in \TeX\ mode---every
section must begin with a commentary, even if it is empty.

The control code \.{@@e} (`e' for `evaluate') is similar to \.{@@l} in that
it begins the code part of an unnamed section, but every form in that part
is evaluated at read-time {\it in addition to\/} being tangled and therefore
evaluated at run-time and possibly compile-time, too. Sections containing
evaluated code-parts should be used only for establishing state that is
needed by the reader: package definitions, structure definitions that are
used with the \.{\#S} reader macro, \etc.

@l
(defclass start-code-marker (marker)
  ((name :reader section-name :initarg :name)
   (evalp :reader evaluated-code-p :initarg :evalp))
  (:default-initargs :name nil :evalp nil))

(defun start-code-reader (stream sub-char arg)
  (declare (ignore stream arg))
  (make-instance 'start-code-marker
                 :evalp (ecase sub-char
                          ((#\L #\P) nil)
                          ((#\E) t))))

(dolist (sub-char '(#\l #\p #\e))
  (set-control-code sub-char #'start-code-reader '(:TeX)))

@ Several control codes, including \.{@@<}, contain `restricted' \TeX\ text,
called {\it control text}, that extends to the matching \.{@@>}. When we
first read control text, we ignore inner-Lisp material (that is, Lisp forms
surrounded by \pb). During weaving, we'll re-scan it to pick up such
material.

@l
(defvar *end-control-text* (make-symbol "@>"))
(set-control-code #\> (constantly *end-control-text*) '(:restricted))

(defun read-control-text (stream)
  (with-mode :restricted
    (apply #'concatenate 'string
           (loop for text = (snarf-until-control-char stream #\@)
                 as x = (read-preserving-whitespace stream t nil t)
                 collect text
                 until (eq x *end-control-text*) collect x))))

@ The control code \.{@@<} introduces a section name, which extends to the
closing \.{@@>}. Its meaning is context-dependent.

In \TeX\ mode, a name must be followed by \.{=}, in which case it indicates
that the name should be attached to the current section and begins the
code part of the section.

In Lisp and inner-Lisp modes, a name is taken to refer to the section so
named. During tangling, such references in Lisp mode will be replaced with
the code defined for that section. References in inner-Lisp mode are used
only during weaving.

@l
(defun make-section-name-reader (definition-allowed-p)
  (lambda (stream sub-char arg)
    (declare (ignore sub-char arg))
    (let* ((name (read-control-text stream))
           (definition-p (eql (peek-char nil stream nil nil t) #\=)))
      (if definition-p
          (if definition-allowed-p
              (progn
                (read-char stream)
                (make-instance 'start-code-marker :name name))
              @<Signal an error about section definition in Lisp mode@>)
          (if definition-allowed-p
               @<Signal an error about section name use in \TeX\ mode@>
               (let ((named-section (find-section name)))
                 (pushnew (current-section) (used-by named-section))
                 named-section))))))

(set-control-code #\< (make-section-name-reader t) '(:TeX))
(set-control-code #\< (make-section-name-reader nil) '(:lisp :inner-lisp))

@ @<Signal an error about section definition in Lisp mode@>=
(restart-case
    (error "Can't define a named section in Lisp mode: ~A" name)
  (use-section ()
    :report "Don't define the section, just use it."
    (find-section name)))

@ @<Signal an error about section name use in \TeX\ mode@>=
(restart-case
    (error "Can't use a section name in TeX mode: ~A" name)
  (name-section ()
    :report "Name the current section and start the code part."
    (make-instance 'start-code-marker :name name))
  (cite-section ()
    :report "Assume the section is just being cited."
    (find-section name)))

@ We need one last utility before coming to the main section reader.
When we're accumulating text, we don't want to bother with empty strings.
So we use the following macro, which is like |push|, but does nothing if
the new object is an empty string or |nil|.

@l
(defmacro maybe-push (obj place &aux (g (gensym)))
  `(let ((,g ,obj))
     (when (typecase ,g
             (string (plusp (length ,g)))
             (t ,g))
       (push ,g ,place))))

@ We come now to the heart of the \WEB\ parser. This function is a
tiny state machine that models the global syntax of a \WEB\ file.
(We can't just use reader macros since sections and their parts lack
explicit closing delimiters.) It returns a list of |section| objects.

@l
(defun read-sections (input-stream append-p)
  (with-charpos-input-stream (stream input-stream)
    (flet ((finish-section (section commentary code)
             @<Trim whitespace and reverse...@>
             (setf (section-commentary section) commentary)
             (setf (section-code section) code)
             (when (section-name section) @<Setup named section...@>)
             section))
      (prog (form commentary code section sections)
       limbo
         (setq section (make-instance 'limbo-section))
         @<Accumulate limbo text in |commentary|@>
       commentary
         (push (finish-section section commentary code) sections)
         @<Initialize section variables@>
         @<Accumulate \TeX-mode material in |commentary|@>
       lisp
         @<Accumulate Lisp-mode material in |code|@>
       eof
         (push (finish-section section commentary code) sections)
         (return (nreverse sections))))))

@ Limbo text is \TeX\ text that proceeds the first section marker, and we
treat it as commentary for a special section with no code. Note that
inner-Lisp material is not recognized in limbo text.

@<Accumulate limbo text in |commentary|@>=
(with-mode :limbo
  (loop
    (maybe-push (snarf-until-control-char stream #\@) commentary)
    (setq form (read-preserving-whitespace stream nil *eof* nil))
    (typecase form
      (eof (go eof))
      (section (go commentary))
      (t (push form commentary)))))

@ @<Initialize section variables@>=
(check-type form section)
(setq section form
      commentary '()
      code '())

@ The commentary part that begins a section consists of \TeX\ text and
inner-Lisp material surrounded by \pb. It is terminated by either the start
of a new section, the beginning of the code part, or {\sc EOF}. If a code
part is detected, we also set the name of the current section, which may be
|nil|.

@<Accumulate \TeX-mode material in |commentary|@>=
(with-mode :TeX
  (loop
    (maybe-push (snarf-until-control-char stream '(#\@ #\|)) commentary)
    (setq form (read-preserving-whitespace stream nil *eof* nil))
    (typecase form
      (eof (go eof))
      (section (go commentary))
      (start-code-marker (setf (section-name section) (section-name form))
                         (go lisp))
      (t (push form commentary)))))

@ The code part of a section consists of zero or more Lisp forms and is
terminated by either {\sc EOF} or the start of a new section. If the code
part was begun by a \.{@@e} control code, we evaluate the code forms as we
read them.

We also don't push newline markers if no code has been accumulated yet, nor
do we accumulate more than one in a row. This simplifies the logic of the
weaver.

@<Accumulate Lisp-mode material in |code|@>=
(check-type form start-code-marker)
(with-mode :lisp
  (let ((evalp (evaluated-code-p form)))
    (loop
      (setq form (read-preserving-whitespace stream nil *eof* nil))
      (typecase form
        (eof (go eof))
        (section (go commentary))
        (start-code-marker (error "Can't start a section with a code part"))
        (newline-marker (unless (or (null code) (newline-p (car code)))
                          (push form code)))
        (t (when evalp (eval (tangle form)))
           (push form code))))))

@ We trim trailing whitespace from the last string in |commentary|, leading
whitespace from the first, and any trailing newline marker from |code|.
(Leading newlines are handled in |@<Accumulate Lisp-mode...@>|.)
We then reverse both lists.

@<Trim whitespace and reverse |commentary| and |code|@>=
(when (stringp (car commentary))
  (rplaca commentary (string-right-trim *whitespace* (car commentary))))
(setq commentary (nreverse commentary))
(when (stringp (car commentary))
  (rplaca commentary (string-left-trim *whitespace* (car commentary))))
(setq code (nreverse (if (newline-p (car code)) (cdr code) code)))

@ @<Setup named section code, number, and cross-references@>=
(let ((named-section (find-section (section-name section)))
      (number (section-number section))
      (code (section-code section)))
  (set-named-section-code named-section code append-p)
  (when (or (not (slot-boundp named-section 'number))
            (not append-p))
    (setf (section-number named-section) number))
  (if append-p
      (pushnew section (see-also named-section))
      (setf (see-also named-section) (list section))))

@*The tangler. Tangling involves recursively replacing each reference to a
named section with the code accumulated for that section. The function
|tangle-1| expands one level of such references, returning the
possibly-expanded form, and a boolean representing whether or not any
expansions were actually performed.

Note that this is a splicing operation, not a simple replacement: if
\X$n$:foo\X$\mathrel\E$|(x y)|, then
\(\\{tangle-1} \'\(\\{a} \X$n$:foo\X\ \\{b}\)\)$\to$|(a x y b)|,~|t|.

Tangling also replaces bound markers with their associated values, and
removes unbound markers.

@l
(defun tangle-1 (form)
  (cond ((list-marker-p form) (values (marker-value form) t))
        ((atom form) (values form nil))
        ((typep (car form) 'named-section)
         (values (append (section-code (car form)) (tangle-1 (cdr form))) t))
        ((typep (car form) 'marker)
         (values (if (marker-boundp (car form))
                     (cons (marker-value (car form)) (tangle-1 (cdr form)))
                     (tangle-1 (cdr form)))
                 t))
        (t (multiple-value-bind (a car-expanded-p) (tangle-1 (car form))
             (multiple-value-bind (d cdr-expanded-p) (tangle-1 (cdr form))
               (values (if (and (eql a (car form))
                                (eql d (cdr form)))
                           form
                           (cons a d))
                       (or car-expanded-p cdr-expanded-p)))))))

@ |tangle| repeatedly calls |tangle-1| on |form| until it can no longer be
expanded. Like |tangle-1|, it returns the possibly-expanded form and an
`expanded' flag.

@l
(defun tangle (form)
  (labels ((expand (form expanded)
             (multiple-value-bind (new-form newly-expanded-p)
                 (tangle-1 form)
               (if newly-expanded-p
                   (expand new-form t)
                   (values new-form expanded)))))
    (expand form nil)))

@ A little utility function invokes the main section reader and returns a
list of all of the forms in all of the unnamed sections' code parts.

@l
(defun read-code-parts (stream append-p)
  (apply #'append
         (map 'list
              #'section-code
              (remove-if #'section-name (read-sections stream append-p)))))

@ We're now ready for the high-level tangler interface. We begin with
|load-web|, which uses a helper function, |load-web-from-stream|, so
that it can handle input from a file or an arbitrary stream. The logic
is straightfoward: loop over the tangled forms read from the stream,
evaluating each one in turn.

Note that like |load|, we bind |*readtable*| and |*package*| to their
current values, so that assignments to those variables in the \WEB\ code
will not effect the calling environment.

@l
(defun load-web-from-stream (stream print &optional (append-p t))
  (let ((*readtable* *readtable*)
        (*package* *package*)
        #+sbcl(sb-ext:*evaluator-mode* :compile))
    (dolist (form (tangle (read-code-parts stream append-p)) t)
      (if print
          (let ((results (multiple-value-list (eval form))))
            (format t "~&; ~{~S~^, ~}~%" results))
          (eval form)))))

(defun load-web (filespec &key
                 (verbose *load-verbose*)
                 (print *load-print*)
                 (if-does-not-exist t)
                 (external-format :default))
  @<Initialize global variables@>
  (when verbose (format t "~&; loading WEB from ~S~%" filespec))
  (if (streamp filespec)
      (load-web-from-stream filespec print)
      (with-open-file (stream filespec
                       :direction :input
                       :external-format external-format
                       :if-does-not-exist (if if-does-not-exist :error nil))
        (load-web-from-stream stream print))))

@ This next function exists solely for the sake of front-ends that wish to
load a piece of a \WEB, such as the author's `\.{clweb.el}'. Note that it
does {\it not\/} initialize the global variables like |*named-sections*|;
this allows for incremental redefinition.

@l
(defun load-sections-from-temp-file (file append-p &aux
                                     (truename (probe-file file)))
  (when truename
    (unwind-protect
         (with-open-file (stream truename :direction :input)
           (load-web-from-stream stream t append-p))
      (delete-file truename))))

@ The file tangler operates by writing out the tangled code to a Lisp source
file and then invoking the file compiler on that file.

@l
(defun tangle-file (input-file &rest args &key
                    output-file
                    (verbose *compile-verbose*)
                    (print *compile-print*)
                    (external-format :default) &allow-other-keys &aux
                    (lisp-file (merge-pathnames (make-pathname :type "lisp")
                                                input-file)))
  (declare (ignore output-file print))
  (when verbose (format t "~&; tangling WEB from ~S~%" input-file))
  @<Initialize global variables@>
  (with-open-file (input input-file
                         :direction :input
                         :external-format external-format)
    (with-open-file (lisp lisp-file
                          :direction :output
                          :if-exists :supersede
                          :external-format external-format)
      (format lisp ";;;; TANGLED OUTPUT FROM WEB ~S. DO NOT EDIT." input-file)
      (dolist (form (tangle (read-code-parts input t)))
        (pprint form lisp))))
  (apply #'compile-file lisp-file args))

@*The weaver. Most of the hard work is done while reading the sections in,
so weaving consists almost entirely of pretty-printing.

@ We set up our own pretty-print dispatch table for weaving, and a utility
function for setting its entries.

@l
(defparameter *weave-pprint-dispatch* (copy-pprint-dispatch nil))

(defun set-weave-dispatch (type-specifier function &optional (priority 0))
  (set-pprint-dispatch type-specifier function priority
                       *weave-pprint-dispatch*))

@ @l
(defun weave (filespec &key
              (output-file nil)
              (verbose *load-verbose*)
              (print *load-print*)
              (if-does-not-exist t)
              (external-format :default))
  (unless output-file
    (setq output-file (merge-pathnames (make-pathname :type "tex") filespec)))
  (load-web filespec
            :verbose verbose
            :print print
            :if-does-not-exist if-does-not-exist
            :external-format external-format)
  (weave-sections *sections* output-file))

@ @l
(defun weave-sections (sections output-file)
  (with-open-file (output output-file
                   :direction :output
                   :if-exists :supersede)
    (format output "\\input clwebmac~%")
    (loop with *print-case* = :downcase
          with *print-escape* = nil
          with *print-pretty* = t
          with *print-pprint-dispatch* = *weave-pprint-dispatch*
          with *print-right-margin* = 1000
          for section across sections
          do (write section :stream output)
          finally (format output "~&\\bye~%"))))

@ \TeX-mode material consists of a list of strings containing pure \TeX\ text
and lists of (inner-)Lisp forms. We set |*inner-lisp*| to true when we're
printing inner-Lisp-mode material so that we can adjust our pretty-printing.

@l
(defvar *inner-lisp* nil)

(defun print-TeX (stream tex-mode-material)
  (dolist (x tex-mode-material)
    (etypecase x
      (string (write-string x stream))
      (list (let ((*inner-lisp* t))
              (dolist (form x)
                (format stream "{\\IB/~W}" form)))))))

@ Control text (like section names) and comments are initially read as
strings containing pure \TeX\ text, but they actually contain restricted
\TeX-mode material, which may include inner-Lisp material. This routine
re-reads such strings and picks up any inner-Lisp material.

@l
(defun read-TeX-from-string (input-string)
  (with-input-from-string (input-stream input-string)
    (with-charpos-input-stream (stream input-stream)
      (with-mode :restricted
        (loop for text = (snarf-until-control-char stream #\|)
              for forms = (read-preserving-whitespace stream nil *eof* nil)
              collect text
              until (eof-p forms) collect forms)))))

@ @l
(defun print-limbo (stream section)
  (let ((commentary (section-commentary section)))
    (when commentary
      (print-TeX stream commentary))))

(set-weave-dispatch 'limbo-section #'print-limbo 1)

@ @l
(defun print-section (stream section)
  (format stream "~&\\~:[M~;N{1}~]{~D}" ; `\.{\{1\}}' should be depth
          (typep section 'starred-section)
          (section-number section))
  (let* ((commentary (section-commentary section))
         (name (section-name section))
         (named-section (and name (find-section name)))
         (code (section-code section)))
    (print-TeX stream commentary)
    (fresh-line stream)
    (cond ((and commentary code) (format stream "\\Y\\B~%"))
          (code (format stream "\\B~%")))
    (when named-section
      (print-section-name stream named-section)
      (format stream "${}~:[\\mathrel+~;~]\\E{}$~%"
              (= (section-number section) (section-number named-section))))
    (when code
      (dolist (form code)
        (if (list-marker-p form)
            (format stream "~@<\\+~@;~W~;\\cr~:>" form)
            (format stream "~W" form)))
      (format stream "~&\\egroup~%")) ; matches \.{\\bgroup} in \.{\\B}
    (when named-section
      (print-xrefs stream #\A (remove section (see-also named-section)))
      (print-xrefs stream #\U (remove section (used-by named-section)))))
  (format stream "\\fi~%"))

(set-weave-dispatch 'section #'print-section)

@ The cross-references lists use the macros \.{\\A} (for `also'), \.{\\U}
(for `use'), \.{\\Q} (for `quote'), and their pluralized variants, along
with the conjunction macros \.{\\ET} (for two section numbers) and~\.{\\ETs}
(for between the last of three or more).

@l
(defun print-xrefs (stream kind xrefs)
  (when xrefs
    ;; This was 16 lines of code over two sections in \CWEB. I love |format|.
    (format stream "\\~C~{~#[~;~D~;s ~D\\ET~D~:;s~@{~#[~;\\ETs~D~;~D~:;~D, ~]~}~]~}.~%"
            kind (sort (mapcar #'section-number xrefs) #'<))))

@ @l
(defun print-section-name (stream named-section)
  (format stream "\\X~D:" (section-number named-section))
  (print-TeX stream (read-TeX-from-string (section-name named-section)))
  (write-string "\\X" stream))

(set-weave-dispatch 'named-section #'print-section-name)

@ Because we're outputting \TeX, we need to carefully escape characters that
\TeX\ treats as special. Unfortunately, because \TeX's syntax is so malleable
(not unlike Lisp's), it's nontrivial to decide what to escape, how, and when.

The following routine is the basis for most of the escaping. It writes the
given string to an output stream, escaping the characters given in the
|escape-chars| a-list. The entries in this a-list should be of the form
`(\metasyn{characters}~.~\metasyn{replacement})', where
\metasyn{characters} is a string of characters to be escaped with
\metasyn{replacement}, which may be a single character, in which case that
character is output before any occurrences of \metasyn{character}, or a
string, in which case it is output instead of the character being considered.

@l
(defun write-escaped-string (stream string escape-chars)
  (dotimes (i (length string))
    (let* ((char (char string i))
           (escape (cdr (assoc char escape-chars :test #'find))))
      (etypecase escape
        (character (write-char escape stream)
                   (write-char char stream))
        (string (write-string escape stream))
        (null (write-char char stream))))))

(defparameter *tex-escape-alist*
  '((" \\%&#$^_~<>" . #\\) ("{" . "$\\{$") ("}" . "$\\}$")))

@ @l
(defun print-string (stream string)
  (write-string "\\.{\"" stream)
  (write-escaped-string stream string
                        (list* '("{}" . #\\)
                               '("\\" . "\\\\\\\\")
                               '("\"" . "\\\\\"")
                               *tex-escape-alist*))
  (write-string "\"}" stream))

(set-weave-dispatch 'string #'print-string)

@ @l
(defun print-char (stream char)
  (let ((graphicp (and (graphic-char-p char)
                       (standard-char-p char)))
        (name (char-name char)))
    (write-string "\\#\\CH{" stream)
    (write-escaped-string stream
                          (if (and name (not graphicp))
                              name
                              (make-string 1 :initial-element char))
                          (list* '("{}" . #\\) *tex-escape-alist*))
    (write-string "}" stream)
    char))

(set-weave-dispatch 'character #'print-char)

@ Some symbols are sometimes printed using a special format for
emphasis. These symbols include (but are not limited to) the Common Lisp
special operators, $\lambda$-list keywords, and symbols whose names begin
with `def'.

@l
(defvar *highlight-special-symbols* nil)

(defun def-p (symbol)
  (when (fboundp symbol)
    (let* ((name (symbol-name symbol))
           (len (length name)))
      (and (> len 3) (string= name "DEF" :end1 3)))))

(defun highlight-symbol-p (symbol)
  (cond ((or (special-operator-p symbol)
             (member symbol '(cond loop)))
         (member :special-operator *highlight-special-symbols*))
        ((member symbol lambda-list-keywords)
         (member :lambda-list-keyword *highlight-special-symbols*))
        ((def-p symbol)
         (member :def *highlight-special-symbols*))))

@ @l
(defun print-symbol (stream symbol)
  (let ((group-p (cond ((highlight-symbol-p symbol)
                        (write-string "\\&{" stream))
                       ((keywordp symbol)
                        (write-string "\\:{" stream)))))
    (write-escaped-string stream
                          (write-to-string symbol :escape nil :pretty nil)
                          *tex-escape-alist*)
    (when group-p (write-string "}" stream))))

(set-weave-dispatch 'symbol #'print-symbol)

@ Next, we turn to list printing, and the tricky topic of indentation. On
the assumption that the human writing the code in a \WEB\ is smarter than
any sort of automatic indentation that we might be able to do, we attempt
to approximate (but {\it not\/} duplicate) on output the indentation given
in the input by utilizing the character position values that the list
reader stores in the list markers.

We do this by breaking up lists into {\it logical blocks\/}---the same sort
of (abstract) entities that the pretty printer uses, but made concrete
here. A logical block defines a left edge for a list of forms, some of
which may be nested logical blocks.

@l
(defstruct (logical-block (:constructor make-logical-block (list)))
  list)

@ The analysis of the indentation is performed by a recursive |labels|
routine, to which we will come in a moment. That routine operates on an
list of |(form . charpos)| conses, taken from a list marker. Building this
list does cost us some consing, but vastly simplifies the logic, since we
don't have to worry about keeping multiple indices synchronized.

@l
(defun analyze-indentation (list-marker)
  (declare (type list-marker list-marker))
  (labels ((find-next-newline (list) (member-if #'newline-p list :key #'car))
           (next-logical-block (list) @<Build a logical block from |list|@>))
    (assert (= (length (list-marker-list list-marker))
               (length (list-marker-charpos list-marker))))
    (next-logical-block (mapcar #'cons
                                (list-marker-list list-marker)
                                (list-marker-charpos list-marker)))))

@ To build a logical block, we identify groups of sub-forms that share a
common left margin, which we'll call the {\it block indentation}. If that
left margin is to the right of that of the current block, we recursively
build a new subordinate logical block. The block ends when the first form
on the next line falls to the left of the current block, or we run out of
forms.

For example, consider the following simple form:
$$\vbox{\B\+(first \!&second\cr\+&third)\cr\egroup}$$
\noindent We start off with an initial logical block with an indentation of
the character position of |first|: this is the {\it block indentation}.
Then we look at |second|, and see that the first form on the following
line, |third|, has the same position, and that it exceeds the current
indentation level. And so we recurse, appending to the new logical block
until we encounter a form whose indentation is less than the new block
indentation, or, as in this trivial example, the end of the list.

More concretely, |next-logical-block| returns two values: the logical block
constructed, and the unused portion of the list, which will always either
be |nil| (we consumed the rest of the forms), or begin with a newline.

We keep a pointer to the next newline in |newline|, and |next-indent| is
the indentation of the immediately following form, which will become the
current indentation when we pass |newline|.  As we do so, we store the
difference between the current indentation and the block indentation in
the newline marker, so that the printing routine, below, doesn't have to
worry about character positions at all: it can just look at the newline
markers and the logical block structure.

As an optimization, if we build a block that doesn't directly contain any
newlines---a trivial logical block---we simply return a list of sub-forms
instead of a logical block structure. This allows the printer to elide the
alignment tabs, and makes the resulting \TeX\ much simpler.

@<Build a logical block...@>=
(do* ((block '())
      (block-indent (cdar list))
      (indent block-indent)
      (newline (find-next-newline list))
      (next-indent (cdadr newline)))
     ((or (endp list)
          (and (eq list newline) next-indent (< next-indent block-indent)))
      (values (if (notany #'newline-p block)
                  (nreverse block)
                  (make-logical-block (nreverse block)))
              list))
  (if (and indent next-indent
           (> next-indent indent)
           (= next-indent (cdar list)))
      (multiple-value-bind (sub-block tail) (next-logical-block list)
        (check-type (caar tail) (or newline-marker null))
        (push sub-block block)
        (setq list tail))
      (let ((next (car (pop list))))
        (push next block)
        (when (and list (newline-p next))
          (setf indent (cdar list)
                (indentation next) (- indent block-indent)
                newline (find-next-newline list)
                next-indent (cdadr newline))))))

@ Printing list markers is now simple, since the complexity is all in the
logical blocks.

@l
(defun print-list (stream list-marker)
  (let ((block (analyze-indentation list-marker)))
    (etypecase block
      (list (format stream "~<(~;~@{~W~^ ~}~;)~:>" block))
      (logical-block (format stream "(~W)" block)))))

(set-weave-dispatch 'list-marker #'print-list)

@ But even here, it's not that bad. We start with a \.{\\!}, which is
just an alias for \.{\\cleartabs}. Then we call (unsurprisingly)
|pprint-logical-block|, using a per-line-prefix for our alignment tabs.

In the loop, we keep a one-token look-ahead to check for newlines, so that
we can output separating spaces when and only when there isn't a newline
coming up.

The indentation set on the newlines by the logical-block building machinery
above is the difference in character positions of the first form following
the newline and the block indentation. For differences of 1 or~2 columns,
we use a single quad (\.{\\1}); for any more, we use two (\.{\\2}).

@l
(defun print-logical-block (stream block)
  (write-string "\\!" stream)
  (pprint-logical-block (stream (logical-block-list block) :per-line-prefix "&")
    (do (indent
         next
         (obj (pprint-pop) next))
        (nil)
      (cond ((newline-p obj)
             (format stream "\\cr~:@_")
             (setq indent (indentation obj))
             (pprint-exit-if-list-exhausted)
             (setq next (pprint-pop)))
            (t (format stream "~@[~[~;\\1~;\\1~:;\\2~]~]~W" indent obj)
               (setq indent nil)
               (pprint-exit-if-list-exhausted)
               (setq next (pprint-pop))
               (unless (newline-p next)
                 (write-char #\Space stream)))))))

(set-weave-dispatch 'logical-block #'print-logical-block)

@ Markers.

@l
(set-weave-dispatch 'newline-marker
                    (lambda (stream obj)
                      (declare (ignore obj))
                      (terpri stream)))

(set-weave-dispatch 'empty-list-marker
                    (lambda (stream obj)
                      (declare (ignore obj))
                      (write-string "()" stream)))

(set-weave-dispatch 'consing-dot-marker
                    (lambda (stream obj)
                      (declare (ignore obj))
                      (write-char #\. stream)))

(set-weave-dispatch 'quote-marker
                    (lambda (stream obj)
                      (format stream "\\'~W" (quoted-form obj))))

(set-weave-dispatch 'comment-marker
                    (lambda (stream obj)
                      (write-string "\\C{" stream)
                      (print-TeX stream (read-TeX-from-string (comment-text obj)))
                      (write-string "}" stream)))

@ @l
(set-weave-dispatch 'backquote-marker
                    (lambda (stream obj)
                      (format stream "\\`~W" (backq-form obj))))

(set-weave-dispatch 'comma-marker
                    (lambda (stream obj)
                      (format stream "\\CO{~@[~C~]}~W"
                              (comma-modifier obj)
                              (comma-form obj))))

@ @l
; Need a higher priority than |quote-marker|.
(set-weave-dispatch 'function-marker
                    (lambda (stream obj)
                      (format stream "\\#\\'~S" (quoted-form obj)))
                    1)

@ @l
(set-weave-dispatch 'simple-vector-marker
                    (lambda (stream obj)
                      (format stream "\\#~@[~D~]~S"
                              (and (slot-boundp obj 'length)
                                   (slot-value obj 'length))
                              (slot-value obj 'elements))))

; Need a higher priority than |simple-vector-marker|.
(set-weave-dispatch 'bit-vector-marker
                    (lambda (stream obj)
                      (format stream "\\#~@[~D~]*~{~[0~;1~]~}"
                              (and (slot-boundp obj 'length)
                                   (slot-value obj 'length))
                              (map 'list #'identity
                                   (slot-value obj 'elements))))
                    1)

@ @l
(set-weave-dispatch 'readtime-eval-marker
                    (lambda (stream obj)
                      (format stream "\\#.~W" (read-eval-form obj))))

@ @l
(set-weave-dispatch 'radix-marker
                    (lambda (stream obj)
                      (let ((*print-radix* nil)
                            (*print-base* (radix-marker-base obj)))
                        (princ (marker-value obj) stream)
                        (format stream "_{~D}" *print-base*))))

@ @l
(set-weave-dispatch 'structure-marker
                    (lambda (stream obj)
                      (format stream "\\#S~W" (structure-marker-form obj))))
